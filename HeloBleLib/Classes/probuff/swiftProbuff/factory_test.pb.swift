// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: factory_test.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum FactoryTestMode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case dischargeMode // = 0
  case chargingMode // = 1
  case pressureMode // = 2
  case placeMode // = 3
  case sensorMode // = 4
  case autoTestMode // = 5
  case fullyAutoResultMode // = 6

  init() {
    self = .dischargeMode
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .dischargeMode
    case 1: self = .chargingMode
    case 2: self = .pressureMode
    case 3: self = .placeMode
    case 4: self = .sensorMode
    case 5: self = .autoTestMode
    case 6: self = .fullyAutoResultMode
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .dischargeMode: return 0
    case .chargingMode: return 1
    case .pressureMode: return 2
    case .placeMode: return 3
    case .sensorMode: return 4
    case .autoTestMode: return 5
    case .fullyAutoResultMode: return 6
    }
  }

}

#if swift(>=4.2)

extension FactoryTestMode: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum TestOperation: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case testStart // = 0
  case testStop // = 1
  case testResult // = 2
  case testLastResult // = 3

  init() {
    self = .testStart
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .testStart
    case 1: self = .testStop
    case 2: self = .testResult
    case 3: self = .testLastResult
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .testStart: return 0
    case .testStop: return 1
    case .testResult: return 2
    case .testLastResult: return 3
    }
  }

}

#if swift(>=4.2)

extension TestOperation: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum FACTORY_PAGE_TEST: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case motor // = 0
  case hx3918ProxCali // = 1
  case prox // = 2
  case light // = 3
  case buzzer // = 4
  case temprature // = 5
  case key // = 6
  case offbody // = 7
  case hr // = 8
  case ecg // = 9
  case knob // = 10
  case pressure // = 11
  case gps // = 12
  case gsmWifi // = 13
  case gsmGps // = 14
  case max32664 // = 15
  case max32664Leak // = 16
  case hrLeak // = 17
  case hrGreyCard // = 18
  case oximeter // = 19
  case hrv // = 20
  case bioz // = 21
  case spl17 // = 22
  case thisResult // = 23
  case gsmInfo // = 24
  case gsmLoop // = 25
  case gsmCall // = 26

  init() {
    self = .motor
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .motor
    case 1: self = .hx3918ProxCali
    case 2: self = .prox
    case 3: self = .light
    case 4: self = .buzzer
    case 5: self = .temprature
    case 6: self = .key
    case 7: self = .offbody
    case 8: self = .hr
    case 9: self = .ecg
    case 10: self = .knob
    case 11: self = .pressure
    case 12: self = .gps
    case 13: self = .gsmWifi
    case 14: self = .gsmGps
    case 15: self = .max32664
    case 16: self = .max32664Leak
    case 17: self = .hrLeak
    case 18: self = .hrGreyCard
    case 19: self = .oximeter
    case 20: self = .hrv
    case 21: self = .bioz
    case 22: self = .spl17
    case 23: self = .thisResult
    case 24: self = .gsmInfo
    case 25: self = .gsmLoop
    case 26: self = .gsmCall
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .motor: return 0
    case .hx3918ProxCali: return 1
    case .prox: return 2
    case .light: return 3
    case .buzzer: return 4
    case .temprature: return 5
    case .key: return 6
    case .offbody: return 7
    case .hr: return 8
    case .ecg: return 9
    case .knob: return 10
    case .pressure: return 11
    case .gps: return 12
    case .gsmWifi: return 13
    case .gsmGps: return 14
    case .max32664: return 15
    case .max32664Leak: return 16
    case .hrLeak: return 17
    case .hrGreyCard: return 18
    case .oximeter: return 19
    case .hrv: return 20
    case .bioz: return 21
    case .spl17: return 22
    case .thisResult: return 23
    case .gsmInfo: return 24
    case .gsmLoop: return 25
    case .gsmCall: return 26
    }
  }

}

#if swift(>=4.2)

extension FACTORY_PAGE_TEST: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct PlacementTestResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var placementTimes: [Int32] = []

  var placementResult: Bool {
    get {return _placementResult ?? false}
    set {_placementResult = newValue}
  }
  /// Returns true if `placementResult` has been explicitly set.
  var hasPlacementResult: Bool {return self._placementResult != nil}
  /// Clears the value of `placementResult`. Subsequent reads from it will return its default value.
  mutating func clearPlacementResult() {self._placementResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _placementResult: Bool? = nil
}

struct ChargeTestResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chargeTimes: [Int32] = []

  var chargeResult: Bool {
    get {return _chargeResult ?? false}
    set {_chargeResult = newValue}
  }
  /// Returns true if `chargeResult` has been explicitly set.
  var hasChargeResult: Bool {return self._chargeResult != nil}
  /// Clears the value of `chargeResult`. Subsequent reads from it will return its default value.
  mutating func clearChargeResult() {self._chargeResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _chargeResult: Bool? = nil
}

struct DischargeTestResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dischargeTimes: [Int32] = []

  var dischargeResult: Bool {
    get {return _dischargeResult ?? false}
    set {_dischargeResult = newValue}
  }
  /// Returns true if `dischargeResult` has been explicitly set.
  var hasDischargeResult: Bool {return self._dischargeResult != nil}
  /// Clears the value of `dischargeResult`. Subsequent reads from it will return its default value.
  mutating func clearDischargeResult() {self._dischargeResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _dischargeResult: Bool? = nil
}

struct PressureTestResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pressureTimes: [Int32] = []

  var pressureResult: Bool {
    get {return _pressureResult ?? false}
    set {_pressureResult = newValue}
  }
  /// Returns true if `pressureResult` has been explicitly set.
  var hasPressureResult: Bool {return self._pressureResult != nil}
  /// Clears the value of `pressureResult`. Subsequent reads from it will return its default value.
  mutating func clearPressureResult() {self._pressureResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pressureResult: Bool? = nil
}

struct AutoTestResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gsensorResult: UInt32 {
    get {return _gsensorResult ?? 0}
    set {_gsensorResult = newValue}
  }
  /// Returns true if `gsensorResult` has been explicitly set.
  var hasGsensorResult: Bool {return self._gsensorResult != nil}
  /// Clears the value of `gsensorResult`. Subsequent reads from it will return its default value.
  mutating func clearGsensorResult() {self._gsensorResult = nil}

  var gsensorChipID: UInt32 {
    get {return _gsensorChipID ?? 0}
    set {_gsensorChipID = newValue}
  }
  /// Returns true if `gsensorChipID` has been explicitly set.
  var hasGsensorChipID: Bool {return self._gsensorChipID != nil}
  /// Clears the value of `gsensorChipID`. Subsequent reads from it will return its default value.
  mutating func clearGsensorChipID() {self._gsensorChipID = nil}

  var ppgResult: UInt32 {
    get {return _ppgResult ?? 0}
    set {_ppgResult = newValue}
  }
  /// Returns true if `ppgResult` has been explicitly set.
  var hasPpgResult: Bool {return self._ppgResult != nil}
  /// Clears the value of `ppgResult`. Subsequent reads from it will return its default value.
  mutating func clearPpgResult() {self._ppgResult = nil}

  var ecgResult: UInt32 {
    get {return _ecgResult ?? 0}
    set {_ecgResult = newValue}
  }
  /// Returns true if `ecgResult` has been explicitly set.
  var hasEcgResult: Bool {return self._ecgResult != nil}
  /// Clears the value of `ecgResult`. Subsequent reads from it will return its default value.
  mutating func clearEcgResult() {self._ecgResult = nil}

  var bpResult: UInt32 {
    get {return _bpResult ?? 0}
    set {_bpResult = newValue}
  }
  /// Returns true if `bpResult` has been explicitly set.
  var hasBpResult: Bool {return self._bpResult != nil}
  /// Clears the value of `bpResult`. Subsequent reads from it will return its default value.
  mutating func clearBpResult() {self._bpResult = nil}

  var tempratureResult: UInt32 {
    get {return _tempratureResult ?? 0}
    set {_tempratureResult = newValue}
  }
  /// Returns true if `tempratureResult` has been explicitly set.
  var hasTempratureResult: Bool {return self._tempratureResult != nil}
  /// Clears the value of `tempratureResult`. Subsequent reads from it will return its default value.
  mutating func clearTempratureResult() {self._tempratureResult = nil}

  var spiFlashResult: UInt32 {
    get {return _spiFlashResult ?? 0}
    set {_spiFlashResult = newValue}
  }
  /// Returns true if `spiFlashResult` has been explicitly set.
  var hasSpiFlashResult: Bool {return self._spiFlashResult != nil}
  /// Clears the value of `spiFlashResult`. Subsequent reads from it will return its default value.
  mutating func clearSpiFlashResult() {self._spiFlashResult = nil}

  var encryptResult: UInt32 {
    get {return _encryptResult ?? 0}
    set {_encryptResult = newValue}
  }
  /// Returns true if `encryptResult` has been explicitly set.
  var hasEncryptResult: Bool {return self._encryptResult != nil}
  /// Clears the value of `encryptResult`. Subsequent reads from it will return its default value.
  mutating func clearEncryptResult() {self._encryptResult = nil}

  var bpVersion: UInt32 {
    get {return _bpVersion ?? 0}
    set {_bpVersion = newValue}
  }
  /// Returns true if `bpVersion` has been explicitly set.
  var hasBpVersion: Bool {return self._bpVersion != nil}
  /// Clears the value of `bpVersion`. Subsequent reads from it will return its default value.
  mutating func clearBpVersion() {self._bpVersion = nil}

  var oaqResult: UInt32 {
    get {return _oaqResult ?? 0}
    set {_oaqResult = newValue}
  }
  /// Returns true if `oaqResult` has been explicitly set.
  var hasOaqResult: Bool {return self._oaqResult != nil}
  /// Clears the value of `oaqResult`. Subsequent reads from it will return its default value.
  mutating func clearOaqResult() {self._oaqResult = nil}

  var iaqResult: UInt32 {
    get {return _iaqResult ?? 0}
    set {_iaqResult = newValue}
  }
  /// Returns true if `iaqResult` has been explicitly set.
  var hasIaqResult: Bool {return self._iaqResult != nil}
  /// Clears the value of `iaqResult`. Subsequent reads from it will return its default value.
  mutating func clearIaqResult() {self._iaqResult = nil}

  var humitureResult: UInt32 {
    get {return _humitureResult ?? 0}
    set {_humitureResult = newValue}
  }
  /// Returns true if `humitureResult` has been explicitly set.
  var hasHumitureResult: Bool {return self._humitureResult != nil}
  /// Clears the value of `humitureResult`. Subsequent reads from it will return its default value.
  mutating func clearHumitureResult() {self._humitureResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _gsensorResult: UInt32? = nil
  fileprivate var _gsensorChipID: UInt32? = nil
  fileprivate var _ppgResult: UInt32? = nil
  fileprivate var _ecgResult: UInt32? = nil
  fileprivate var _bpResult: UInt32? = nil
  fileprivate var _tempratureResult: UInt32? = nil
  fileprivate var _spiFlashResult: UInt32? = nil
  fileprivate var _encryptResult: UInt32? = nil
  fileprivate var _bpVersion: UInt32? = nil
  fileprivate var _oaqResult: UInt32? = nil
  fileprivate var _iaqResult: UInt32? = nil
  fileprivate var _humitureResult: UInt32? = nil
}

struct SensorTestResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var motorResult: UInt32 {
    get {return _storage._motorResult ?? 0}
    set {_uniqueStorage()._motorResult = newValue}
  }
  /// Returns true if `motorResult` has been explicitly set.
  var hasMotorResult: Bool {return _storage._motorResult != nil}
  /// Clears the value of `motorResult`. Subsequent reads from it will return its default value.
  mutating func clearMotorResult() {_uniqueStorage()._motorResult = nil}

  var lightResult: UInt32 {
    get {return _storage._lightResult ?? 0}
    set {_uniqueStorage()._lightResult = newValue}
  }
  /// Returns true if `lightResult` has been explicitly set.
  var hasLightResult: Bool {return _storage._lightResult != nil}
  /// Clears the value of `lightResult`. Subsequent reads from it will return its default value.
  mutating func clearLightResult() {_uniqueStorage()._lightResult = nil}

  var tempratureResult: UInt32 {
    get {return _storage._tempratureResult ?? 0}
    set {_uniqueStorage()._tempratureResult = newValue}
  }
  /// Returns true if `tempratureResult` has been explicitly set.
  var hasTempratureResult: Bool {return _storage._tempratureResult != nil}
  /// Clears the value of `tempratureResult`. Subsequent reads from it will return its default value.
  mutating func clearTempratureResult() {_uniqueStorage()._tempratureResult = nil}

  var hrResult: UInt32 {
    get {return _storage._hrResult ?? 0}
    set {_uniqueStorage()._hrResult = newValue}
  }
  /// Returns true if `hrResult` has been explicitly set.
  var hasHrResult: Bool {return _storage._hrResult != nil}
  /// Clears the value of `hrResult`. Subsequent reads from it will return its default value.
  mutating func clearHrResult() {_uniqueStorage()._hrResult = nil}

  var ecgTouchResult: UInt32 {
    get {return _storage._ecgTouchResult ?? 0}
    set {_uniqueStorage()._ecgTouchResult = newValue}
  }
  /// Returns true if `ecgTouchResult` has been explicitly set.
  var hasEcgTouchResult: Bool {return _storage._ecgTouchResult != nil}
  /// Clears the value of `ecgTouchResult`. Subsequent reads from it will return its default value.
  mutating func clearEcgTouchResult() {_uniqueStorage()._ecgTouchResult = nil}

  var hrvResult: UInt32 {
    get {return _storage._hrvResult ?? 0}
    set {_uniqueStorage()._hrvResult = newValue}
  }
  /// Returns true if `hrvResult` has been explicitly set.
  var hasHrvResult: Bool {return _storage._hrvResult != nil}
  /// Clears the value of `hrvResult`. Subsequent reads from it will return its default value.
  mutating func clearHrvResult() {_uniqueStorage()._hrvResult = nil}

  var lcdResult: UInt32 {
    get {return _storage._lcdResult ?? 0}
    set {_uniqueStorage()._lcdResult = newValue}
  }
  /// Returns true if `lcdResult` has been explicitly set.
  var hasLcdResult: Bool {return _storage._lcdResult != nil}
  /// Clears the value of `lcdResult`. Subsequent reads from it will return its default value.
  mutating func clearLcdResult() {_uniqueStorage()._lcdResult = nil}

  var tpResult: UInt32 {
    get {return _storage._tpResult ?? 0}
    set {_uniqueStorage()._tpResult = newValue}
  }
  /// Returns true if `tpResult` has been explicitly set.
  var hasTpResult: Bool {return _storage._tpResult != nil}
  /// Clears the value of `tpResult`. Subsequent reads from it will return its default value.
  mutating func clearTpResult() {_uniqueStorage()._tpResult = nil}

  var gpsResult: UInt32 {
    get {return _storage._gpsResult ?? 0}
    set {_uniqueStorage()._gpsResult = newValue}
  }
  /// Returns true if `gpsResult` has been explicitly set.
  var hasGpsResult: Bool {return _storage._gpsResult != nil}
  /// Clears the value of `gpsResult`. Subsequent reads from it will return its default value.
  mutating func clearGpsResult() {_uniqueStorage()._gpsResult = nil}

  var biozResult: UInt32 {
    get {return _storage._biozResult ?? 0}
    set {_uniqueStorage()._biozResult = newValue}
  }
  /// Returns true if `biozResult` has been explicitly set.
  var hasBiozResult: Bool {return _storage._biozResult != nil}
  /// Clears the value of `biozResult`. Subsequent reads from it will return its default value.
  mutating func clearBiozResult() {_uniqueStorage()._biozResult = nil}

  var max32664LeakResult: UInt32 {
    get {return _storage._max32664LeakResult ?? 0}
    set {_uniqueStorage()._max32664LeakResult = newValue}
  }
  /// Returns true if `max32664LeakResult` has been explicitly set.
  var hasMax32664LeakResult: Bool {return _storage._max32664LeakResult != nil}
  /// Clears the value of `max32664LeakResult`. Subsequent reads from it will return its default value.
  mutating func clearMax32664LeakResult() {_uniqueStorage()._max32664LeakResult = nil}

  var hrLeakResult: UInt32 {
    get {return _storage._hrLeakResult ?? 0}
    set {_uniqueStorage()._hrLeakResult = newValue}
  }
  /// Returns true if `hrLeakResult` has been explicitly set.
  var hasHrLeakResult: Bool {return _storage._hrLeakResult != nil}
  /// Clears the value of `hrLeakResult`. Subsequent reads from it will return its default value.
  mutating func clearHrLeakResult() {_uniqueStorage()._hrLeakResult = nil}

  var greyCardResult: UInt32 {
    get {return _storage._greyCardResult ?? 0}
    set {_uniqueStorage()._greyCardResult = newValue}
  }
  /// Returns true if `greyCardResult` has been explicitly set.
  var hasGreyCardResult: Bool {return _storage._greyCardResult != nil}
  /// Clears the value of `greyCardResult`. Subsequent reads from it will return its default value.
  mutating func clearGreyCardResult() {_uniqueStorage()._greyCardResult = nil}

  var gsensorResult: UInt32 {
    get {return _storage._gsensorResult ?? 0}
    set {_uniqueStorage()._gsensorResult = newValue}
  }
  /// Returns true if `gsensorResult` has been explicitly set.
  var hasGsensorResult: Bool {return _storage._gsensorResult != nil}
  /// Clears the value of `gsensorResult`. Subsequent reads from it will return its default value.
  mutating func clearGsensorResult() {_uniqueStorage()._gsensorResult = nil}

  var offbodyResult: UInt32 {
    get {return _storage._offbodyResult ?? 0}
    set {_uniqueStorage()._offbodyResult = newValue}
  }
  /// Returns true if `offbodyResult` has been explicitly set.
  var hasOffbodyResult: Bool {return _storage._offbodyResult != nil}
  /// Clears the value of `offbodyResult`. Subsequent reads from it will return its default value.
  mutating func clearOffbodyResult() {_uniqueStorage()._offbodyResult = nil}

  var keyResult: UInt32 {
    get {return _storage._keyResult ?? 0}
    set {_uniqueStorage()._keyResult = newValue}
  }
  /// Returns true if `keyResult` has been explicitly set.
  var hasKeyResult: Bool {return _storage._keyResult != nil}
  /// Clears the value of `keyResult`. Subsequent reads from it will return its default value.
  mutating func clearKeyResult() {_uniqueStorage()._keyResult = nil}

  var spl17Result: UInt32 {
    get {return _storage._spl17Result ?? 0}
    set {_uniqueStorage()._spl17Result = newValue}
  }
  /// Returns true if `spl17Result` has been explicitly set.
  var hasSpl17Result: Bool {return _storage._spl17Result != nil}
  /// Clears the value of `spl17Result`. Subsequent reads from it will return its default value.
  mutating func clearSpl17Result() {_uniqueStorage()._spl17Result = nil}

  var looptestResult: UInt32 {
    get {return _storage._looptestResult ?? 0}
    set {_uniqueStorage()._looptestResult = newValue}
  }
  /// Returns true if `looptestResult` has been explicitly set.
  var hasLooptestResult: Bool {return _storage._looptestResult != nil}
  /// Clears the value of `looptestResult`. Subsequent reads from it will return its default value.
  mutating func clearLooptestResult() {_uniqueStorage()._looptestResult = nil}

  var gsmResult: UInt32 {
    get {return _storage._gsmResult ?? 0}
    set {_uniqueStorage()._gsmResult = newValue}
  }
  /// Returns true if `gsmResult` has been explicitly set.
  var hasGsmResult: Bool {return _storage._gsmResult != nil}
  /// Clears the value of `gsmResult`. Subsequent reads from it will return its default value.
  mutating func clearGsmResult() {_uniqueStorage()._gsmResult = nil}

  var wifiResult: UInt32 {
    get {return _storage._wifiResult ?? 0}
    set {_uniqueStorage()._wifiResult = newValue}
  }
  /// Returns true if `wifiResult` has been explicitly set.
  var hasWifiResult: Bool {return _storage._wifiResult != nil}
  /// Clears the value of `wifiResult`. Subsequent reads from it will return its default value.
  mutating func clearWifiResult() {_uniqueStorage()._wifiResult = nil}

  var pressureSensorResult: UInt32 {
    get {return _storage._pressureSensorResult ?? 0}
    set {_uniqueStorage()._pressureSensorResult = newValue}
  }
  /// Returns true if `pressureSensorResult` has been explicitly set.
  var hasPressureSensorResult: Bool {return _storage._pressureSensorResult != nil}
  /// Clears the value of `pressureSensorResult`. Subsequent reads from it will return its default value.
  mutating func clearPressureSensorResult() {_uniqueStorage()._pressureSensorResult = nil}

  var knobResult: UInt32 {
    get {return _storage._knobResult ?? 0}
    set {_uniqueStorage()._knobResult = newValue}
  }
  /// Returns true if `knobResult` has been explicitly set.
  var hasKnobResult: Bool {return _storage._knobResult != nil}
  /// Clears the value of `knobResult`. Subsequent reads from it will return its default value.
  mutating func clearKnobResult() {_uniqueStorage()._knobResult = nil}

  var oximeterResult: UInt32 {
    get {return _storage._oximeterResult ?? 0}
    set {_uniqueStorage()._oximeterResult = newValue}
  }
  /// Returns true if `oximeterResult` has been explicitly set.
  var hasOximeterResult: Bool {return _storage._oximeterResult != nil}
  /// Clears the value of `oximeterResult`. Subsequent reads from it will return its default value.
  mutating func clearOximeterResult() {_uniqueStorage()._oximeterResult = nil}

  var proxCaliResult: UInt32 {
    get {return _storage._proxCaliResult ?? 0}
    set {_uniqueStorage()._proxCaliResult = newValue}
  }
  /// Returns true if `proxCaliResult` has been explicitly set.
  var hasProxCaliResult: Bool {return _storage._proxCaliResult != nil}
  /// Clears the value of `proxCaliResult`. Subsequent reads from it will return its default value.
  mutating func clearProxCaliResult() {_uniqueStorage()._proxCaliResult = nil}

  var proxResult: UInt32 {
    get {return _storage._proxResult ?? 0}
    set {_uniqueStorage()._proxResult = newValue}
  }
  /// Returns true if `proxResult` has been explicitly set.
  var hasProxResult: Bool {return _storage._proxResult != nil}
  /// Clears the value of `proxResult`. Subsequent reads from it will return its default value.
  mutating func clearProxResult() {_uniqueStorage()._proxResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct prox_cali {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fdsReadResult: [UInt32] = []

  ///0:NG  1:OK
  var proxCaliResult: Bool {
    get {return _proxCaliResult ?? false}
    set {_proxCaliResult = newValue}
  }
  /// Returns true if `proxCaliResult` has been explicitly set.
  var hasProxCaliResult: Bool {return self._proxCaliResult != nil}
  /// Clears the value of `proxCaliResult`. Subsequent reads from it will return its default value.
  mutating func clearProxCaliResult() {self._proxCaliResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _proxCaliResult: Bool? = nil
}

struct Test_prox {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var diff0Data: UInt32 {
    get {return _diff0Data ?? 0}
    set {_diff0Data = newValue}
  }
  /// Returns true if `diff0Data` has been explicitly set.
  var hasDiff0Data: Bool {return self._diff0Data != nil}
  /// Clears the value of `diff0Data`. Subsequent reads from it will return its default value.
  mutating func clearDiff0Data() {self._diff0Data = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _diff0Data: UInt32? = nil
}

struct Test_temprature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bodySurface: UInt32 {
    get {return _bodySurface ?? 0}
    set {_bodySurface = newValue}
  }
  /// Returns true if `bodySurface` has been explicitly set.
  var hasBodySurface: Bool {return self._bodySurface != nil}
  /// Clears the value of `bodySurface`. Subsequent reads from it will return its default value.
  mutating func clearBodySurface() {self._bodySurface = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bodySurface: UInt32? = nil
}

struct Test_key {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var keyResult: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Test_diff0_data {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var diff0Data: UInt32 {
    get {return _diff0Data ?? 0}
    set {_diff0Data = newValue}
  }
  /// Returns true if `diff0Data` has been explicitly set.
  var hasDiff0Data: Bool {return self._diff0Data != nil}
  /// Clears the value of `diff0Data`. Subsequent reads from it will return its default value.
  mutating func clearDiff0Data() {self._diff0Data = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _diff0Data: UInt32? = nil
}

struct Test_HR {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hrValue: UInt32 {
    get {return _hrValue ?? 0}
    set {_hrValue = newValue}
  }
  /// Returns true if `hrValue` has been explicitly set.
  var hasHrValue: Bool {return self._hrValue != nil}
  /// Clears the value of `hrValue`. Subsequent reads from it will return its default value.
  mutating func clearHrValue() {self._hrValue = nil}

  ///no wear：0XFF
  var hrState: Int32 {
    get {return _hrState ?? 0}
    set {_hrState = newValue}
  }
  /// Returns true if `hrState` has been explicitly set.
  var hasHrState: Bool {return self._hrState != nil}
  /// Clears the value of `hrState`. Subsequent reads from it will return its default value.
  mutating func clearHrState() {self._hrState = nil}

  var gsensorValue: Int32 {
    get {return _gsensorValue ?? 0}
    set {_gsensorValue = newValue}
  }
  /// Returns true if `gsensorValue` has been explicitly set.
  var hasGsensorValue: Bool {return self._gsensorValue != nil}
  /// Clears the value of `gsensorValue`. Subsequent reads from it will return its default value.
  mutating func clearGsensorValue() {self._gsensorValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hrValue: UInt32? = nil
  fileprivate var _hrState: Int32? = nil
  fileprivate var _gsensorValue: Int32? = nil
}

struct Test_ECG {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ecgWearData: UInt32 {
    get {return _ecgWearData ?? 0}
    set {_ecgWearData = newValue}
  }
  /// Returns true if `ecgWearData` has been explicitly set.
  var hasEcgWearData: Bool {return self._ecgWearData != nil}
  /// Clears the value of `ecgWearData`. Subsequent reads from it will return its default value.
  mutating func clearEcgWearData() {self._ecgWearData = nil}

  ///0:NG  1:OK
  var touchResult: Bool {
    get {return _touchResult ?? false}
    set {_touchResult = newValue}
  }
  /// Returns true if `touchResult` has been explicitly set.
  var hasTouchResult: Bool {return self._touchResult != nil}
  /// Clears the value of `touchResult`. Subsequent reads from it will return its default value.
  mutating func clearTouchResult() {self._touchResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ecgWearData: UInt32? = nil
  fileprivate var _touchResult: Bool? = nil
}

struct Test_konb {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var imgQa: UInt32 {
    get {return _imgQa ?? 0}
    set {_imgQa = newValue}
  }
  /// Returns true if `imgQa` has been explicitly set.
  var hasImgQa: Bool {return self._imgQa != nil}
  /// Clears the value of `imgQa`. Subsequent reads from it will return its default value.
  mutating func clearImgQa() {self._imgQa = nil}

  var pdSat: UInt32 {
    get {return _pdSat ?? 0}
    set {_pdSat = newValue}
  }
  /// Returns true if `pdSat` has been explicitly set.
  var hasPdSat: Bool {return self._pdSat != nil}
  /// Clears the value of `pdSat`. Subsequent reads from it will return its default value.
  mutating func clearPdSat() {self._pdSat = nil}

  ///0:NG  1:OK
  var imgQaResult: Bool {
    get {return _imgQaResult ?? false}
    set {_imgQaResult = newValue}
  }
  /// Returns true if `imgQaResult` has been explicitly set.
  var hasImgQaResult: Bool {return self._imgQaResult != nil}
  /// Clears the value of `imgQaResult`. Subsequent reads from it will return its default value.
  mutating func clearImgQaResult() {self._imgQaResult = nil}

  ///0:NG  1:OK
  var pdSatResult: Bool {
    get {return _pdSatResult ?? false}
    set {_pdSatResult = newValue}
  }
  /// Returns true if `pdSatResult` has been explicitly set.
  var hasPdSatResult: Bool {return self._pdSatResult != nil}
  /// Clears the value of `pdSatResult`. Subsequent reads from it will return its default value.
  mutating func clearPdSatResult() {self._pdSatResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _imgQa: UInt32? = nil
  fileprivate var _pdSat: UInt32? = nil
  fileprivate var _imgQaResult: Bool? = nil
  fileprivate var _pdSatResult: Bool? = nil
}

struct Test_Air_pressure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var airPressureValue: UInt32 {
    get {return _airPressureValue ?? 0}
    set {_airPressureValue = newValue}
  }
  /// Returns true if `airPressureValue` has been explicitly set.
  var hasAirPressureValue: Bool {return self._airPressureValue != nil}
  /// Clears the value of `airPressureValue`. Subsequent reads from it will return its default value.
  mutating func clearAirPressureValue() {self._airPressureValue = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _airPressureValue: UInt32? = nil
}

struct Test_gps {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var locationState: UInt32 {
    get {return _locationState ?? 0}
    set {_locationState = newValue}
  }
  /// Returns true if `locationState` has been explicitly set.
  var hasLocationState: Bool {return self._locationState != nil}
  /// Clears the value of `locationState`. Subsequent reads from it will return its default value.
  mutating func clearLocationState() {self._locationState = nil}

  var validSatellite: UInt32 {
    get {return _validSatellite ?? 0}
    set {_validSatellite = newValue}
  }
  /// Returns true if `validSatellite` has been explicitly set.
  var hasValidSatellite: Bool {return self._validSatellite != nil}
  /// Clears the value of `validSatellite`. Subsequent reads from it will return its default value.
  mutating func clearValidSatellite() {self._validSatellite = nil}

  var visibleSatellite: UInt32 {
    get {return _visibleSatellite ?? 0}
    set {_visibleSatellite = newValue}
  }
  /// Returns true if `visibleSatellite` has been explicitly set.
  var hasVisibleSatellite: Bool {return self._visibleSatellite != nil}
  /// Clears the value of `visibleSatellite`. Subsequent reads from it will return its default value.
  mutating func clearVisibleSatellite() {self._visibleSatellite = nil}

  var satelliteSignal: [UInt32] = []

  var avg: UInt32 {
    get {return _avg ?? 0}
    set {_avg = newValue}
  }
  /// Returns true if `avg` has been explicitly set.
  var hasAvg: Bool {return self._avg != nil}
  /// Clears the value of `avg`. Subsequent reads from it will return its default value.
  mutating func clearAvg() {self._avg = nil}

  var gpsLocationTime: UInt32 {
    get {return _gpsLocationTime ?? 0}
    set {_gpsLocationTime = newValue}
  }
  /// Returns true if `gpsLocationTime` has been explicitly set.
  var hasGpsLocationTime: Bool {return self._gpsLocationTime != nil}
  /// Clears the value of `gpsLocationTime`. Subsequent reads from it will return its default value.
  mutating func clearGpsLocationTime() {self._gpsLocationTime = nil}

  var epoValid: Bool {
    get {return _epoValid ?? false}
    set {_epoValid = newValue}
  }
  /// Returns true if `epoValid` has been explicitly set.
  var hasEpoValid: Bool {return self._epoValid != nil}
  /// Clears the value of `epoValid`. Subsequent reads from it will return its default value.
  mutating func clearEpoValid() {self._epoValid = nil}

  var epoWeeknum: String {
    get {return _epoWeeknum ?? String()}
    set {_epoWeeknum = newValue}
  }
  /// Returns true if `epoWeeknum` has been explicitly set.
  var hasEpoWeeknum: Bool {return self._epoWeeknum != nil}
  /// Clears the value of `epoWeeknum`. Subsequent reads from it will return its default value.
  mutating func clearEpoWeeknum() {self._epoWeeknum = nil}

  var fwVersion: String {
    get {return _fwVersion ?? String()}
    set {_fwVersion = newValue}
  }
  /// Returns true if `fwVersion` has been explicitly set.
  var hasFwVersion: Bool {return self._fwVersion != nil}
  /// Clears the value of `fwVersion`. Subsequent reads from it will return its default value.
  mutating func clearFwVersion() {self._fwVersion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _locationState: UInt32? = nil
  fileprivate var _validSatellite: UInt32? = nil
  fileprivate var _visibleSatellite: UInt32? = nil
  fileprivate var _avg: UInt32? = nil
  fileprivate var _gpsLocationTime: UInt32? = nil
  fileprivate var _epoValid: Bool? = nil
  fileprivate var _epoWeeknum: String? = nil
  fileprivate var _fwVersion: String? = nil
}

struct Test_gsm_wifi {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///0: NG   1: OK
  var wifiResult: Bool {
    get {return _wifiResult ?? false}
    set {_wifiResult = newValue}
  }
  /// Returns true if `wifiResult` has been explicitly set.
  var hasWifiResult: Bool {return self._wifiResult != nil}
  /// Clears the value of `wifiResult`. Subsequent reads from it will return its default value.
  mutating func clearWifiResult() {self._wifiResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _wifiResult: Bool? = nil
}

struct Test_max32664 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var version: UInt32 {
    get {return _version ?? 0}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var max32664Leak1: UInt32 {
    get {return _max32664Leak1 ?? 0}
    set {_max32664Leak1 = newValue}
  }
  /// Returns true if `max32664Leak1` has been explicitly set.
  var hasMax32664Leak1: Bool {return self._max32664Leak1 != nil}
  /// Clears the value of `max32664Leak1`. Subsequent reads from it will return its default value.
  mutating func clearMax32664Leak1() {self._max32664Leak1 = nil}

  var max32664Leak2: UInt32 {
    get {return _max32664Leak2 ?? 0}
    set {_max32664Leak2 = newValue}
  }
  /// Returns true if `max32664Leak2` has been explicitly set.
  var hasMax32664Leak2: Bool {return self._max32664Leak2 != nil}
  /// Clears the value of `max32664Leak2`. Subsequent reads from it will return its default value.
  mutating func clearMax32664Leak2() {self._max32664Leak2 = nil}

  ///0:NG   1:OK
  var leakResult: Bool {
    get {return _leakResult ?? false}
    set {_leakResult = newValue}
  }
  /// Returns true if `leakResult` has been explicitly set.
  var hasLeakResult: Bool {return self._leakResult != nil}
  /// Clears the value of `leakResult`. Subsequent reads from it will return its default value.
  mutating func clearLeakResult() {self._leakResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _version: UInt32? = nil
  fileprivate var _max32664Leak1: UInt32? = nil
  fileprivate var _max32664Leak2: UInt32? = nil
  fileprivate var _leakResult: Bool? = nil
}

struct Test_hr_leak {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ledValid: [UInt32] = []

  ///0:NG  1:OK
  var hrLeakResult: Bool {
    get {return _hrLeakResult ?? false}
    set {_hrLeakResult = newValue}
  }
  /// Returns true if `hrLeakResult` has been explicitly set.
  var hasHrLeakResult: Bool {return self._hrLeakResult != nil}
  /// Clears the value of `hrLeakResult`. Subsequent reads from it will return its default value.
  mutating func clearHrLeakResult() {self._hrLeakResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hrLeakResult: Bool? = nil
}

struct Test_pah8009_leak {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var adc: [UInt32] = []

  var chResult: [UInt32] = []

  var pah8009LeakResult: Bool {
    get {return _pah8009LeakResult ?? false}
    set {_pah8009LeakResult = newValue}
  }
  /// Returns true if `pah8009LeakResult` has been explicitly set.
  var hasPah8009LeakResult: Bool {return self._pah8009LeakResult != nil}
  /// Clears the value of `pah8009LeakResult`. Subsequent reads from it will return its default value.
  mutating func clearPah8009LeakResult() {self._pah8009LeakResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pah8009LeakResult: Bool? = nil
}

struct Test_gh3xxx_hr_leak {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gh3XxOsTestRet: [UInt32] = []

  ///0:NG   1:OK
  var hrLeakResult: Bool {
    get {return _hrLeakResult ?? false}
    set {_hrLeakResult = newValue}
  }
  /// Returns true if `hrLeakResult` has been explicitly set.
  var hasHrLeakResult: Bool {return self._hrLeakResult != nil}
  /// Clears the value of `hrLeakResult`. Subsequent reads from it will return its default value.
  mutating func clearHrLeakResult() {self._hrLeakResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hrLeakResult: Bool? = nil
}

struct Test_pah831x_leak {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///0:NG   1:OK
  var hrLeakResult: Bool {
    get {return _hrLeakResult ?? false}
    set {_hrLeakResult = newValue}
  }
  /// Returns true if `hrLeakResult` has been explicitly set.
  var hasHrLeakResult: Bool {return self._hrLeakResult != nil}
  /// Clears the value of `hrLeakResult`. Subsequent reads from it will return its default value.
  mutating func clearHrLeakResult() {self._hrLeakResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hrLeakResult: Bool? = nil
}

struct Test_hrs3600_leak {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hrmRawData: UInt32 {
    get {return _hrmRawData ?? 0}
    set {_hrmRawData = newValue}
  }
  /// Returns true if `hrmRawData` has been explicitly set.
  var hasHrmRawData: Bool {return self._hrmRawData != nil}
  /// Clears the value of `hrmRawData`. Subsequent reads from it will return its default value.
  mutating func clearHrmRawData() {self._hrmRawData = nil}

  var infraredData: UInt32 {
    get {return _infraredData ?? 0}
    set {_infraredData = newValue}
  }
  /// Returns true if `infraredData` has been explicitly set.
  var hasInfraredData: Bool {return self._infraredData != nil}
  /// Clears the value of `infraredData`. Subsequent reads from it will return its default value.
  mutating func clearInfraredData() {self._infraredData = nil}

  ///0:NG  1:OK
  var hrs3600LeakResult: Bool {
    get {return _hrs3600LeakResult ?? false}
    set {_hrs3600LeakResult = newValue}
  }
  /// Returns true if `hrs3600LeakResult` has been explicitly set.
  var hasHrs3600LeakResult: Bool {return self._hrs3600LeakResult != nil}
  /// Clears the value of `hrs3600LeakResult`. Subsequent reads from it will return its default value.
  mutating func clearHrs3600LeakResult() {self._hrs3600LeakResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hrmRawData: UInt32? = nil
  fileprivate var _infraredData: UInt32? = nil
  fileprivate var _hrs3600LeakResult: Bool? = nil
}

struct Test_hx3918_leak {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var leakG: UInt32 {
    get {return _leakG ?? 0}
    set {_leakG = newValue}
  }
  /// Returns true if `leakG` has been explicitly set.
  var hasLeakG: Bool {return self._leakG != nil}
  /// Clears the value of `leakG`. Subsequent reads from it will return its default value.
  mutating func clearLeakG() {self._leakG = nil}

  var leakR: UInt32 {
    get {return _leakR ?? 0}
    set {_leakR = newValue}
  }
  /// Returns true if `leakR` has been explicitly set.
  var hasLeakR: Bool {return self._leakR != nil}
  /// Clears the value of `leakR`. Subsequent reads from it will return its default value.
  mutating func clearLeakR() {self._leakR = nil}

  var leakIr: UInt32 {
    get {return _leakIr ?? 0}
    set {_leakIr = newValue}
  }
  /// Returns true if `leakIr` has been explicitly set.
  var hasLeakIr: Bool {return self._leakIr != nil}
  /// Clears the value of `leakIr`. Subsequent reads from it will return its default value.
  mutating func clearLeakIr() {self._leakIr = nil}

  ///0:NG  1:OK
  var hrLeakResult: Bool {
    get {return _hrLeakResult ?? false}
    set {_hrLeakResult = newValue}
  }
  /// Returns true if `hrLeakResult` has been explicitly set.
  var hasHrLeakResult: Bool {return self._hrLeakResult != nil}
  /// Clears the value of `hrLeakResult`. Subsequent reads from it will return its default value.
  mutating func clearHrLeakResult() {self._hrLeakResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _leakG: UInt32? = nil
  fileprivate var _leakR: UInt32? = nil
  fileprivate var _leakIr: UInt32? = nil
  fileprivate var _hrLeakResult: Bool? = nil
}

struct Test_oximeter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var oximeterResult: Bool {
    get {return _oximeterResult ?? false}
    set {_oximeterResult = newValue}
  }
  /// Returns true if `oximeterResult` has been explicitly set.
  var hasOximeterResult: Bool {return self._oximeterResult != nil}
  /// Clears the value of `oximeterResult`. Subsequent reads from it will return its default value.
  mutating func clearOximeterResult() {self._oximeterResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _oximeterResult: Bool? = nil
}

struct Test_hrv {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hrvVoltage: UInt32 {
    get {return _hrvVoltage ?? 0}
    set {_hrvVoltage = newValue}
  }
  /// Returns true if `hrvVoltage` has been explicitly set.
  var hasHrvVoltage: Bool {return self._hrvVoltage != nil}
  /// Clears the value of `hrvVoltage`. Subsequent reads from it will return its default value.
  mutating func clearHrvVoltage() {self._hrvVoltage = nil}

  ///0:NG   1:OK
  var hrvResult: Bool {
    get {return _hrvResult ?? false}
    set {_hrvResult = newValue}
  }
  /// Returns true if `hrvResult` has been explicitly set.
  var hasHrvResult: Bool {return self._hrvResult != nil}
  /// Clears the value of `hrvResult`. Subsequent reads from it will return its default value.
  mutating func clearHrvResult() {self._hrvResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hrvVoltage: UInt32? = nil
  fileprivate var _hrvResult: Bool? = nil
}

struct Test_bioz {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var biozData: UInt32 {
    get {return _biozData ?? 0}
    set {_biozData = newValue}
  }
  /// Returns true if `biozData` has been explicitly set.
  var hasBiozData: Bool {return self._biozData != nil}
  /// Clears the value of `biozData`. Subsequent reads from it will return its default value.
  mutating func clearBiozData() {self._biozData = nil}

  ///0:NG   1:OK
  var biozResult: Bool {
    get {return _biozResult ?? false}
    set {_biozResult = newValue}
  }
  /// Returns true if `biozResult` has been explicitly set.
  var hasBiozResult: Bool {return self._biozResult != nil}
  /// Clears the value of `biozResult`. Subsequent reads from it will return its default value.
  mutating func clearBiozResult() {self._biozResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _biozData: UInt32? = nil
  fileprivate var _biozResult: Bool? = nil
}

struct Test_bp_upressure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var upressureValid: UInt32 {
    get {return _upressureValid ?? 0}
    set {_upressureValid = newValue}
  }
  /// Returns true if `upressureValid` has been explicitly set.
  var hasUpressureValid: Bool {return self._upressureValid != nil}
  /// Clears the value of `upressureValid`. Subsequent reads from it will return its default value.
  mutating func clearUpressureValid() {self._upressureValid = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _upressureValid: UInt32? = nil
}

struct cell_info {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var state: String {
    get {return _state ?? String()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {self._state = nil}

  var freqBandInd: UInt32 {
    get {return _freqBandInd ?? 0}
    set {_freqBandInd = newValue}
  }
  /// Returns true if `freqBandInd` has been explicitly set.
  var hasFreqBandInd: Bool {return self._freqBandInd != nil}
  /// Clears the value of `freqBandInd`. Subsequent reads from it will return its default value.
  mutating func clearFreqBandInd() {self._freqBandInd = nil}

  var ulBandwidth: UInt32 {
    get {return _ulBandwidth ?? 0}
    set {_ulBandwidth = newValue}
  }
  /// Returns true if `ulBandwidth` has been explicitly set.
  var hasUlBandwidth: Bool {return self._ulBandwidth != nil}
  /// Clears the value of `ulBandwidth`. Subsequent reads from it will return its default value.
  mutating func clearUlBandwidth() {self._ulBandwidth = nil}

  var dlBandwidth: UInt32 {
    get {return _dlBandwidth ?? 0}
    set {_dlBandwidth = newValue}
  }
  /// Returns true if `dlBandwidth` has been explicitly set.
  var hasDlBandwidth: Bool {return self._dlBandwidth != nil}
  /// Clears the value of `dlBandwidth`. Subsequent reads from it will return its default value.
  mutating func clearDlBandwidth() {self._dlBandwidth = nil}

  var mcc: String {
    get {return _mcc ?? String()}
    set {_mcc = newValue}
  }
  /// Returns true if `mcc` has been explicitly set.
  var hasMcc: Bool {return self._mcc != nil}
  /// Clears the value of `mcc`. Subsequent reads from it will return its default value.
  mutating func clearMcc() {self._mcc = nil}

  var mnc: String {
    get {return _mnc ?? String()}
    set {_mnc = newValue}
  }
  /// Returns true if `mnc` has been explicitly set.
  var hasMnc: Bool {return self._mnc != nil}
  /// Clears the value of `mnc`. Subsequent reads from it will return its default value.
  mutating func clearMnc() {self._mnc = nil}

  var csqRssi: UInt32 {
    get {return _csqRssi ?? 0}
    set {_csqRssi = newValue}
  }
  /// Returns true if `csqRssi` has been explicitly set.
  var hasCsqRssi: Bool {return self._csqRssi != nil}
  /// Clears the value of `csqRssi`. Subsequent reads from it will return its default value.
  mutating func clearCsqRssi() {self._csqRssi = nil}

  var signal: UInt32 {
    get {return _signal ?? 0}
    set {_signal = newValue}
  }
  /// Returns true if `signal` has been explicitly set.
  var hasSignal: Bool {return self._signal != nil}
  /// Clears the value of `signal`. Subsequent reads from it will return its default value.
  mutating func clearSignal() {self._signal = nil}

  var rsrq: UInt32 {
    get {return _rsrq ?? 0}
    set {_rsrq = newValue}
  }
  /// Returns true if `rsrq` has been explicitly set.
  var hasRsrq: Bool {return self._rsrq != nil}
  /// Clears the value of `rsrq`. Subsequent reads from it will return its default value.
  mutating func clearRsrq() {self._rsrq = nil}

  var rssi: UInt32 {
    get {return _rssi ?? 0}
    set {_rssi = newValue}
  }
  /// Returns true if `rssi` has been explicitly set.
  var hasRssi: Bool {return self._rssi != nil}
  /// Clears the value of `rssi`. Subsequent reads from it will return its default value.
  mutating func clearRssi() {self._rssi = nil}

  var sinr: UInt32 {
    get {return _sinr ?? 0}
    set {_sinr = newValue}
  }
  /// Returns true if `sinr` has been explicitly set.
  var hasSinr: Bool {return self._sinr != nil}
  /// Clears the value of `sinr`. Subsequent reads from it will return its default value.
  mutating func clearSinr() {self._sinr = nil}

  var acT: String {
    get {return _acT ?? String()}
    set {_acT = newValue}
  }
  /// Returns true if `acT` has been explicitly set.
  var hasAcT: Bool {return self._acT != nil}
  /// Clears the value of `acT`. Subsequent reads from it will return its default value.
  mutating func clearAcT() {self._acT = nil}

  var band: String {
    get {return _band ?? String()}
    set {_band = newValue}
  }
  /// Returns true if `band` has been explicitly set.
  var hasBand: Bool {return self._band != nil}
  /// Clears the value of `band`. Subsequent reads from it will return its default value.
  mutating func clearBand() {self._band = nil}

  var creg: UInt32 {
    get {return _creg ?? 0}
    set {_creg = newValue}
  }
  /// Returns true if `creg` has been explicitly set.
  var hasCreg: Bool {return self._creg != nil}
  /// Clears the value of `creg`. Subsequent reads from it will return its default value.
  mutating func clearCreg() {self._creg = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _state: String? = nil
  fileprivate var _freqBandInd: UInt32? = nil
  fileprivate var _ulBandwidth: UInt32? = nil
  fileprivate var _dlBandwidth: UInt32? = nil
  fileprivate var _mcc: String? = nil
  fileprivate var _mnc: String? = nil
  fileprivate var _csqRssi: UInt32? = nil
  fileprivate var _signal: UInt32? = nil
  fileprivate var _rsrq: UInt32? = nil
  fileprivate var _rssi: UInt32? = nil
  fileprivate var _sinr: UInt32? = nil
  fileprivate var _acT: String? = nil
  fileprivate var _band: String? = nil
  fileprivate var _creg: UInt32? = nil
}

struct Test_gsm_info {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var simReady: UInt32 {
    get {return _simReady ?? 0}
    set {_simReady = newValue}
  }
  /// Returns true if `simReady` has been explicitly set.
  var hasSimReady: Bool {return self._simReady != nil}
  /// Clears the value of `simReady`. Subsequent reads from it will return its default value.
  mutating func clearSimReady() {self._simReady = nil}

  var gsmCellInfo: cell_info {
    get {return _gsmCellInfo ?? cell_info()}
    set {_gsmCellInfo = newValue}
  }
  /// Returns true if `gsmCellInfo` has been explicitly set.
  var hasGsmCellInfo: Bool {return self._gsmCellInfo != nil}
  /// Clears the value of `gsmCellInfo`. Subsequent reads from it will return its default value.
  mutating func clearGsmCellInfo() {self._gsmCellInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _simReady: UInt32? = nil
  fileprivate var _gsmCellInfo: cell_info? = nil
}

struct Test_gsm_loop {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var testRecording: Bool {
    get {return _testRecording ?? false}
    set {_testRecording = newValue}
  }
  /// Returns true if `testRecording` has been explicitly set.
  var hasTestRecording: Bool {return self._testRecording != nil}
  /// Clears the value of `testRecording`. Subsequent reads from it will return its default value.
  mutating func clearTestRecording() {self._testRecording = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _testRecording: Bool? = nil
}

struct Test_gsm_call {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var callReady: UInt32 {
    get {return _callReady ?? 0}
    set {_callReady = newValue}
  }
  /// Returns true if `callReady` has been explicitly set.
  var hasCallReady: Bool {return self._callReady != nil}
  /// Clears the value of `callReady`. Subsequent reads from it will return its default value.
  mutating func clearCallReady() {self._callReady = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _callReady: UInt32? = nil
}

struct FactoryTestNotify {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mode: FactoryTestMode {
    get {return _mode ?? .dischargeMode}
    set {_mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  var hasMode: Bool {return self._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  mutating func clearMode() {self._mode = nil}

  var operation: TestOperation {
    get {return _operation ?? .testStart}
    set {_operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  var hasOperation: Bool {return self._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  mutating func clearOperation() {self._operation = nil}

  var sensorResult: SensorTestResult {
    get {return _sensorResult ?? SensorTestResult()}
    set {_sensorResult = newValue}
  }
  /// Returns true if `sensorResult` has been explicitly set.
  var hasSensorResult: Bool {return self._sensorResult != nil}
  /// Clears the value of `sensorResult`. Subsequent reads from it will return its default value.
  mutating func clearSensorResult() {self._sensorResult = nil}

  var pressureHour: UInt32 {
    get {return _pressureHour ?? 0}
    set {_pressureHour = newValue}
  }
  /// Returns true if `pressureHour` has been explicitly set.
  var hasPressureHour: Bool {return self._pressureHour != nil}
  /// Clears the value of `pressureHour`. Subsequent reads from it will return its default value.
  mutating func clearPressureHour() {self._pressureHour = nil}

  var placementHour: UInt32 {
    get {return _placementHour ?? 0}
    set {_placementHour = newValue}
  }
  /// Returns true if `placementHour` has been explicitly set.
  var hasPlacementHour: Bool {return self._placementHour != nil}
  /// Clears the value of `placementHour`. Subsequent reads from it will return its default value.
  mutating func clearPlacementHour() {self._placementHour = nil}

  var operationPage: FACTORY_PAGE_TEST {
    get {return _operationPage ?? .motor}
    set {_operationPage = newValue}
  }
  /// Returns true if `operationPage` has been explicitly set.
  var hasOperationPage: Bool {return self._operationPage != nil}
  /// Clears the value of `operationPage`. Subsequent reads from it will return its default value.
  mutating func clearOperationPage() {self._operationPage = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mode: FactoryTestMode? = nil
  fileprivate var _operation: TestOperation? = nil
  fileprivate var _sensorResult: SensorTestResult? = nil
  fileprivate var _pressureHour: UInt32? = nil
  fileprivate var _placementHour: UInt32? = nil
  fileprivate var _operationPage: FACTORY_PAGE_TEST? = nil
}

struct FactoryTestConfim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mode: FactoryTestMode {
    get {return _storage._mode ?? .dischargeMode}
    set {_uniqueStorage()._mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  var hasMode: Bool {return _storage._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  mutating func clearMode() {_uniqueStorage()._mode = nil}

  var ret: Bool {
    get {return _storage._ret ?? false}
    set {_uniqueStorage()._ret = newValue}
  }
  /// Returns true if `ret` has been explicitly set.
  var hasRet: Bool {return _storage._ret != nil}
  /// Clears the value of `ret`. Subsequent reads from it will return its default value.
  mutating func clearRet() {_uniqueStorage()._ret = nil}

  var operation: TestOperation {
    get {return _storage._operation ?? .testStart}
    set {_uniqueStorage()._operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  var hasOperation: Bool {return _storage._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  mutating func clearOperation() {_uniqueStorage()._operation = nil}

  var params: OneOf_Params? {
    get {return _storage._params}
    set {_uniqueStorage()._params = newValue}
  }

  var dischargeResult: DischargeTestResult {
    get {
      if case .dischargeResult(let v)? = _storage._params {return v}
      return DischargeTestResult()
    }
    set {_uniqueStorage()._params = .dischargeResult(newValue)}
  }

  var chargeResult: ChargeTestResult {
    get {
      if case .chargeResult(let v)? = _storage._params {return v}
      return ChargeTestResult()
    }
    set {_uniqueStorage()._params = .chargeResult(newValue)}
  }

  var pressureResult: PressureTestResult {
    get {
      if case .pressureResult(let v)? = _storage._params {return v}
      return PressureTestResult()
    }
    set {_uniqueStorage()._params = .pressureResult(newValue)}
  }

  var placementResult: PlacementTestResult {
    get {
      if case .placementResult(let v)? = _storage._params {return v}
      return PlacementTestResult()
    }
    set {_uniqueStorage()._params = .placementResult(newValue)}
  }

  var autoResult: AutoTestResult {
    get {
      if case .autoResult(let v)? = _storage._params {return v}
      return AutoTestResult()
    }
    set {_uniqueStorage()._params = .autoResult(newValue)}
  }

  var sensorResult: SensorTestResult {
    get {
      if case .sensorResult(let v)? = _storage._params {return v}
      return SensorTestResult()
    }
    set {_uniqueStorage()._params = .sensorResult(newValue)}
  }

  var proxCaliResult: prox_cali {
    get {
      if case .proxCaliResult(let v)? = _storage._params {return v}
      return prox_cali()
    }
    set {_uniqueStorage()._params = .proxCaliResult(newValue)}
  }

  var proxResult: Test_prox {
    get {
      if case .proxResult(let v)? = _storage._params {return v}
      return Test_prox()
    }
    set {_uniqueStorage()._params = .proxResult(newValue)}
  }

  var tempratureResult: Test_temprature {
    get {
      if case .tempratureResult(let v)? = _storage._params {return v}
      return Test_temprature()
    }
    set {_uniqueStorage()._params = .tempratureResult(newValue)}
  }

  var keyResult: Test_key {
    get {
      if case .keyResult(let v)? = _storage._params {return v}
      return Test_key()
    }
    set {_uniqueStorage()._params = .keyResult(newValue)}
  }

  var diff0DataResult: Test_diff0_data {
    get {
      if case .diff0DataResult(let v)? = _storage._params {return v}
      return Test_diff0_data()
    }
    set {_uniqueStorage()._params = .diff0DataResult(newValue)}
  }

  var hrResult: Test_HR {
    get {
      if case .hrResult(let v)? = _storage._params {return v}
      return Test_HR()
    }
    set {_uniqueStorage()._params = .hrResult(newValue)}
  }

  var ecgResult: Test_ECG {
    get {
      if case .ecgResult(let v)? = _storage._params {return v}
      return Test_ECG()
    }
    set {_uniqueStorage()._params = .ecgResult(newValue)}
  }

  var konbResult: Test_konb {
    get {
      if case .konbResult(let v)? = _storage._params {return v}
      return Test_konb()
    }
    set {_uniqueStorage()._params = .konbResult(newValue)}
  }

  var airPressureResult: Test_Air_pressure {
    get {
      if case .airPressureResult(let v)? = _storage._params {return v}
      return Test_Air_pressure()
    }
    set {_uniqueStorage()._params = .airPressureResult(newValue)}
  }

  var gpsResult: Test_gps {
    get {
      if case .gpsResult(let v)? = _storage._params {return v}
      return Test_gps()
    }
    set {_uniqueStorage()._params = .gpsResult(newValue)}
  }

  var gsmWifiResult: Test_gsm_wifi {
    get {
      if case .gsmWifiResult(let v)? = _storage._params {return v}
      return Test_gsm_wifi()
    }
    set {_uniqueStorage()._params = .gsmWifiResult(newValue)}
  }

  var max32664Result: Test_max32664 {
    get {
      if case .max32664Result(let v)? = _storage._params {return v}
      return Test_max32664()
    }
    set {_uniqueStorage()._params = .max32664Result(newValue)}
  }

  var pah8009LeakResult: Test_pah8009_leak {
    get {
      if case .pah8009LeakResult(let v)? = _storage._params {return v}
      return Test_pah8009_leak()
    }
    set {_uniqueStorage()._params = .pah8009LeakResult(newValue)}
  }

  var gh3XxxHrLeakResult: Test_gh3xxx_hr_leak {
    get {
      if case .gh3XxxHrLeakResult(let v)? = _storage._params {return v}
      return Test_gh3xxx_hr_leak()
    }
    set {_uniqueStorage()._params = .gh3XxxHrLeakResult(newValue)}
  }

  var pah831XLeakResult: Test_pah831x_leak {
    get {
      if case .pah831XLeakResult(let v)? = _storage._params {return v}
      return Test_pah831x_leak()
    }
    set {_uniqueStorage()._params = .pah831XLeakResult(newValue)}
  }

  var hrs3600LeakResult: Test_hrs3600_leak {
    get {
      if case .hrs3600LeakResult(let v)? = _storage._params {return v}
      return Test_hrs3600_leak()
    }
    set {_uniqueStorage()._params = .hrs3600LeakResult(newValue)}
  }

  var hx3918LeakResult: Test_hx3918_leak {
    get {
      if case .hx3918LeakResult(let v)? = _storage._params {return v}
      return Test_hx3918_leak()
    }
    set {_uniqueStorage()._params = .hx3918LeakResult(newValue)}
  }

  var oximeterResult: Test_oximeter {
    get {
      if case .oximeterResult(let v)? = _storage._params {return v}
      return Test_oximeter()
    }
    set {_uniqueStorage()._params = .oximeterResult(newValue)}
  }

  var hrvResult: Test_hrv {
    get {
      if case .hrvResult(let v)? = _storage._params {return v}
      return Test_hrv()
    }
    set {_uniqueStorage()._params = .hrvResult(newValue)}
  }

  var biozResult: Test_bioz {
    get {
      if case .biozResult(let v)? = _storage._params {return v}
      return Test_bioz()
    }
    set {_uniqueStorage()._params = .biozResult(newValue)}
  }

  var bpUpressureResult: Test_bp_upressure {
    get {
      if case .bpUpressureResult(let v)? = _storage._params {return v}
      return Test_bp_upressure()
    }
    set {_uniqueStorage()._params = .bpUpressureResult(newValue)}
  }

  var gsmInfoResult: Test_gsm_info {
    get {
      if case .gsmInfoResult(let v)? = _storage._params {return v}
      return Test_gsm_info()
    }
    set {_uniqueStorage()._params = .gsmInfoResult(newValue)}
  }

  var gsmLoopResult: Test_gsm_loop {
    get {
      if case .gsmLoopResult(let v)? = _storage._params {return v}
      return Test_gsm_loop()
    }
    set {_uniqueStorage()._params = .gsmLoopResult(newValue)}
  }

  var gsmCallResult: Test_gsm_call {
    get {
      if case .gsmCallResult(let v)? = _storage._params {return v}
      return Test_gsm_call()
    }
    set {_uniqueStorage()._params = .gsmCallResult(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Params: Equatable {
    case dischargeResult(DischargeTestResult)
    case chargeResult(ChargeTestResult)
    case pressureResult(PressureTestResult)
    case placementResult(PlacementTestResult)
    case autoResult(AutoTestResult)
    case sensorResult(SensorTestResult)
    case proxCaliResult(prox_cali)
    case proxResult(Test_prox)
    case tempratureResult(Test_temprature)
    case keyResult(Test_key)
    case diff0DataResult(Test_diff0_data)
    case hrResult(Test_HR)
    case ecgResult(Test_ECG)
    case konbResult(Test_konb)
    case airPressureResult(Test_Air_pressure)
    case gpsResult(Test_gps)
    case gsmWifiResult(Test_gsm_wifi)
    case max32664Result(Test_max32664)
    case pah8009LeakResult(Test_pah8009_leak)
    case gh3XxxHrLeakResult(Test_gh3xxx_hr_leak)
    case pah831XLeakResult(Test_pah831x_leak)
    case hrs3600LeakResult(Test_hrs3600_leak)
    case hx3918LeakResult(Test_hx3918_leak)
    case oximeterResult(Test_oximeter)
    case hrvResult(Test_hrv)
    case biozResult(Test_bioz)
    case bpUpressureResult(Test_bp_upressure)
    case gsmInfoResult(Test_gsm_info)
    case gsmLoopResult(Test_gsm_loop)
    case gsmCallResult(Test_gsm_call)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .dischargeResult: return {
        guard case .dischargeResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .chargeResult: return {
        guard case .chargeResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .pressureResult: return {
        guard case .pressureResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .placementResult: return {
        guard case .placementResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .autoResult: return {
        guard case .autoResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .proxCaliResult: return {
        guard case .proxCaliResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .proxResult: return {
        guard case .proxResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .tempratureResult: return {
        guard case .tempratureResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .diff0DataResult: return {
        guard case .diff0DataResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .hrResult: return {
        guard case .hrResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .ecgResult: return {
        guard case .ecgResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .konbResult: return {
        guard case .konbResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .airPressureResult: return {
        guard case .airPressureResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .gpsResult: return {
        guard case .gpsResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .gsmWifiResult: return {
        guard case .gsmWifiResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .max32664Result: return {
        guard case .max32664Result(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .pah831XLeakResult: return {
        guard case .pah831XLeakResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .hrs3600LeakResult: return {
        guard case .hrs3600LeakResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .hx3918LeakResult: return {
        guard case .hx3918LeakResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .hrvResult: return {
        guard case .hrvResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .biozResult: return {
        guard case .biozResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .bpUpressureResult: return {
        guard case .bpUpressureResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .gsmInfoResult: return {
        guard case .gsmInfoResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .gsmLoopResult: return {
        guard case .gsmLoopResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .gsmCallResult: return {
        guard case .gsmCallResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      default: return true
      }
    }

  #if !swift(>=4.1)
    static func ==(lhs: FactoryTestConfim.OneOf_Params, rhs: FactoryTestConfim.OneOf_Params) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.dischargeResult, .dischargeResult): return {
        guard case .dischargeResult(let l) = lhs, case .dischargeResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chargeResult, .chargeResult): return {
        guard case .chargeResult(let l) = lhs, case .chargeResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pressureResult, .pressureResult): return {
        guard case .pressureResult(let l) = lhs, case .pressureResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.placementResult, .placementResult): return {
        guard case .placementResult(let l) = lhs, case .placementResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.autoResult, .autoResult): return {
        guard case .autoResult(let l) = lhs, case .autoResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sensorResult, .sensorResult): return {
        guard case .sensorResult(let l) = lhs, case .sensorResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.proxCaliResult, .proxCaliResult): return {
        guard case .proxCaliResult(let l) = lhs, case .proxCaliResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.proxResult, .proxResult): return {
        guard case .proxResult(let l) = lhs, case .proxResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.tempratureResult, .tempratureResult): return {
        guard case .tempratureResult(let l) = lhs, case .tempratureResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.keyResult, .keyResult): return {
        guard case .keyResult(let l) = lhs, case .keyResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.diff0DataResult, .diff0DataResult): return {
        guard case .diff0DataResult(let l) = lhs, case .diff0DataResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hrResult, .hrResult): return {
        guard case .hrResult(let l) = lhs, case .hrResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ecgResult, .ecgResult): return {
        guard case .ecgResult(let l) = lhs, case .ecgResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.konbResult, .konbResult): return {
        guard case .konbResult(let l) = lhs, case .konbResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.airPressureResult, .airPressureResult): return {
        guard case .airPressureResult(let l) = lhs, case .airPressureResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gpsResult, .gpsResult): return {
        guard case .gpsResult(let l) = lhs, case .gpsResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gsmWifiResult, .gsmWifiResult): return {
        guard case .gsmWifiResult(let l) = lhs, case .gsmWifiResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.max32664Result, .max32664Result): return {
        guard case .max32664Result(let l) = lhs, case .max32664Result(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pah8009LeakResult, .pah8009LeakResult): return {
        guard case .pah8009LeakResult(let l) = lhs, case .pah8009LeakResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gh3XxxHrLeakResult, .gh3XxxHrLeakResult): return {
        guard case .gh3XxxHrLeakResult(let l) = lhs, case .gh3XxxHrLeakResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pah831XLeakResult, .pah831XLeakResult): return {
        guard case .pah831XLeakResult(let l) = lhs, case .pah831XLeakResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hrs3600LeakResult, .hrs3600LeakResult): return {
        guard case .hrs3600LeakResult(let l) = lhs, case .hrs3600LeakResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hx3918LeakResult, .hx3918LeakResult): return {
        guard case .hx3918LeakResult(let l) = lhs, case .hx3918LeakResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.oximeterResult, .oximeterResult): return {
        guard case .oximeterResult(let l) = lhs, case .oximeterResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hrvResult, .hrvResult): return {
        guard case .hrvResult(let l) = lhs, case .hrvResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.biozResult, .biozResult): return {
        guard case .biozResult(let l) = lhs, case .biozResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.bpUpressureResult, .bpUpressureResult): return {
        guard case .bpUpressureResult(let l) = lhs, case .bpUpressureResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gsmInfoResult, .gsmInfoResult): return {
        guard case .gsmInfoResult(let l) = lhs, case .gsmInfoResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gsmLoopResult, .gsmLoopResult): return {
        guard case .gsmLoopResult(let l) = lhs, case .gsmLoopResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gsmCallResult, .gsmCallResult): return {
        guard case .gsmCallResult(let l) = lhs, case .gsmCallResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension FactoryTestMode: @unchecked Sendable {}
extension TestOperation: @unchecked Sendable {}
extension FACTORY_PAGE_TEST: @unchecked Sendable {}
extension PlacementTestResult: @unchecked Sendable {}
extension ChargeTestResult: @unchecked Sendable {}
extension DischargeTestResult: @unchecked Sendable {}
extension PressureTestResult: @unchecked Sendable {}
extension AutoTestResult: @unchecked Sendable {}
extension SensorTestResult: @unchecked Sendable {}
extension prox_cali: @unchecked Sendable {}
extension Test_prox: @unchecked Sendable {}
extension Test_temprature: @unchecked Sendable {}
extension Test_key: @unchecked Sendable {}
extension Test_diff0_data: @unchecked Sendable {}
extension Test_HR: @unchecked Sendable {}
extension Test_ECG: @unchecked Sendable {}
extension Test_konb: @unchecked Sendable {}
extension Test_Air_pressure: @unchecked Sendable {}
extension Test_gps: @unchecked Sendable {}
extension Test_gsm_wifi: @unchecked Sendable {}
extension Test_max32664: @unchecked Sendable {}
extension Test_hr_leak: @unchecked Sendable {}
extension Test_pah8009_leak: @unchecked Sendable {}
extension Test_gh3xxx_hr_leak: @unchecked Sendable {}
extension Test_pah831x_leak: @unchecked Sendable {}
extension Test_hrs3600_leak: @unchecked Sendable {}
extension Test_hx3918_leak: @unchecked Sendable {}
extension Test_oximeter: @unchecked Sendable {}
extension Test_hrv: @unchecked Sendable {}
extension Test_bioz: @unchecked Sendable {}
extension Test_bp_upressure: @unchecked Sendable {}
extension cell_info: @unchecked Sendable {}
extension Test_gsm_info: @unchecked Sendable {}
extension Test_gsm_loop: @unchecked Sendable {}
extension Test_gsm_call: @unchecked Sendable {}
extension FactoryTestNotify: @unchecked Sendable {}
extension FactoryTestConfim: @unchecked Sendable {}
extension FactoryTestConfim.OneOf_Params: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension FactoryTestMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISCHARGE_MODE"),
    1: .same(proto: "CHARGING_MODE"),
    2: .same(proto: "PRESSURE_MODE"),
    3: .same(proto: "PLACE_MODE"),
    4: .same(proto: "SENSOR_MODE"),
    5: .same(proto: "AUTO_TEST_MODE"),
    6: .same(proto: "FULLY_AUTO_RESULT_MODE"),
  ]
}

extension TestOperation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEST_START"),
    1: .same(proto: "TEST_STOP"),
    2: .same(proto: "TEST_RESULT"),
    3: .same(proto: "TEST_LAST_RESULT"),
  ]
}

extension FACTORY_PAGE_TEST: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MOTOR"),
    1: .same(proto: "HX3918_PROX_CALI"),
    2: .same(proto: "PROX"),
    3: .same(proto: "LIGHT"),
    4: .same(proto: "BUZZER"),
    5: .same(proto: "TEMPRATURE"),
    6: .same(proto: "KEY"),
    7: .same(proto: "OFFBODY"),
    8: .same(proto: "HR"),
    9: .same(proto: "ECG"),
    10: .same(proto: "KNOB"),
    11: .same(proto: "PRESSURE"),
    12: .same(proto: "GPS"),
    13: .same(proto: "GSM_WIFI"),
    14: .same(proto: "GSM_GPS"),
    15: .same(proto: "MAX32664"),
    16: .same(proto: "MAX32664_LEAK"),
    17: .same(proto: "HR_LEAK"),
    18: .same(proto: "HR_GREY_CARD"),
    19: .same(proto: "OXIMETER"),
    20: .same(proto: "HRV"),
    21: .same(proto: "BIOZ"),
    22: .same(proto: "SPL17"),
    23: .same(proto: "THIS_RESULT"),
    24: .same(proto: "GSM_INFO"),
    25: .same(proto: "GSM_LOOP"),
    26: .same(proto: "GSM_CALL"),
  ]
}

extension PlacementTestResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PlacementTestResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "placement_times"),
    2: .standard(proto: "placement_result"),
  ]

  public var isInitialized: Bool {
    if self._placementResult == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedSFixed32Field(value: &self.placementTimes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._placementResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.placementTimes.isEmpty {
      try visitor.visitPackedSFixed32Field(value: self.placementTimes, fieldNumber: 1)
    }
    try { if let v = self._placementResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PlacementTestResult, rhs: PlacementTestResult) -> Bool {
    if lhs.placementTimes != rhs.placementTimes {return false}
    if lhs._placementResult != rhs._placementResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChargeTestResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChargeTestResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "charge_times"),
    2: .standard(proto: "charge_result"),
  ]

  public var isInitialized: Bool {
    if self._chargeResult == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedSFixed32Field(value: &self.chargeTimes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._chargeResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.chargeTimes.isEmpty {
      try visitor.visitPackedSFixed32Field(value: self.chargeTimes, fieldNumber: 1)
    }
    try { if let v = self._chargeResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ChargeTestResult, rhs: ChargeTestResult) -> Bool {
    if lhs.chargeTimes != rhs.chargeTimes {return false}
    if lhs._chargeResult != rhs._chargeResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DischargeTestResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DischargeTestResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "discharge_times"),
    2: .standard(proto: "discharge_result"),
  ]

  public var isInitialized: Bool {
    if self._dischargeResult == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedSFixed32Field(value: &self.dischargeTimes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._dischargeResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.dischargeTimes.isEmpty {
      try visitor.visitPackedSFixed32Field(value: self.dischargeTimes, fieldNumber: 1)
    }
    try { if let v = self._dischargeResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DischargeTestResult, rhs: DischargeTestResult) -> Bool {
    if lhs.dischargeTimes != rhs.dischargeTimes {return false}
    if lhs._dischargeResult != rhs._dischargeResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PressureTestResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PressureTestResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pressure_times"),
    2: .standard(proto: "pressure_result"),
  ]

  public var isInitialized: Bool {
    if self._pressureResult == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedSFixed32Field(value: &self.pressureTimes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._pressureResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pressureTimes.isEmpty {
      try visitor.visitPackedSFixed32Field(value: self.pressureTimes, fieldNumber: 1)
    }
    try { if let v = self._pressureResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PressureTestResult, rhs: PressureTestResult) -> Bool {
    if lhs.pressureTimes != rhs.pressureTimes {return false}
    if lhs._pressureResult != rhs._pressureResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoTestResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AutoTestResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gsensor_result"),
    2: .standard(proto: "gsensor_chip_id"),
    3: .standard(proto: "ppg_result"),
    4: .standard(proto: "ecg_result"),
    5: .standard(proto: "bp_result"),
    6: .standard(proto: "temprature_result"),
    7: .standard(proto: "spi_flash_result"),
    8: .standard(proto: "encrypt_result"),
    9: .standard(proto: "bp_version"),
    10: .standard(proto: "oaq_result"),
    11: .standard(proto: "iaq_result"),
    12: .standard(proto: "humiture_result"),
  ]

  public var isInitialized: Bool {
    if self._gsensorResult == nil {return false}
    if self._gsensorChipID == nil {return false}
    if self._ppgResult == nil {return false}
    if self._ecgResult == nil {return false}
    if self._bpResult == nil {return false}
    if self._tempratureResult == nil {return false}
    if self._spiFlashResult == nil {return false}
    if self._encryptResult == nil {return false}
    if self._bpVersion == nil {return false}
    if self._oaqResult == nil {return false}
    if self._iaqResult == nil {return false}
    if self._humitureResult == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._gsensorResult) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._gsensorChipID) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._ppgResult) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._ecgResult) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self._bpResult) }()
      case 6: try { try decoder.decodeSingularFixed32Field(value: &self._tempratureResult) }()
      case 7: try { try decoder.decodeSingularFixed32Field(value: &self._spiFlashResult) }()
      case 8: try { try decoder.decodeSingularFixed32Field(value: &self._encryptResult) }()
      case 9: try { try decoder.decodeSingularFixed32Field(value: &self._bpVersion) }()
      case 10: try { try decoder.decodeSingularFixed32Field(value: &self._oaqResult) }()
      case 11: try { try decoder.decodeSingularFixed32Field(value: &self._iaqResult) }()
      case 12: try { try decoder.decodeSingularFixed32Field(value: &self._humitureResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._gsensorResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._gsensorChipID {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._ppgResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._ecgResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._bpResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._tempratureResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._spiFlashResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._encryptResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._bpVersion {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._oaqResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._iaqResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._humitureResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoTestResult, rhs: AutoTestResult) -> Bool {
    if lhs._gsensorResult != rhs._gsensorResult {return false}
    if lhs._gsensorChipID != rhs._gsensorChipID {return false}
    if lhs._ppgResult != rhs._ppgResult {return false}
    if lhs._ecgResult != rhs._ecgResult {return false}
    if lhs._bpResult != rhs._bpResult {return false}
    if lhs._tempratureResult != rhs._tempratureResult {return false}
    if lhs._spiFlashResult != rhs._spiFlashResult {return false}
    if lhs._encryptResult != rhs._encryptResult {return false}
    if lhs._bpVersion != rhs._bpVersion {return false}
    if lhs._oaqResult != rhs._oaqResult {return false}
    if lhs._iaqResult != rhs._iaqResult {return false}
    if lhs._humitureResult != rhs._humitureResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SensorTestResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SensorTestResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "motor_result"),
    2: .standard(proto: "light_result"),
    3: .standard(proto: "temprature_result"),
    4: .standard(proto: "hr_result"),
    5: .standard(proto: "ecg_touch_result"),
    6: .standard(proto: "hrv_result"),
    7: .standard(proto: "lcd_result"),
    8: .standard(proto: "tp_result"),
    9: .standard(proto: "gps_result"),
    10: .standard(proto: "bioz_result"),
    11: .standard(proto: "max32664_leak_result"),
    12: .standard(proto: "hr_leak_result"),
    13: .standard(proto: "grey_card_result"),
    14: .standard(proto: "gsensor_result"),
    15: .standard(proto: "offbody_result"),
    16: .standard(proto: "key_result"),
    17: .standard(proto: "spl17_result"),
    18: .standard(proto: "looptest_result"),
    19: .standard(proto: "gsm_result"),
    20: .standard(proto: "wifi_result"),
    21: .standard(proto: "pressure_sensor_result"),
    22: .standard(proto: "knob_result"),
    23: .standard(proto: "oximeter_result"),
    24: .standard(proto: "prox_cali_result"),
    25: .standard(proto: "prox_result"),
  ]

  fileprivate class _StorageClass {
    var _motorResult: UInt32? = nil
    var _lightResult: UInt32? = nil
    var _tempratureResult: UInt32? = nil
    var _hrResult: UInt32? = nil
    var _ecgTouchResult: UInt32? = nil
    var _hrvResult: UInt32? = nil
    var _lcdResult: UInt32? = nil
    var _tpResult: UInt32? = nil
    var _gpsResult: UInt32? = nil
    var _biozResult: UInt32? = nil
    var _max32664LeakResult: UInt32? = nil
    var _hrLeakResult: UInt32? = nil
    var _greyCardResult: UInt32? = nil
    var _gsensorResult: UInt32? = nil
    var _offbodyResult: UInt32? = nil
    var _keyResult: UInt32? = nil
    var _spl17Result: UInt32? = nil
    var _looptestResult: UInt32? = nil
    var _gsmResult: UInt32? = nil
    var _wifiResult: UInt32? = nil
    var _pressureSensorResult: UInt32? = nil
    var _knobResult: UInt32? = nil
    var _oximeterResult: UInt32? = nil
    var _proxCaliResult: UInt32? = nil
    var _proxResult: UInt32? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _motorResult = source._motorResult
      _lightResult = source._lightResult
      _tempratureResult = source._tempratureResult
      _hrResult = source._hrResult
      _ecgTouchResult = source._ecgTouchResult
      _hrvResult = source._hrvResult
      _lcdResult = source._lcdResult
      _tpResult = source._tpResult
      _gpsResult = source._gpsResult
      _biozResult = source._biozResult
      _max32664LeakResult = source._max32664LeakResult
      _hrLeakResult = source._hrLeakResult
      _greyCardResult = source._greyCardResult
      _gsensorResult = source._gsensorResult
      _offbodyResult = source._offbodyResult
      _keyResult = source._keyResult
      _spl17Result = source._spl17Result
      _looptestResult = source._looptestResult
      _gsmResult = source._gsmResult
      _wifiResult = source._wifiResult
      _pressureSensorResult = source._pressureSensorResult
      _knobResult = source._knobResult
      _oximeterResult = source._oximeterResult
      _proxCaliResult = source._proxCaliResult
      _proxResult = source._proxResult
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularFixed32Field(value: &_storage._motorResult) }()
        case 2: try { try decoder.decodeSingularFixed32Field(value: &_storage._lightResult) }()
        case 3: try { try decoder.decodeSingularFixed32Field(value: &_storage._tempratureResult) }()
        case 4: try { try decoder.decodeSingularFixed32Field(value: &_storage._hrResult) }()
        case 5: try { try decoder.decodeSingularFixed32Field(value: &_storage._ecgTouchResult) }()
        case 6: try { try decoder.decodeSingularFixed32Field(value: &_storage._hrvResult) }()
        case 7: try { try decoder.decodeSingularFixed32Field(value: &_storage._lcdResult) }()
        case 8: try { try decoder.decodeSingularFixed32Field(value: &_storage._tpResult) }()
        case 9: try { try decoder.decodeSingularFixed32Field(value: &_storage._gpsResult) }()
        case 10: try { try decoder.decodeSingularFixed32Field(value: &_storage._biozResult) }()
        case 11: try { try decoder.decodeSingularFixed32Field(value: &_storage._max32664LeakResult) }()
        case 12: try { try decoder.decodeSingularFixed32Field(value: &_storage._hrLeakResult) }()
        case 13: try { try decoder.decodeSingularFixed32Field(value: &_storage._greyCardResult) }()
        case 14: try { try decoder.decodeSingularFixed32Field(value: &_storage._gsensorResult) }()
        case 15: try { try decoder.decodeSingularFixed32Field(value: &_storage._offbodyResult) }()
        case 16: try { try decoder.decodeSingularFixed32Field(value: &_storage._keyResult) }()
        case 17: try { try decoder.decodeSingularFixed32Field(value: &_storage._spl17Result) }()
        case 18: try { try decoder.decodeSingularFixed32Field(value: &_storage._looptestResult) }()
        case 19: try { try decoder.decodeSingularFixed32Field(value: &_storage._gsmResult) }()
        case 20: try { try decoder.decodeSingularFixed32Field(value: &_storage._wifiResult) }()
        case 21: try { try decoder.decodeSingularFixed32Field(value: &_storage._pressureSensorResult) }()
        case 22: try { try decoder.decodeSingularFixed32Field(value: &_storage._knobResult) }()
        case 23: try { try decoder.decodeSingularFixed32Field(value: &_storage._oximeterResult) }()
        case 24: try { try decoder.decodeSingularFixed32Field(value: &_storage._proxCaliResult) }()
        case 25: try { try decoder.decodeSingularFixed32Field(value: &_storage._proxResult) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._motorResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._lightResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._tempratureResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._hrResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._ecgTouchResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._hrvResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._lcdResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._tpResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._gpsResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._biozResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._max32664LeakResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._hrLeakResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._greyCardResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._gsensorResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._offbodyResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._keyResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._spl17Result {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._looptestResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 18)
      } }()
      try { if let v = _storage._gsmResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 19)
      } }()
      try { if let v = _storage._wifiResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 20)
      } }()
      try { if let v = _storage._pressureSensorResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 21)
      } }()
      try { if let v = _storage._knobResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 22)
      } }()
      try { if let v = _storage._oximeterResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 23)
      } }()
      try { if let v = _storage._proxCaliResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 24)
      } }()
      try { if let v = _storage._proxResult {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 25)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SensorTestResult, rhs: SensorTestResult) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._motorResult != rhs_storage._motorResult {return false}
        if _storage._lightResult != rhs_storage._lightResult {return false}
        if _storage._tempratureResult != rhs_storage._tempratureResult {return false}
        if _storage._hrResult != rhs_storage._hrResult {return false}
        if _storage._ecgTouchResult != rhs_storage._ecgTouchResult {return false}
        if _storage._hrvResult != rhs_storage._hrvResult {return false}
        if _storage._lcdResult != rhs_storage._lcdResult {return false}
        if _storage._tpResult != rhs_storage._tpResult {return false}
        if _storage._gpsResult != rhs_storage._gpsResult {return false}
        if _storage._biozResult != rhs_storage._biozResult {return false}
        if _storage._max32664LeakResult != rhs_storage._max32664LeakResult {return false}
        if _storage._hrLeakResult != rhs_storage._hrLeakResult {return false}
        if _storage._greyCardResult != rhs_storage._greyCardResult {return false}
        if _storage._gsensorResult != rhs_storage._gsensorResult {return false}
        if _storage._offbodyResult != rhs_storage._offbodyResult {return false}
        if _storage._keyResult != rhs_storage._keyResult {return false}
        if _storage._spl17Result != rhs_storage._spl17Result {return false}
        if _storage._looptestResult != rhs_storage._looptestResult {return false}
        if _storage._gsmResult != rhs_storage._gsmResult {return false}
        if _storage._wifiResult != rhs_storage._wifiResult {return false}
        if _storage._pressureSensorResult != rhs_storage._pressureSensorResult {return false}
        if _storage._knobResult != rhs_storage._knobResult {return false}
        if _storage._oximeterResult != rhs_storage._oximeterResult {return false}
        if _storage._proxCaliResult != rhs_storage._proxCaliResult {return false}
        if _storage._proxResult != rhs_storage._proxResult {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension prox_cali: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "prox_cali"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fds_read_result"),
    2: .standard(proto: "prox_cali_result"),
  ]

  public var isInitialized: Bool {
    if self._proxCaliResult == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFixed32Field(value: &self.fdsReadResult) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._proxCaliResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.fdsReadResult.isEmpty {
      try visitor.visitPackedFixed32Field(value: self.fdsReadResult, fieldNumber: 1)
    }
    try { if let v = self._proxCaliResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: prox_cali, rhs: prox_cali) -> Bool {
    if lhs.fdsReadResult != rhs.fdsReadResult {return false}
    if lhs._proxCaliResult != rhs._proxCaliResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_prox: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_prox"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "diff0_data"),
  ]

  public var isInitialized: Bool {
    if self._diff0Data == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._diff0Data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._diff0Data {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_prox, rhs: Test_prox) -> Bool {
    if lhs._diff0Data != rhs._diff0Data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_temprature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_temprature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bodySurface"),
  ]

  public var isInitialized: Bool {
    if self._bodySurface == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._bodySurface) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bodySurface {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_temprature, rhs: Test_temprature) -> Bool {
    if lhs._bodySurface != rhs._bodySurface {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_key: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_key"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "key_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFixed32Field(value: &self.keyResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.keyResult.isEmpty {
      try visitor.visitPackedFixed32Field(value: self.keyResult, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_key, rhs: Test_key) -> Bool {
    if lhs.keyResult != rhs.keyResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_diff0_data: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_diff0_data"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "diff0_data"),
  ]

  public var isInitialized: Bool {
    if self._diff0Data == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._diff0Data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._diff0Data {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_diff0_data, rhs: Test_diff0_data) -> Bool {
    if lhs._diff0Data != rhs._diff0Data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_HR: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_HR"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hr_Value"),
    2: .standard(proto: "hr_state"),
    3: .standard(proto: "gsensor_value"),
  ]

  public var isInitialized: Bool {
    if self._hrValue == nil {return false}
    if self._hrState == nil {return false}
    if self._gsensorValue == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._hrValue) }()
      case 2: try { try decoder.decodeSingularSFixed32Field(value: &self._hrState) }()
      case 3: try { try decoder.decodeSingularSFixed32Field(value: &self._gsensorValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hrValue {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._hrState {
      try visitor.visitSingularSFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._gsensorValue {
      try visitor.visitSingularSFixed32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_HR, rhs: Test_HR) -> Bool {
    if lhs._hrValue != rhs._hrValue {return false}
    if lhs._hrState != rhs._hrState {return false}
    if lhs._gsensorValue != rhs._gsensorValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_ECG: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_ECG"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ecg_wear_data"),
    2: .standard(proto: "Touch_result"),
  ]

  public var isInitialized: Bool {
    if self._ecgWearData == nil {return false}
    if self._touchResult == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._ecgWearData) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._touchResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ecgWearData {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._touchResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_ECG, rhs: Test_ECG) -> Bool {
    if lhs._ecgWearData != rhs._ecgWearData {return false}
    if lhs._touchResult != rhs._touchResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_konb: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_konb"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Img_Qa"),
    2: .standard(proto: "PD_SAT"),
    3: .standard(proto: "Img_Qa_result"),
    4: .standard(proto: "PD_SAT_result"),
  ]

  public var isInitialized: Bool {
    if self._imgQa == nil {return false}
    if self._pdSat == nil {return false}
    if self._imgQaResult == nil {return false}
    if self._pdSatResult == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._imgQa) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._pdSat) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._imgQaResult) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._pdSatResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._imgQa {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._pdSat {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._imgQaResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pdSatResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_konb, rhs: Test_konb) -> Bool {
    if lhs._imgQa != rhs._imgQa {return false}
    if lhs._pdSat != rhs._pdSat {return false}
    if lhs._imgQaResult != rhs._imgQaResult {return false}
    if lhs._pdSatResult != rhs._pdSatResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_Air_pressure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_Air_pressure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "Air_pressure_value"),
  ]

  public var isInitialized: Bool {
    if self._airPressureValue == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._airPressureValue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._airPressureValue {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_Air_pressure, rhs: Test_Air_pressure) -> Bool {
    if lhs._airPressureValue != rhs._airPressureValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_gps: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_gps"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "location_state"),
    2: .standard(proto: "valid_satellite"),
    3: .standard(proto: "visible_satellite"),
    4: .standard(proto: "satellite_signal"),
    5: .same(proto: "avg"),
    6: .standard(proto: "gps_location_time"),
    7: .standard(proto: "epo_valid"),
    8: .standard(proto: "epo_weeknum"),
    9: .standard(proto: "fw_version"),
  ]

  public var isInitialized: Bool {
    if self._locationState == nil {return false}
    if self._validSatellite == nil {return false}
    if self._visibleSatellite == nil {return false}
    if self._avg == nil {return false}
    if self._gpsLocationTime == nil {return false}
    if self._epoValid == nil {return false}
    if self._epoWeeknum == nil {return false}
    if self._fwVersion == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._locationState) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._validSatellite) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._visibleSatellite) }()
      case 4: try { try decoder.decodeRepeatedFixed32Field(value: &self.satelliteSignal) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self._avg) }()
      case 6: try { try decoder.decodeSingularFixed32Field(value: &self._gpsLocationTime) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self._epoValid) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._epoWeeknum) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._fwVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._locationState {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._validSatellite {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._visibleSatellite {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    if !self.satelliteSignal.isEmpty {
      try visitor.visitPackedFixed32Field(value: self.satelliteSignal, fieldNumber: 4)
    }
    try { if let v = self._avg {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._gpsLocationTime {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._epoValid {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._epoWeeknum {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._fwVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_gps, rhs: Test_gps) -> Bool {
    if lhs._locationState != rhs._locationState {return false}
    if lhs._validSatellite != rhs._validSatellite {return false}
    if lhs._visibleSatellite != rhs._visibleSatellite {return false}
    if lhs.satelliteSignal != rhs.satelliteSignal {return false}
    if lhs._avg != rhs._avg {return false}
    if lhs._gpsLocationTime != rhs._gpsLocationTime {return false}
    if lhs._epoValid != rhs._epoValid {return false}
    if lhs._epoWeeknum != rhs._epoWeeknum {return false}
    if lhs._fwVersion != rhs._fwVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_gsm_wifi: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_gsm_wifi"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "wifi_result"),
  ]

  public var isInitialized: Bool {
    if self._wifiResult == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._wifiResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._wifiResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_gsm_wifi, rhs: Test_gsm_wifi) -> Bool {
    if lhs._wifiResult != rhs._wifiResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_max32664: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_max32664"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "version"),
    2: .standard(proto: "max32664_leak_1"),
    3: .standard(proto: "max32664_leak_2"),
    4: .standard(proto: "leak_result"),
  ]

  public var isInitialized: Bool {
    if self._version == nil {return false}
    if self._max32664Leak1 == nil {return false}
    if self._max32664Leak2 == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._version) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._max32664Leak1) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._max32664Leak2) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._leakResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._version {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._max32664Leak1 {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._max32664Leak2 {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._leakResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_max32664, rhs: Test_max32664) -> Bool {
    if lhs._version != rhs._version {return false}
    if lhs._max32664Leak1 != rhs._max32664Leak1 {return false}
    if lhs._max32664Leak2 != rhs._max32664Leak2 {return false}
    if lhs._leakResult != rhs._leakResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_hr_leak: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_hr_leak"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "led_valid"),
    2: .standard(proto: "hr_leak_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFixed32Field(value: &self.ledValid) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._hrLeakResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.ledValid.isEmpty {
      try visitor.visitPackedFixed32Field(value: self.ledValid, fieldNumber: 1)
    }
    try { if let v = self._hrLeakResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_hr_leak, rhs: Test_hr_leak) -> Bool {
    if lhs.ledValid != rhs.ledValid {return false}
    if lhs._hrLeakResult != rhs._hrLeakResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_pah8009_leak: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_pah8009_leak"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "adc"),
    2: .standard(proto: "ch_result"),
    3: .standard(proto: "pah8009_leak_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFixed32Field(value: &self.adc) }()
      case 2: try { try decoder.decodeRepeatedFixed32Field(value: &self.chResult) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._pah8009LeakResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.adc.isEmpty {
      try visitor.visitPackedFixed32Field(value: self.adc, fieldNumber: 1)
    }
    if !self.chResult.isEmpty {
      try visitor.visitPackedFixed32Field(value: self.chResult, fieldNumber: 2)
    }
    try { if let v = self._pah8009LeakResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_pah8009_leak, rhs: Test_pah8009_leak) -> Bool {
    if lhs.adc != rhs.adc {return false}
    if lhs.chResult != rhs.chResult {return false}
    if lhs._pah8009LeakResult != rhs._pah8009LeakResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_gh3xxx_hr_leak: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_gh3xxx_hr_leak"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gh3xx_os_test_ret"),
    2: .standard(proto: "hr_leak_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedFixed32Field(value: &self.gh3XxOsTestRet) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._hrLeakResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.gh3XxOsTestRet.isEmpty {
      try visitor.visitPackedFixed32Field(value: self.gh3XxOsTestRet, fieldNumber: 1)
    }
    try { if let v = self._hrLeakResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_gh3xxx_hr_leak, rhs: Test_gh3xxx_hr_leak) -> Bool {
    if lhs.gh3XxOsTestRet != rhs.gh3XxOsTestRet {return false}
    if lhs._hrLeakResult != rhs._hrLeakResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_pah831x_leak: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_pah831x_leak"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hr_leak_result"),
  ]

  public var isInitialized: Bool {
    if self._hrLeakResult == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._hrLeakResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hrLeakResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_pah831x_leak, rhs: Test_pah831x_leak) -> Bool {
    if lhs._hrLeakResult != rhs._hrLeakResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_hrs3600_leak: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_hrs3600_leak"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hrm_raw_data"),
    2: .standard(proto: "infrared_data"),
    3: .standard(proto: "hrs3600_leak_result"),
  ]

  public var isInitialized: Bool {
    if self._hrmRawData == nil {return false}
    if self._infraredData == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._hrmRawData) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._infraredData) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._hrs3600LeakResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hrmRawData {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._infraredData {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hrs3600LeakResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_hrs3600_leak, rhs: Test_hrs3600_leak) -> Bool {
    if lhs._hrmRawData != rhs._hrmRawData {return false}
    if lhs._infraredData != rhs._infraredData {return false}
    if lhs._hrs3600LeakResult != rhs._hrs3600LeakResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_hx3918_leak: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_hx3918_leak"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "leak_g"),
    2: .standard(proto: "leak_r"),
    3: .standard(proto: "leak_ir"),
    4: .standard(proto: "hr_leak_result"),
  ]

  public var isInitialized: Bool {
    if self._leakG == nil {return false}
    if self._leakR == nil {return false}
    if self._leakIr == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._leakG) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._leakR) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._leakIr) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._hrLeakResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._leakG {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._leakR {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._leakIr {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._hrLeakResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_hx3918_leak, rhs: Test_hx3918_leak) -> Bool {
    if lhs._leakG != rhs._leakG {return false}
    if lhs._leakR != rhs._leakR {return false}
    if lhs._leakIr != rhs._leakIr {return false}
    if lhs._hrLeakResult != rhs._hrLeakResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_oximeter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_oximeter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "oximeter_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._oximeterResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._oximeterResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_oximeter, rhs: Test_oximeter) -> Bool {
    if lhs._oximeterResult != rhs._oximeterResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_hrv: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_hrv"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hrv_voltage"),
    2: .standard(proto: "hrv_result"),
  ]

  public var isInitialized: Bool {
    if self._hrvVoltage == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._hrvVoltage) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._hrvResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hrvVoltage {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._hrvResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_hrv, rhs: Test_hrv) -> Bool {
    if lhs._hrvVoltage != rhs._hrvVoltage {return false}
    if lhs._hrvResult != rhs._hrvResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_bioz: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_bioz"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bioz_data"),
    2: .standard(proto: "bioz_result"),
  ]

  public var isInitialized: Bool {
    if self._biozData == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._biozData) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._biozResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._biozData {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._biozResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_bioz, rhs: Test_bioz) -> Bool {
    if lhs._biozData != rhs._biozData {return false}
    if lhs._biozResult != rhs._biozResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_bp_upressure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_bp_upressure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "upressure_valid"),
  ]

  public var isInitialized: Bool {
    if self._upressureValid == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._upressureValid) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._upressureValid {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_bp_upressure, rhs: Test_bp_upressure) -> Bool {
    if lhs._upressureValid != rhs._upressureValid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension cell_info: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "cell_info"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "state"),
    2: .standard(proto: "freq_band_ind"),
    3: .standard(proto: "UL_bandwidth"),
    4: .standard(proto: "DL_bandwidth"),
    5: .same(proto: "mcc"),
    6: .same(proto: "mnc"),
    7: .standard(proto: "csq_rssi"),
    8: .same(proto: "signal"),
    9: .same(proto: "rsrq"),
    10: .same(proto: "rssi"),
    11: .same(proto: "sinr"),
    12: .same(proto: "AcT"),
    13: .same(proto: "band"),
    14: .same(proto: "creg"),
  ]

  public var isInitialized: Bool {
    if self._state == nil {return false}
    if self._freqBandInd == nil {return false}
    if self._ulBandwidth == nil {return false}
    if self._dlBandwidth == nil {return false}
    if self._mcc == nil {return false}
    if self._mnc == nil {return false}
    if self._csqRssi == nil {return false}
    if self._signal == nil {return false}
    if self._rsrq == nil {return false}
    if self._rssi == nil {return false}
    if self._sinr == nil {return false}
    if self._acT == nil {return false}
    if self._band == nil {return false}
    if self._creg == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._state) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._freqBandInd) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._ulBandwidth) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._dlBandwidth) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._mcc) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._mnc) }()
      case 7: try { try decoder.decodeSingularFixed32Field(value: &self._csqRssi) }()
      case 8: try { try decoder.decodeSingularFixed32Field(value: &self._signal) }()
      case 9: try { try decoder.decodeSingularFixed32Field(value: &self._rsrq) }()
      case 10: try { try decoder.decodeSingularFixed32Field(value: &self._rssi) }()
      case 11: try { try decoder.decodeSingularFixed32Field(value: &self._sinr) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._acT) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self._band) }()
      case 14: try { try decoder.decodeSingularFixed32Field(value: &self._creg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._state {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._freqBandInd {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._ulBandwidth {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._dlBandwidth {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._mcc {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._mnc {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._csqRssi {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._signal {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._rsrq {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._rssi {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._sinr {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._acT {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._band {
      try visitor.visitSingularStringField(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._creg {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 14)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: cell_info, rhs: cell_info) -> Bool {
    if lhs._state != rhs._state {return false}
    if lhs._freqBandInd != rhs._freqBandInd {return false}
    if lhs._ulBandwidth != rhs._ulBandwidth {return false}
    if lhs._dlBandwidth != rhs._dlBandwidth {return false}
    if lhs._mcc != rhs._mcc {return false}
    if lhs._mnc != rhs._mnc {return false}
    if lhs._csqRssi != rhs._csqRssi {return false}
    if lhs._signal != rhs._signal {return false}
    if lhs._rsrq != rhs._rsrq {return false}
    if lhs._rssi != rhs._rssi {return false}
    if lhs._sinr != rhs._sinr {return false}
    if lhs._acT != rhs._acT {return false}
    if lhs._band != rhs._band {return false}
    if lhs._creg != rhs._creg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_gsm_info: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_gsm_info"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sim_ready"),
    2: .standard(proto: "gsm_cell_info"),
  ]

  public var isInitialized: Bool {
    if self._simReady == nil {return false}
    if let v = self._gsmCellInfo, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._simReady) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._gsmCellInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._simReady {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._gsmCellInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_gsm_info, rhs: Test_gsm_info) -> Bool {
    if lhs._simReady != rhs._simReady {return false}
    if lhs._gsmCellInfo != rhs._gsmCellInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_gsm_loop: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_gsm_loop"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "test_recording"),
  ]

  public var isInitialized: Bool {
    if self._testRecording == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._testRecording) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._testRecording {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_gsm_loop, rhs: Test_gsm_loop) -> Bool {
    if lhs._testRecording != rhs._testRecording {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Test_gsm_call: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Test_gsm_call"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "call_ready"),
  ]

  public var isInitialized: Bool {
    if self._callReady == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._callReady) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._callReady {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Test_gsm_call, rhs: Test_gsm_call) -> Bool {
    if lhs._callReady != rhs._callReady {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FactoryTestNotify: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FactoryTestNotify"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .same(proto: "operation"),
    3: .standard(proto: "Sensor_Result"),
    4: .standard(proto: "pressure_hour"),
    5: .standard(proto: "Placement_hour"),
    6: .standard(proto: "operation_page"),
  ]

  public var isInitialized: Bool {
    if self._mode == nil {return false}
    if self._operation == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._mode) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._operation) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._sensorResult) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._pressureHour) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self._placementHour) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self._operationPage) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._operation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sensorResult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._pressureHour {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._placementHour {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._operationPage {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FactoryTestNotify, rhs: FactoryTestNotify) -> Bool {
    if lhs._mode != rhs._mode {return false}
    if lhs._operation != rhs._operation {return false}
    if lhs._sensorResult != rhs._sensorResult {return false}
    if lhs._pressureHour != rhs._pressureHour {return false}
    if lhs._placementHour != rhs._placementHour {return false}
    if lhs._operationPage != rhs._operationPage {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FactoryTestConfim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FactoryTestConfim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .same(proto: "ret"),
    3: .same(proto: "operation"),
    4: .standard(proto: "discharge_Result"),
    5: .standard(proto: "charge_Result"),
    6: .standard(proto: "pressure_Result"),
    7: .standard(proto: "placement_Result"),
    8: .standard(proto: "Auto_Result"),
    9: .standard(proto: "Sensor_Result"),
    10: .standard(proto: "prox_cali_result"),
    11: .standard(proto: "prox_result"),
    12: .standard(proto: "temprature_result"),
    13: .standard(proto: "key_result"),
    14: .standard(proto: "diff0_data_result"),
    15: .standard(proto: "HR_Result"),
    16: .standard(proto: "ECG_result"),
    17: .standard(proto: "konb_result"),
    18: .standard(proto: "Air_pressure_result"),
    19: .standard(proto: "gps_result"),
    20: .standard(proto: "gsm_wifi_result"),
    21: .standard(proto: "max32664_result"),
    22: .standard(proto: "pah8009_leak_result"),
    23: .standard(proto: "gh3xxx_hr_leak_result"),
    24: .standard(proto: "pah831x_leak_result"),
    25: .standard(proto: "hrs3600_leak_result"),
    26: .standard(proto: "hx3918_leak_result"),
    27: .standard(proto: "oximeter_result"),
    28: .standard(proto: "hrv_result"),
    29: .standard(proto: "bioz_result"),
    30: .standard(proto: "bp_upressure_result"),
    31: .standard(proto: "gsm_info_result"),
    32: .standard(proto: "gsm_loop_result"),
    33: .standard(proto: "gsm_call_result"),
  ]

  fileprivate class _StorageClass {
    var _mode: FactoryTestMode? = nil
    var _ret: Bool? = nil
    var _operation: TestOperation? = nil
    var _params: FactoryTestConfim.OneOf_Params?

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _mode = source._mode
      _ret = source._ret
      _operation = source._operation
      _params = source._params
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._mode == nil {return false}
      if _storage._ret == nil {return false}
      if _storage._operation == nil {return false}
      if let v = _storage._params, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._mode) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._ret) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._operation) }()
        case 4: try {
          var v: DischargeTestResult?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .dischargeResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .dischargeResult(v)
          }
        }()
        case 5: try {
          var v: ChargeTestResult?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .chargeResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .chargeResult(v)
          }
        }()
        case 6: try {
          var v: PressureTestResult?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .pressureResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .pressureResult(v)
          }
        }()
        case 7: try {
          var v: PlacementTestResult?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .placementResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .placementResult(v)
          }
        }()
        case 8: try {
          var v: AutoTestResult?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .autoResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .autoResult(v)
          }
        }()
        case 9: try {
          var v: SensorTestResult?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .sensorResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .sensorResult(v)
          }
        }()
        case 10: try {
          var v: prox_cali?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .proxCaliResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .proxCaliResult(v)
          }
        }()
        case 11: try {
          var v: Test_prox?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .proxResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .proxResult(v)
          }
        }()
        case 12: try {
          var v: Test_temprature?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .tempratureResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .tempratureResult(v)
          }
        }()
        case 13: try {
          var v: Test_key?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .keyResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .keyResult(v)
          }
        }()
        case 14: try {
          var v: Test_diff0_data?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .diff0DataResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .diff0DataResult(v)
          }
        }()
        case 15: try {
          var v: Test_HR?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .hrResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .hrResult(v)
          }
        }()
        case 16: try {
          var v: Test_ECG?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .ecgResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .ecgResult(v)
          }
        }()
        case 17: try {
          var v: Test_konb?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .konbResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .konbResult(v)
          }
        }()
        case 18: try {
          var v: Test_Air_pressure?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .airPressureResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .airPressureResult(v)
          }
        }()
        case 19: try {
          var v: Test_gps?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .gpsResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .gpsResult(v)
          }
        }()
        case 20: try {
          var v: Test_gsm_wifi?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .gsmWifiResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .gsmWifiResult(v)
          }
        }()
        case 21: try {
          var v: Test_max32664?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .max32664Result(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .max32664Result(v)
          }
        }()
        case 22: try {
          var v: Test_pah8009_leak?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .pah8009LeakResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .pah8009LeakResult(v)
          }
        }()
        case 23: try {
          var v: Test_gh3xxx_hr_leak?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .gh3XxxHrLeakResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .gh3XxxHrLeakResult(v)
          }
        }()
        case 24: try {
          var v: Test_pah831x_leak?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .pah831XLeakResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .pah831XLeakResult(v)
          }
        }()
        case 25: try {
          var v: Test_hrs3600_leak?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .hrs3600LeakResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .hrs3600LeakResult(v)
          }
        }()
        case 26: try {
          var v: Test_hx3918_leak?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .hx3918LeakResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .hx3918LeakResult(v)
          }
        }()
        case 27: try {
          var v: Test_oximeter?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .oximeterResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .oximeterResult(v)
          }
        }()
        case 28: try {
          var v: Test_hrv?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .hrvResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .hrvResult(v)
          }
        }()
        case 29: try {
          var v: Test_bioz?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .biozResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .biozResult(v)
          }
        }()
        case 30: try {
          var v: Test_bp_upressure?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .bpUpressureResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .bpUpressureResult(v)
          }
        }()
        case 31: try {
          var v: Test_gsm_info?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .gsmInfoResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .gsmInfoResult(v)
          }
        }()
        case 32: try {
          var v: Test_gsm_loop?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .gsmLoopResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .gsmLoopResult(v)
          }
        }()
        case 33: try {
          var v: Test_gsm_call?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .gsmCallResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .gsmCallResult(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._mode {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._ret {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._operation {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      } }()
      switch _storage._params {
      case .dischargeResult?: try {
        guard case .dischargeResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .chargeResult?: try {
        guard case .chargeResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .pressureResult?: try {
        guard case .pressureResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .placementResult?: try {
        guard case .placementResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .autoResult?: try {
        guard case .autoResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .sensorResult?: try {
        guard case .sensorResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case .proxCaliResult?: try {
        guard case .proxCaliResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
      }()
      case .proxResult?: try {
        guard case .proxResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      }()
      case .tempratureResult?: try {
        guard case .tempratureResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      }()
      case .keyResult?: try {
        guard case .keyResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      }()
      case .diff0DataResult?: try {
        guard case .diff0DataResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      }()
      case .hrResult?: try {
        guard case .hrResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      }()
      case .ecgResult?: try {
        guard case .ecgResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      }()
      case .konbResult?: try {
        guard case .konbResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      }()
      case .airPressureResult?: try {
        guard case .airPressureResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 18)
      }()
      case .gpsResult?: try {
        guard case .gpsResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 19)
      }()
      case .gsmWifiResult?: try {
        guard case .gsmWifiResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 20)
      }()
      case .max32664Result?: try {
        guard case .max32664Result(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 21)
      }()
      case .pah8009LeakResult?: try {
        guard case .pah8009LeakResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 22)
      }()
      case .gh3XxxHrLeakResult?: try {
        guard case .gh3XxxHrLeakResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 23)
      }()
      case .pah831XLeakResult?: try {
        guard case .pah831XLeakResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 24)
      }()
      case .hrs3600LeakResult?: try {
        guard case .hrs3600LeakResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 25)
      }()
      case .hx3918LeakResult?: try {
        guard case .hx3918LeakResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 26)
      }()
      case .oximeterResult?: try {
        guard case .oximeterResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 27)
      }()
      case .hrvResult?: try {
        guard case .hrvResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 28)
      }()
      case .biozResult?: try {
        guard case .biozResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 29)
      }()
      case .bpUpressureResult?: try {
        guard case .bpUpressureResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 30)
      }()
      case .gsmInfoResult?: try {
        guard case .gsmInfoResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 31)
      }()
      case .gsmLoopResult?: try {
        guard case .gsmLoopResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 32)
      }()
      case .gsmCallResult?: try {
        guard case .gsmCallResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 33)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FactoryTestConfim, rhs: FactoryTestConfim) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._mode != rhs_storage._mode {return false}
        if _storage._ret != rhs_storage._ret {return false}
        if _storage._operation != rhs_storage._operation {return false}
        if _storage._params != rhs_storage._params {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
