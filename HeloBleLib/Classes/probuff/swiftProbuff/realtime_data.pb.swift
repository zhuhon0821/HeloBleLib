// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: realtime_data.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum RtMode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case backNormal // = 0
  case enterCamera // = 1
  case rtStartFindWatch // = 2
  case rtStartDfuMode // = 3
  case hrMeasure // = 4
  case fatigueMeasure // = 5
  case pressureMeasure // = 6
  case rtViewMeasureState // = 7

  init() {
    self = .backNormal
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .backNormal
    case 1: self = .enterCamera
    case 2: self = .rtStartFindWatch
    case 3: self = .rtStartDfuMode
    case 4: self = .hrMeasure
    case 5: self = .fatigueMeasure
    case 6: self = .pressureMeasure
    case 7: self = .rtViewMeasureState
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .backNormal: return 0
    case .enterCamera: return 1
    case .rtStartFindWatch: return 2
    case .rtStartDfuMode: return 3
    case .hrMeasure: return 4
    case .fatigueMeasure: return 5
    case .pressureMeasure: return 6
    case .rtViewMeasureState: return 7
    }
  }

}

#if swift(>=4.2)

extension RtMode: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum RtKeyEvent: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case rtKeyCamera // = 0
  case rtKeyAudioPlay // = 1
  case rtKeyAudioPre // = 2
  case rtKeyAudioNext // = 3
  case rtKeyAudioVolumeUp // = 4
  case rtKeyAudioVolumeDown // = 5
  case rtStartFindPhone // = 6
  case rtStopFindDevice // = 7
  case rtLnHealthMeasure // = 8
  case rtNoneMeasure // = 9

  init() {
    self = .rtKeyCamera
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .rtKeyCamera
    case 1: self = .rtKeyAudioPlay
    case 2: self = .rtKeyAudioPre
    case 3: self = .rtKeyAudioNext
    case 4: self = .rtKeyAudioVolumeUp
    case 5: self = .rtKeyAudioVolumeDown
    case 6: self = .rtStartFindPhone
    case 7: self = .rtStopFindDevice
    case 8: self = .rtLnHealthMeasure
    case 9: self = .rtNoneMeasure
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .rtKeyCamera: return 0
    case .rtKeyAudioPlay: return 1
    case .rtKeyAudioPre: return 2
    case .rtKeyAudioNext: return 3
    case .rtKeyAudioVolumeUp: return 4
    case .rtKeyAudioVolumeDown: return 5
    case .rtStartFindPhone: return 6
    case .rtStopFindDevice: return 7
    case .rtLnHealthMeasure: return 8
    case .rtNoneMeasure: return 9
    }
  }

}

#if swift(>=4.2)

extension RtKeyEvent: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum RtSync: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case stopAll // = 0
  case onlyOnce // = 1
  case onValueChange // = 2
  case onSecondChange // = 3
  case onMinuteChange // = 4
  case onHourChange // = 5
  case onDayChange // = 6
  case onTenMinuteChange // = 7

  init() {
    self = .stopAll
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .stopAll
    case 1: self = .onlyOnce
    case 2: self = .onValueChange
    case 3: self = .onSecondChange
    case 4: self = .onMinuteChange
    case 5: self = .onHourChange
    case 6: self = .onDayChange
    case 7: self = .onTenMinuteChange
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .stopAll: return 0
    case .onlyOnce: return 1
    case .onValueChange: return 2
    case .onSecondChange: return 3
    case .onMinuteChange: return 4
    case .onHourChange: return 5
    case .onDayChange: return 6
    case .onTenMinuteChange: return 7
    }
  }

}

#if swift(>=4.2)

extension RtSync: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum SensorType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case none // = 0
  case ecg // = 1
  case ppg // = 2
  case mag // = 4
  case gyro // = 8
  case acc // = 16
  case bp // = 32
  case bpresult // = 64
  case temperature // = 128
  case twoEcg // = 256
  case bioz // = 512
  case ecgDetect // = 1024
  case factoryEcg // = 2048
  case factoryBioz // = 4096
  case hrLeak // = 8192
  case bpLeak // = 16384
  case spo2 // = 32768
  case oaq // = 65536
  case iaq // = 131072
  case humiture // = 262144
  case ultrasonic // = 524288

  init() {
    self = .none
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .none
    case 1: self = .ecg
    case 2: self = .ppg
    case 4: self = .mag
    case 8: self = .gyro
    case 16: self = .acc
    case 32: self = .bp
    case 64: self = .bpresult
    case 128: self = .temperature
    case 256: self = .twoEcg
    case 512: self = .bioz
    case 1024: self = .ecgDetect
    case 2048: self = .factoryEcg
    case 4096: self = .factoryBioz
    case 8192: self = .hrLeak
    case 16384: self = .bpLeak
    case 32768: self = .spo2
    case 65536: self = .oaq
    case 131072: self = .iaq
    case 262144: self = .humiture
    case 524288: self = .ultrasonic
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .none: return 0
    case .ecg: return 1
    case .ppg: return 2
    case .mag: return 4
    case .gyro: return 8
    case .acc: return 16
    case .bp: return 32
    case .bpresult: return 64
    case .temperature: return 128
    case .twoEcg: return 256
    case .bioz: return 512
    case .ecgDetect: return 1024
    case .factoryEcg: return 2048
    case .factoryBioz: return 4096
    case .hrLeak: return 8192
    case .bpLeak: return 16384
    case .spo2: return 32768
    case .oaq: return 65536
    case .iaq: return 131072
    case .humiture: return 262144
    case .ultrasonic: return 524288
    }
  }

}

#if swift(>=4.2)

extension SensorType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum SensorOperation: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// start sync
  case sensorStartSync // = 0

  /// pause sync
  case sensorPauseSync // = 1

  /// stop sync
  case sensorStopSync // = 2

  init() {
    self = .sensorStartSync
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sensorStartSync
    case 1: self = .sensorPauseSync
    case 2: self = .sensorStopSync
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .sensorStartSync: return 0
    case .sensorPauseSync: return 1
    case .sensorStopSync: return 2
    }
  }

}

#if swift(>=4.2)

extension SensorOperation: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct RtTime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var seconds: UInt32 {
    get {return _seconds ?? 0}
    set {_seconds = newValue}
  }
  /// Returns true if `seconds` has been explicitly set.
  var hasSeconds: Bool {return self._seconds != nil}
  /// Clears the value of `seconds`. Subsequent reads from it will return its default value.
  mutating func clearSeconds() {self._seconds = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _seconds: UInt32? = nil
}

struct DateTime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dateTime: RtTime {
    get {return _dateTime ?? RtTime()}
    set {_dateTime = newValue}
  }
  /// Returns true if `dateTime` has been explicitly set.
  var hasDateTime: Bool {return self._dateTime != nil}
  /// Clears the value of `dateTime`. Subsequent reads from it will return its default value.
  mutating func clearDateTime() {self._dateTime = nil}

  var timeZone: Int32 {
    get {return _timeZone ?? 0}
    set {_timeZone = newValue}
  }
  /// Returns true if `timeZone` has been explicitly set.
  var hasTimeZone: Bool {return self._timeZone != nil}
  /// Clears the value of `timeZone`. Subsequent reads from it will return its default value.
  mutating func clearTimeZone() {self._timeZone = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _dateTime: RtTime? = nil
  fileprivate var _timeZone: Int32? = nil
}

struct RtBattery {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///0~9
  var level: UInt32 {
    get {return _level ?? 0}
    set {_level = newValue}
  }
  /// Returns true if `level` has been explicitly set.
  var hasLevel: Bool {return self._level != nil}
  /// Clears the value of `level`. Subsequent reads from it will return its default value.
  mutating func clearLevel() {self._level = nil}

  var charging: Bool {
    get {return _charging ?? false}
    set {_charging = newValue}
  }
  /// Returns true if `charging` has been explicitly set.
  var hasCharging: Bool {return self._charging != nil}
  /// Clears the value of `charging`. Subsequent reads from it will return its default value.
  mutating func clearCharging() {self._charging = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _level: UInt32? = nil
  fileprivate var _charging: Bool? = nil
}

struct RtHealth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var steps: UInt32 {
    get {return _steps ?? 0}
    set {_steps = newValue}
  }
  /// Returns true if `steps` has been explicitly set.
  var hasSteps: Bool {return self._steps != nil}
  /// Clears the value of `steps`. Subsequent reads from it will return its default value.
  mutating func clearSteps() {self._steps = nil}

  var distance: UInt32 {
    get {return _distance ?? 0}
    set {_distance = newValue}
  }
  /// Returns true if `distance` has been explicitly set.
  var hasDistance: Bool {return self._distance != nil}
  /// Clears the value of `distance`. Subsequent reads from it will return its default value.
  mutating func clearDistance() {self._distance = nil}

  var calorie: UInt32 {
    get {return _calorie ?? 0}
    set {_calorie = newValue}
  }
  /// Returns true if `calorie` has been explicitly set.
  var hasCalorie: Bool {return self._calorie != nil}
  /// Clears the value of `calorie`. Subsequent reads from it will return its default value.
  mutating func clearCalorie() {self._calorie = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _steps: UInt32? = nil
  fileprivate var _distance: UInt32? = nil
  fileprivate var _calorie: UInt32? = nil
}

struct BPresult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sbp: UInt32 {
    get {return _sbp ?? 0}
    set {_sbp = newValue}
  }
  /// Returns true if `sbp` has been explicitly set.
  var hasSbp: Bool {return self._sbp != nil}
  /// Clears the value of `sbp`. Subsequent reads from it will return its default value.
  mutating func clearSbp() {self._sbp = nil}

  var dbp: UInt32 {
    get {return _dbp ?? 0}
    set {_dbp = newValue}
  }
  /// Returns true if `dbp` has been explicitly set.
  var hasDbp: Bool {return self._dbp != nil}
  /// Clears the value of `dbp`. Subsequent reads from it will return its default value.
  mutating func clearDbp() {self._dbp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sbp: UInt32? = nil
  fileprivate var _dbp: UInt32? = nil
}

struct RtHealthResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fatigue: UInt32 {
    get {return _fatigue ?? 0}
    set {_fatigue = newValue}
  }
  /// Returns true if `fatigue` has been explicitly set.
  var hasFatigue: Bool {return self._fatigue != nil}
  /// Clears the value of `fatigue`. Subsequent reads from it will return its default value.
  mutating func clearFatigue() {self._fatigue = nil}

  var stress: UInt32 {
    get {return _stress ?? 0}
    set {_stress = newValue}
  }
  /// Returns true if `stress` has been explicitly set.
  var hasStress: Bool {return self._stress != nil}
  /// Clears the value of `stress`. Subsequent reads from it will return its default value.
  mutating func clearStress() {self._stress = nil}

  var spo2: UInt32 {
    get {return _spo2 ?? 0}
    set {_spo2 = newValue}
  }
  /// Returns true if `spo2` has been explicitly set.
  var hasSpo2: Bool {return self._spo2 != nil}
  /// Clears the value of `spo2`. Subsequent reads from it will return its default value.
  mutating func clearSpo2() {self._spo2 = nil}

  var hr: UInt32 {
    get {return _hr ?? 0}
    set {_hr = newValue}
  }
  /// Returns true if `hr` has been explicitly set.
  var hasHr: Bool {return self._hr != nil}
  /// Clears the value of `hr`. Subsequent reads from it will return its default value.
  mutating func clearHr() {self._hr = nil}

  var bp: BPresult {
    get {return _bp ?? BPresult()}
    set {_bp = newValue}
  }
  /// Returns true if `bp` has been explicitly set.
  var hasBp: Bool {return self._bp != nil}
  /// Clears the value of `bp`. Subsequent reads from it will return its default value.
  mutating func clearBp() {self._bp = nil}

  var breathrate: UInt32 {
    get {return _breathrate ?? 0}
    set {_breathrate = newValue}
  }
  /// Returns true if `breathrate` has been explicitly set.
  var hasBreathrate: Bool {return self._breathrate != nil}
  /// Clears the value of `breathrate`. Subsequent reads from it will return its default value.
  mutating func clearBreathrate() {self._breathrate = nil}

  var temperatur: UInt32 {
    get {return _temperatur ?? 0}
    set {_temperatur = newValue}
  }
  /// Returns true if `temperatur` has been explicitly set.
  var hasTemperatur: Bool {return self._temperatur != nil}
  /// Clears the value of `temperatur`. Subsequent reads from it will return its default value.
  mutating func clearTemperatur() {self._temperatur = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fatigue: UInt32? = nil
  fileprivate var _stress: UInt32? = nil
  fileprivate var _spo2: UInt32? = nil
  fileprivate var _hr: UInt32? = nil
  fileprivate var _bp: BPresult? = nil
  fileprivate var _breathrate: UInt32? = nil
  fileprivate var _temperatur: UInt32? = nil
}

struct RtGNSS {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var longitude: Float {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {self._longitude = nil}

  var latitude: Float {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {self._latitude = nil}

  /// m/s
  var speed: Float {
    get {return _speed ?? 0}
    set {_speed = newValue}
  }
  /// Returns true if `speed` has been explicitly set.
  var hasSpeed: Bool {return self._speed != nil}
  /// Clears the value of `speed`. Subsequent reads from it will return its default value.
  mutating func clearSpeed() {self._speed = nil}

  /// m
  var altitude: Float {
    get {return _altitude ?? 0}
    set {_altitude = newValue}
  }
  /// Returns true if `altitude` has been explicitly set.
  var hasAltitude: Bool {return self._altitude != nil}
  /// Clears the value of `altitude`. Subsequent reads from it will return its default value.
  mutating func clearAltitude() {self._altitude = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _longitude: Float? = nil
  fileprivate var _latitude: Float? = nil
  fileprivate var _speed: Float? = nil
  fileprivate var _altitude: Float? = nil
}

struct RtSensor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var operation: SensorOperation {
    get {return _operation ?? .sensorStartSync}
    set {_operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  var hasOperation: Bool {return self._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  mutating func clearOperation() {self._operation = nil}

  var type: UInt32 {
    get {return _type ?? 0}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _operation: SensorOperation? = nil
  fileprivate var _type: UInt32? = nil
}

struct RtSubscriber {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var time: RtSync {
    get {return _time ?? .stopAll}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var battery: RtSync {
    get {return _battery ?? .stopAll}
    set {_battery = newValue}
  }
  /// Returns true if `battery` has been explicitly set.
  var hasBattery: Bool {return self._battery != nil}
  /// Clears the value of `battery`. Subsequent reads from it will return its default value.
  mutating func clearBattery() {self._battery = nil}

  var health: RtSync {
    get {return _health ?? .stopAll}
    set {_health = newValue}
  }
  /// Returns true if `health` has been explicitly set.
  var hasHealth: Bool {return self._health != nil}
  /// Clears the value of `health`. Subsequent reads from it will return its default value.
  mutating func clearHealth() {self._health = nil}

  var mode: RtMode {
    get {return _mode ?? .backNormal}
    set {_mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  var hasMode: Bool {return self._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  mutating func clearMode() {self._mode = nil}

  var sensor: RtSensor {
    get {return _sensor ?? RtSensor()}
    set {_sensor = newValue}
  }
  /// Returns true if `sensor` has been explicitly set.
  var hasSensor: Bool {return self._sensor != nil}
  /// Clears the value of `sensor`. Subsequent reads from it will return its default value.
  mutating func clearSensor() {self._sensor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _time: RtSync? = nil
  fileprivate var _battery: RtSync? = nil
  fileprivate var _health: RtSync? = nil
  fileprivate var _mode: RtMode? = nil
  fileprivate var _sensor: RtSensor? = nil
}

struct RtData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var time: RtTime {
    get {return _time ?? RtTime()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var battery: RtBattery {
    get {return _battery ?? RtBattery()}
    set {_battery = newValue}
  }
  /// Returns true if `battery` has been explicitly set.
  var hasBattery: Bool {return self._battery != nil}
  /// Clears the value of `battery`. Subsequent reads from it will return its default value.
  mutating func clearBattery() {self._battery = nil}

  var health: RtHealth {
    get {return _health ?? RtHealth()}
    set {_health = newValue}
  }
  /// Returns true if `health` has been explicitly set.
  var hasHealth: Bool {return self._health != nil}
  /// Clears the value of `health`. Subsequent reads from it will return its default value.
  mutating func clearHealth() {self._health = nil}

  var key: RtKeyEvent {
    get {return _key ?? .rtKeyCamera}
    set {_key = newValue}
  }
  /// Returns true if `key` has been explicitly set.
  var hasKey: Bool {return self._key != nil}
  /// Clears the value of `key`. Subsequent reads from it will return its default value.
  mutating func clearKey() {self._key = nil}

  var timeZone: Int32 {
    get {return _timeZone ?? 0}
    set {_timeZone = newValue}
  }
  /// Returns true if `timeZone` has been explicitly set.
  var hasTimeZone: Bool {return self._timeZone != nil}
  /// Clears the value of `timeZone`. Subsequent reads from it will return its default value.
  mutating func clearTimeZone() {self._timeZone = nil}

  var healthresult: RtHealthResult {
    get {return _healthresult ?? RtHealthResult()}
    set {_healthresult = newValue}
  }
  /// Returns true if `healthresult` has been explicitly set.
  var hasHealthresult: Bool {return self._healthresult != nil}
  /// Clears the value of `healthresult`. Subsequent reads from it will return its default value.
  mutating func clearHealthresult() {self._healthresult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _time: RtTime? = nil
  fileprivate var _battery: RtBattery? = nil
  fileprivate var _health: RtHealth? = nil
  fileprivate var _key: RtKeyEvent? = nil
  fileprivate var _timeZone: Int32? = nil
  fileprivate var _healthresult: RtHealthResult? = nil
}

struct RtState {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var time: RtSync {
    get {return _time ?? .stopAll}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var battery: RtSync {
    get {return _battery ?? .stopAll}
    set {_battery = newValue}
  }
  /// Returns true if `battery` has been explicitly set.
  var hasBattery: Bool {return self._battery != nil}
  /// Clears the value of `battery`. Subsequent reads from it will return its default value.
  mutating func clearBattery() {self._battery = nil}

  var health: RtSync {
    get {return _health ?? .stopAll}
    set {_health = newValue}
  }
  /// Returns true if `health` has been explicitly set.
  var hasHealth: Bool {return self._health != nil}
  /// Clears the value of `health`. Subsequent reads from it will return its default value.
  mutating func clearHealth() {self._health = nil}

  var mode: RtMode {
    get {return _mode ?? .backNormal}
    set {_mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  var hasMode: Bool {return self._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  mutating func clearMode() {self._mode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _time: RtSync? = nil
  fileprivate var _battery: RtSync? = nil
  fileprivate var _health: RtSync? = nil
  fileprivate var _mode: RtMode? = nil
}

struct RtSensorData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: UInt32 {
    get {return _type ?? 0}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var time: RtTime {
    get {return _time ?? RtTime()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var seq: UInt32 {
    get {return _seq ?? 0}
    set {_seq = newValue}
  }
  /// Returns true if `seq` has been explicitly set.
  var hasSeq: Bool {return self._seq != nil}
  /// Clears the value of `seq`. Subsequent reads from it will return its default value.
  mutating func clearSeq() {self._seq = nil}

  var data: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: UInt32? = nil
  fileprivate var _time: RtTime? = nil
  fileprivate var _seq: UInt32? = nil
}

struct RtNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: RtNotification.OneOf_Data? = nil

  var rtData: RtData {
    get {
      if case .rtData(let v)? = data {return v}
      return RtData()
    }
    set {data = .rtData(newValue)}
  }

  var rtState: RtState {
    get {
      if case .rtState(let v)? = data {return v}
      return RtState()
    }
    set {data = .rtState(newValue)}
  }

  var rtSensordata: RtSensorData {
    get {
      if case .rtSensordata(let v)? = data {return v}
      return RtSensorData()
    }
    set {data = .rtSensordata(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    case rtData(RtData)
    case rtState(RtState)
    case rtSensordata(RtSensorData)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .rtData: return {
        guard case .rtData(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .rtSensordata: return {
        guard case .rtSensordata(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      default: return true
      }
    }

  #if !swift(>=4.1)
    static func ==(lhs: RtNotification.OneOf_Data, rhs: RtNotification.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.rtData, .rtData): return {
        guard case .rtData(let l) = lhs, case .rtData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rtState, .rtState): return {
        guard case .rtState(let l) = lhs, case .rtState(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rtSensordata, .rtSensordata): return {
        guard case .rtSensordata(let l) = lhs, case .rtSensordata(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension RtMode: @unchecked Sendable {}
extension RtKeyEvent: @unchecked Sendable {}
extension RtSync: @unchecked Sendable {}
extension SensorType: @unchecked Sendable {}
extension SensorOperation: @unchecked Sendable {}
extension RtTime: @unchecked Sendable {}
extension DateTime: @unchecked Sendable {}
extension RtBattery: @unchecked Sendable {}
extension RtHealth: @unchecked Sendable {}
extension BPresult: @unchecked Sendable {}
extension RtHealthResult: @unchecked Sendable {}
extension RtGNSS: @unchecked Sendable {}
extension RtSensor: @unchecked Sendable {}
extension RtSubscriber: @unchecked Sendable {}
extension RtData: @unchecked Sendable {}
extension RtState: @unchecked Sendable {}
extension RtSensorData: @unchecked Sendable {}
extension RtNotification: @unchecked Sendable {}
extension RtNotification.OneOf_Data: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension RtMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RT_MODE_BACK_NORMAL"),
    1: .same(proto: "RT_MODE_ENTER_CAMERA"),
    2: .same(proto: "RT_START_FIND_WATCH"),
    3: .same(proto: "RT_START_DFU_MODE"),
    4: .same(proto: "RT_MODE_HR_MEASURE"),
    5: .same(proto: "RT_MODE_FATIGUE_MEASURE"),
    6: .same(proto: "RT_MODE_PRESSURE_MEASURE"),
    7: .same(proto: "RT_VIEW_MEASURE_STATE"),
  ]
}

extension RtKeyEvent: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RT_KEY_CAMERA"),
    1: .same(proto: "RT_KEY_AUDIO_PLAY"),
    2: .same(proto: "RT_KEY_AUDIO_PRE"),
    3: .same(proto: "RT_KEY_AUDIO_NEXT"),
    4: .same(proto: "RT_KEY_AUDIO_VOLUME_UP"),
    5: .same(proto: "RT_KEY_AUDIO_VOLUME_DOWN"),
    6: .same(proto: "RT_START_FIND_PHONE"),
    7: .same(proto: "RT_STOP_FIND_DEVICE"),
    8: .same(proto: "RT_LN_HEALTH_MEASURE"),
    9: .same(proto: "RT_NONE_MEASURE"),
  ]
}

extension RtSync: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STOP_ALL"),
    1: .same(proto: "ONLY_ONCE"),
    2: .same(proto: "ON_VALUE_CHANGE"),
    3: .same(proto: "ON_SECOND_CHANGE"),
    4: .same(proto: "ON_MINUTE_CHANGE"),
    5: .same(proto: "ON_HOUR_CHANGE"),
    6: .same(proto: "ON_DAY_CHANGE"),
    7: .same(proto: "ON_TEN_MINUTE_CHANGE"),
  ]
}

extension SensorType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NONE"),
    1: .same(proto: "ECG"),
    2: .same(proto: "PPG"),
    4: .same(proto: "MAG"),
    8: .same(proto: "GYRO"),
    16: .same(proto: "ACC"),
    32: .same(proto: "BP"),
    64: .same(proto: "BPRESULT"),
    128: .same(proto: "TEMPERATURE"),
    256: .same(proto: "TWO_ECG"),
    512: .same(proto: "BIOZ"),
    1024: .same(proto: "ECG_DETECT"),
    2048: .same(proto: "FACTORY_ECG"),
    4096: .same(proto: "FACTORY_BIOZ"),
    8192: .same(proto: "HR_LEAK"),
    16384: .same(proto: "BP_LEAK"),
    32768: .same(proto: "SPO2"),
    65536: .same(proto: "OAQ"),
    131072: .same(proto: "IAQ"),
    262144: .same(proto: "HUMITURE"),
    524288: .same(proto: "ULTRASONIC"),
  ]
}

extension SensorOperation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SENSOR_START_SYNC"),
    1: .same(proto: "SENSOR_PAUSE_SYNC"),
    2: .same(proto: "SENSOR_STOP_SYNC"),
  ]
}

extension RtTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RtTime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seconds"),
  ]

  public var isInitialized: Bool {
    if self._seconds == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._seconds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._seconds {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RtTime, rhs: RtTime) -> Bool {
    if lhs._seconds != rhs._seconds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DateTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DateTime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "date_time"),
    2: .standard(proto: "time_zone"),
  ]

  public var isInitialized: Bool {
    if self._dateTime == nil {return false}
    if self._timeZone == nil {return false}
    if let v = self._dateTime, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._dateTime) }()
      case 2: try { try decoder.decodeSingularSFixed32Field(value: &self._timeZone) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._dateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._timeZone {
      try visitor.visitSingularSFixed32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DateTime, rhs: DateTime) -> Bool {
    if lhs._dateTime != rhs._dateTime {return false}
    if lhs._timeZone != rhs._timeZone {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RtBattery: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RtBattery"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "level"),
    2: .same(proto: "charging"),
  ]

  public var isInitialized: Bool {
    if self._level == nil {return false}
    if self._charging == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._level) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._charging) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._level {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._charging {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RtBattery, rhs: RtBattery) -> Bool {
    if lhs._level != rhs._level {return false}
    if lhs._charging != rhs._charging {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RtHealth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RtHealth"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "steps"),
    2: .same(proto: "distance"),
    3: .same(proto: "calorie"),
  ]

  public var isInitialized: Bool {
    if self._steps == nil {return false}
    if self._distance == nil {return false}
    if self._calorie == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._steps) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._distance) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._calorie) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._steps {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._distance {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._calorie {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RtHealth, rhs: RtHealth) -> Bool {
    if lhs._steps != rhs._steps {return false}
    if lhs._distance != rhs._distance {return false}
    if lhs._calorie != rhs._calorie {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BPresult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BPresult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sbp"),
    2: .same(proto: "dbp"),
  ]

  public var isInitialized: Bool {
    if self._sbp == nil {return false}
    if self._dbp == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._sbp) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._dbp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sbp {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._dbp {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BPresult, rhs: BPresult) -> Bool {
    if lhs._sbp != rhs._sbp {return false}
    if lhs._dbp != rhs._dbp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RtHealthResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RtHealthResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fatigue"),
    2: .same(proto: "stress"),
    3: .same(proto: "spo2"),
    4: .same(proto: "hr"),
    5: .same(proto: "bp"),
    6: .same(proto: "breathrate"),
    7: .same(proto: "temperatur"),
  ]

  public var isInitialized: Bool {
    if let v = self._bp, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._fatigue) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._stress) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._spo2) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._hr) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._bp) }()
      case 6: try { try decoder.decodeSingularFixed32Field(value: &self._breathrate) }()
      case 7: try { try decoder.decodeSingularFixed32Field(value: &self._temperatur) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fatigue {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._stress {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._spo2 {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._hr {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._bp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._breathrate {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._temperatur {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RtHealthResult, rhs: RtHealthResult) -> Bool {
    if lhs._fatigue != rhs._fatigue {return false}
    if lhs._stress != rhs._stress {return false}
    if lhs._spo2 != rhs._spo2 {return false}
    if lhs._hr != rhs._hr {return false}
    if lhs._bp != rhs._bp {return false}
    if lhs._breathrate != rhs._breathrate {return false}
    if lhs._temperatur != rhs._temperatur {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RtGNSS: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RtGNSS"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "longitude"),
    2: .same(proto: "latitude"),
    3: .same(proto: "speed"),
    4: .same(proto: "altitude"),
  ]

  public var isInitialized: Bool {
    if self._longitude == nil {return false}
    if self._latitude == nil {return false}
    if self._speed == nil {return false}
    if self._altitude == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._longitude) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._latitude) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._speed) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._altitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._longitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._latitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._speed {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._altitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RtGNSS, rhs: RtGNSS) -> Bool {
    if lhs._longitude != rhs._longitude {return false}
    if lhs._latitude != rhs._latitude {return false}
    if lhs._speed != rhs._speed {return false}
    if lhs._altitude != rhs._altitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RtSensor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RtSensor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
    2: .same(proto: "type"),
  ]

  public var isInitialized: Bool {
    if self._operation == nil {return false}
    if self._type == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._operation) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._operation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RtSensor, rhs: RtSensor) -> Bool {
    if lhs._operation != rhs._operation {return false}
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RtSubscriber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RtSubscriber"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "battery"),
    3: .same(proto: "health"),
    4: .same(proto: "mode"),
    5: .same(proto: "sensor"),
  ]

  public var isInitialized: Bool {
    if let v = self._sensor, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._time) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._battery) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._health) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._mode) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._sensor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._time {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._battery {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._health {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._mode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._sensor {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RtSubscriber, rhs: RtSubscriber) -> Bool {
    if lhs._time != rhs._time {return false}
    if lhs._battery != rhs._battery {return false}
    if lhs._health != rhs._health {return false}
    if lhs._mode != rhs._mode {return false}
    if lhs._sensor != rhs._sensor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RtData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RtData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "battery"),
    3: .same(proto: "health"),
    4: .same(proto: "key"),
    5: .standard(proto: "time_zone"),
    6: .same(proto: "healthresult"),
  ]

  public var isInitialized: Bool {
    if let v = self._time, !v.isInitialized {return false}
    if let v = self._battery, !v.isInitialized {return false}
    if let v = self._health, !v.isInitialized {return false}
    if let v = self._healthresult, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._battery) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._health) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._key) }()
      case 5: try { try decoder.decodeSingularSFixed32Field(value: &self._timeZone) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._healthresult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._battery {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._health {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._key {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._timeZone {
      try visitor.visitSingularSFixed32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._healthresult {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RtData, rhs: RtData) -> Bool {
    if lhs._time != rhs._time {return false}
    if lhs._battery != rhs._battery {return false}
    if lhs._health != rhs._health {return false}
    if lhs._key != rhs._key {return false}
    if lhs._timeZone != rhs._timeZone {return false}
    if lhs._healthresult != rhs._healthresult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RtState: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RtState"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .same(proto: "battery"),
    3: .same(proto: "health"),
    4: .same(proto: "mode"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._time) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._battery) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._health) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._mode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._time {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._battery {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._health {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._mode {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RtState, rhs: RtState) -> Bool {
    if lhs._time != rhs._time {return false}
    if lhs._battery != rhs._battery {return false}
    if lhs._health != rhs._health {return false}
    if lhs._mode != rhs._mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RtSensorData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RtSensorData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "time"),
    3: .same(proto: "seq"),
    4: .same(proto: "data"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if self._time == nil {return false}
    if self._seq == nil {return false}
    if let v = self._time, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._seq) }()
      case 4: try { try decoder.decodeRepeatedFixed32Field(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._seq {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    if !self.data.isEmpty {
      try visitor.visitRepeatedFixed32Field(value: self.data, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RtSensorData, rhs: RtSensorData) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._time != rhs._time {return false}
    if lhs._seq != rhs._seq {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RtNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RtNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "rt_data"),
    2: .standard(proto: "rt_state"),
    3: .standard(proto: "rt_sensordata"),
  ]

  public var isInitialized: Bool {
    if let v = self.data, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: RtData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .rtData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .rtData(v)
        }
      }()
      case 2: try {
        var v: RtState?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .rtState(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .rtState(v)
        }
      }()
      case 3: try {
        var v: RtSensorData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .rtSensordata(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .rtSensordata(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.data {
    case .rtData?: try {
      guard case .rtData(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .rtState?: try {
      guard case .rtState(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .rtSensordata?: try {
      guard case .rtSensordata(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RtNotification, rhs: RtNotification) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
