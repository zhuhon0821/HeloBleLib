// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: peer_info.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct PeerInfoSubsriber {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var supportPeerType: Bool {
    get {return _storage._supportPeerType ?? false}
    set {_uniqueStorage()._supportPeerType = newValue}
  }
  /// Returns true if `supportPeerType` has been explicitly set.
  var hasSupportPeerType: Bool {return _storage._supportPeerType != nil}
  /// Clears the value of `supportPeerType`. Subsequent reads from it will return its default value.
  mutating func clearSupportPeerType() {_uniqueStorage()._supportPeerType = nil}

  var supportPeerStatus: Bool {
    get {return _storage._supportPeerStatus ?? false}
    set {_uniqueStorage()._supportPeerStatus = newValue}
  }
  /// Returns true if `supportPeerStatus` has been explicitly set.
  var hasSupportPeerStatus: Bool {return _storage._supportPeerStatus != nil}
  /// Clears the value of `supportPeerStatus`. Subsequent reads from it will return its default value.
  mutating func clearSupportPeerStatus() {_uniqueStorage()._supportPeerStatus = nil}

  var supportDateTime: Bool {
    get {return _storage._supportDateTime ?? false}
    set {_uniqueStorage()._supportDateTime = newValue}
  }
  /// Returns true if `supportDateTime` has been explicitly set.
  var hasSupportDateTime: Bool {return _storage._supportDateTime != nil}
  /// Clears the value of `supportDateTime`. Subsequent reads from it will return its default value.
  mutating func clearSupportDateTime() {_uniqueStorage()._supportDateTime = nil}

  var supportGnssConf: Bool {
    get {return _storage._supportGnssConf ?? false}
    set {_uniqueStorage()._supportGnssConf = newValue}
  }
  /// Returns true if `supportGnssConf` has been explicitly set.
  var hasSupportGnssConf: Bool {return _storage._supportGnssConf != nil}
  /// Clears the value of `supportGnssConf`. Subsequent reads from it will return its default value.
  mutating func clearSupportGnssConf() {_uniqueStorage()._supportGnssConf = nil}

  var supportHrAlarmConf: Bool {
    get {return _storage._supportHrAlarmConf ?? false}
    set {_uniqueStorage()._supportHrAlarmConf = newValue}
  }
  /// Returns true if `supportHrAlarmConf` has been explicitly set.
  var hasSupportHrAlarmConf: Bool {return _storage._supportHrAlarmConf != nil}
  /// Clears the value of `supportHrAlarmConf`. Subsequent reads from it will return its default value.
  mutating func clearSupportHrAlarmConf() {_uniqueStorage()._supportHrAlarmConf = nil}

  var supportUserConf: Bool {
    get {return _storage._supportUserConf ?? false}
    set {_uniqueStorage()._supportUserConf = newValue}
  }
  /// Returns true if `supportUserConf` has been explicitly set.
  var hasSupportUserConf: Bool {return _storage._supportUserConf != nil}
  /// Clears the value of `supportUserConf`. Subsequent reads from it will return its default value.
  mutating func clearSupportUserConf() {_uniqueStorage()._supportUserConf = nil}

  var supportGoalConf: Bool {
    get {return _storage._supportGoalConf ?? false}
    set {_uniqueStorage()._supportGoalConf = newValue}
  }
  /// Returns true if `supportGoalConf` has been explicitly set.
  var hasSupportGoalConf: Bool {return _storage._supportGoalConf != nil}
  /// Clears the value of `supportGoalConf`. Subsequent reads from it will return its default value.
  mutating func clearSupportGoalConf() {_uniqueStorage()._supportGoalConf = nil}

  var supportFemalHealthConf: Bool {
    get {return _storage._supportFemalHealthConf ?? false}
    set {_uniqueStorage()._supportFemalHealthConf = newValue}
  }
  /// Returns true if `supportFemalHealthConf` has been explicitly set.
  var hasSupportFemalHealthConf: Bool {return _storage._supportFemalHealthConf != nil}
  /// Clears the value of `supportFemalHealthConf`. Subsequent reads from it will return its default value.
  mutating func clearSupportFemalHealthConf() {_uniqueStorage()._supportFemalHealthConf = nil}

  var hashGnssConf: UInt32 {
    get {return _storage._hashGnssConf ?? 0}
    set {_uniqueStorage()._hashGnssConf = newValue}
  }
  /// Returns true if `hashGnssConf` has been explicitly set.
  var hasHashGnssConf: Bool {return _storage._hashGnssConf != nil}
  /// Clears the value of `hashGnssConf`. Subsequent reads from it will return its default value.
  mutating func clearHashGnssConf() {_uniqueStorage()._hashGnssConf = nil}

  var hashHrAlarmConf: UInt32 {
    get {return _storage._hashHrAlarmConf ?? 0}
    set {_uniqueStorage()._hashHrAlarmConf = newValue}
  }
  /// Returns true if `hashHrAlarmConf` has been explicitly set.
  var hasHashHrAlarmConf: Bool {return _storage._hashHrAlarmConf != nil}
  /// Clears the value of `hashHrAlarmConf`. Subsequent reads from it will return its default value.
  mutating func clearHashHrAlarmConf() {_uniqueStorage()._hashHrAlarmConf = nil}

  var hashUserConf: UInt32 {
    get {return _storage._hashUserConf ?? 0}
    set {_uniqueStorage()._hashUserConf = newValue}
  }
  /// Returns true if `hashUserConf` has been explicitly set.
  var hasHashUserConf: Bool {return _storage._hashUserConf != nil}
  /// Clears the value of `hashUserConf`. Subsequent reads from it will return its default value.
  mutating func clearHashUserConf() {_uniqueStorage()._hashUserConf = nil}

  var hashGoalConf: UInt32 {
    get {return _storage._hashGoalConf ?? 0}
    set {_uniqueStorage()._hashGoalConf = newValue}
  }
  /// Returns true if `hashGoalConf` has been explicitly set.
  var hasHashGoalConf: Bool {return _storage._hashGoalConf != nil}
  /// Clears the value of `hashGoalConf`. Subsequent reads from it will return its default value.
  mutating func clearHashGoalConf() {_uniqueStorage()._hashGoalConf = nil}

  var supportBpcaliConf: Bool {
    get {return _storage._supportBpcaliConf ?? false}
    set {_uniqueStorage()._supportBpcaliConf = newValue}
  }
  /// Returns true if `supportBpcaliConf` has been explicitly set.
  var hasSupportBpcaliConf: Bool {return _storage._supportBpcaliConf != nil}
  /// Clears the value of `supportBpcaliConf`. Subsequent reads from it will return its default value.
  mutating func clearSupportBpcaliConf() {_uniqueStorage()._supportBpcaliConf = nil}

  var hashBpcaliConf: Bool {
    get {return _storage._hashBpcaliConf ?? false}
    set {_uniqueStorage()._hashBpcaliConf = newValue}
  }
  /// Returns true if `hashBpcaliConf` has been explicitly set.
  var hasHashBpcaliConf: Bool {return _storage._hashBpcaliConf != nil}
  /// Clears the value of `hashBpcaliConf`. Subsequent reads from it will return its default value.
  mutating func clearHashBpcaliConf() {_uniqueStorage()._hashBpcaliConf = nil}

  var supportAfConf: Bool {
    get {return _storage._supportAfConf ?? false}
    set {_uniqueStorage()._supportAfConf = newValue}
  }
  /// Returns true if `supportAfConf` has been explicitly set.
  var hasSupportAfConf: Bool {return _storage._supportAfConf != nil}
  /// Clears the value of `supportAfConf`. Subsequent reads from it will return its default value.
  mutating func clearSupportAfConf() {_uniqueStorage()._supportAfConf = nil}

  var hashAfConf: UInt32 {
    get {return _storage._hashAfConf ?? 0}
    set {_uniqueStorage()._hashAfConf = newValue}
  }
  /// Returns true if `hashAfConf` has been explicitly set.
  var hasHashAfConf: Bool {return _storage._hashAfConf != nil}
  /// Clears the value of `hashAfConf`. Subsequent reads from it will return its default value.
  mutating func clearHashAfConf() {_uniqueStorage()._hashAfConf = nil}

  var hashFemalHealthConf: Bool {
    get {return _storage._hashFemalHealthConf ?? false}
    set {_uniqueStorage()._hashFemalHealthConf = newValue}
  }
  /// Returns true if `hashFemalHealthConf` has been explicitly set.
  var hasHashFemalHealthConf: Bool {return _storage._hashFemalHealthConf != nil}
  /// Clears the value of `hashFemalHealthConf`. Subsequent reads from it will return its default value.
  mutating func clearHashFemalHealthConf() {_uniqueStorage()._hashFemalHealthConf = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct UserConf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: UInt32 {
    get {return _hash ?? 0}
    set {_hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  var hasHash: Bool {return self._hash != nil}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  mutating func clearHash() {self._hash = nil}

  /// cm, default: 170
  var height: UInt32 {
    get {return _height ?? 170}
    set {_height = newValue}
  }
  /// Returns true if `height` has been explicitly set.
  var hasHeight: Bool {return self._height != nil}
  /// Clears the value of `height`. Subsequent reads from it will return its default value.
  mutating func clearHeight() {self._height = nil}

  /// kg, default: 60
  var weight: UInt32 {
    get {return _weight ?? 60}
    set {_weight = newValue}
  }
  /// Returns true if `weight` has been explicitly set.
  var hasWeight: Bool {return self._weight != nil}
  /// Clears the value of `weight`. Subsequent reads from it will return its default value.
  mutating func clearWeight() {self._weight = nil}

  /// 0[default]: male, 1: female
  var gender: Bool {
    get {return _gender ?? false}
    set {_gender = newValue}
  }
  /// Returns true if `gender` has been explicitly set.
  var hasGender: Bool {return self._gender != nil}
  /// Clears the value of `gender`. Subsequent reads from it will return its default value.
  mutating func clearGender() {self._gender = nil}

  /// 20
  var age: UInt32 {
    get {return _age ?? 20}
    set {_age = newValue}
  }
  /// Returns true if `age` has been explicitly set.
  var hasAge: Bool {return self._age != nil}
  /// Clears the value of `age`. Subsequent reads from it will return its default value.
  mutating func clearAge() {self._age = nil}

  /// 50~200, calibrate value of walking
  var calibWalk: UInt32 {
    get {return _calibWalk ?? 100}
    set {_calibWalk = newValue}
  }
  /// Returns true if `calibWalk` has been explicitly set.
  var hasCalibWalk: Bool {return self._calibWalk != nil}
  /// Clears the value of `calibWalk`. Subsequent reads from it will return its default value.
  mutating func clearCalibWalk() {self._calibWalk = nil}

  /// 50~200, calibrate value of running
  var calibRun: UInt32 {
    get {return _calibRun ?? 100}
    set {_calibRun = newValue}
  }
  /// Returns true if `calibRun` has been explicitly set.
  var hasCalibRun: Bool {return self._calibRun != nil}
  /// Clears the value of `calibRun`. Subsequent reads from it will return its default value.
  mutating func clearCalibRun() {self._calibRun = nil}

  var grade: UInt32 {
    get {return _grade ?? 0}
    set {_grade = newValue}
  }
  /// Returns true if `grade` has been explicitly set.
  var hasGrade: Bool {return self._grade != nil}
  /// Clears the value of `grade`. Subsequent reads from it will return its default value.
  mutating func clearGrade() {self._grade = nil}

  /// 80~230mm, Wrist circumference
  var wristCircumference: UInt32 {
    get {return _wristCircumference ?? 0}
    set {_wristCircumference = newValue}
  }
  /// Returns true if `wristCircumference` has been explicitly set.
  var hasWristCircumference: Bool {return self._wristCircumference != nil}
  /// Clears the value of `wristCircumference`. Subsequent reads from it will return its default value.
  mutating func clearWristCircumference() {self._wristCircumference = nil}

  /// 0: no, 1: Yes
  var historyOfHypertension: Bool {
    get {return _historyOfHypertension ?? false}
    set {_historyOfHypertension = newValue}
  }
  /// Returns true if `historyOfHypertension` has been explicitly set.
  var hasHistoryOfHypertension: Bool {return self._historyOfHypertension != nil}
  /// Clears the value of `historyOfHypertension`. Subsequent reads from it will return its default value.
  mutating func clearHistoryOfHypertension() {self._historyOfHypertension = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hash: UInt32? = nil
  fileprivate var _height: UInt32? = nil
  fileprivate var _weight: UInt32? = nil
  fileprivate var _gender: Bool? = nil
  fileprivate var _age: UInt32? = nil
  fileprivate var _calibWalk: UInt32? = nil
  fileprivate var _calibRun: UInt32? = nil
  fileprivate var _grade: UInt32? = nil
  fileprivate var _wristCircumference: UInt32? = nil
  fileprivate var _historyOfHypertension: Bool? = nil
}

struct GoalConf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: UInt32 {
    get {return _hash ?? 0}
    set {_hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  var hasHash: Bool {return self._hash != nil}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  mutating func clearHash() {self._hash = nil}

  /// meters
  var distance: UInt32 {
    get {return _distance ?? 10000}
    set {_distance = newValue}
  }
  /// Returns true if `distance` has been explicitly set.
  var hasDistance: Bool {return self._distance != nil}
  /// Clears the value of `distance`. Subsequent reads from it will return its default value.
  mutating func clearDistance() {self._distance = nil}

  /// seconds
  var step: UInt32 {
    get {return _step ?? 10000}
    set {_step = newValue}
  }
  /// Returns true if `step` has been explicitly set.
  var hasStep: Bool {return self._step != nil}
  /// Clears the value of `step`. Subsequent reads from it will return its default value.
  mutating func clearStep() {self._step = nil}

  /// kC
  var calorie: UInt32 {
    get {return _calorie ?? 400}
    set {_calorie = newValue}
  }
  /// Returns true if `calorie` has been explicitly set.
  var hasCalorie: Bool {return self._calorie != nil}
  /// Clears the value of `calorie`. Subsequent reads from it will return its default value.
  mutating func clearCalorie() {self._calorie = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hash: UInt32? = nil
  fileprivate var _distance: UInt32? = nil
  fileprivate var _step: UInt32? = nil
  fileprivate var _calorie: UInt32? = nil
}

struct HrAlarmConf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: UInt32 {
    get {return _hash ?? 0}
    set {_hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  var hasHash: Bool {return self._hash != nil}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  mutating func clearHash() {self._hash = nil}

  /// 0[default]: disable, 1: enable
  var enable: Bool {
    get {return _enable ?? false}
    set {_enable = newValue}
  }
  /// Returns true if `enable` has been explicitly set.
  var hasEnable: Bool {return self._enable != nil}
  /// Clears the value of `enable`. Subsequent reads from it will return its default value.
  mutating func clearEnable() {self._enable = nil}

  /// 50~200, when hr value goes beyond [ths_low, ths_high], (re-)start counter
  var thsHigh: UInt32 {
    get {return _thsHigh ?? 160}
    set {_thsHigh = newValue}
  }
  /// Returns true if `thsHigh` has been explicitly set.
  var hasThsHigh: Bool {return self._thsHigh != nil}
  /// Clears the value of `thsHigh`. Subsequent reads from it will return its default value.
  mutating func clearThsHigh() {self._thsHigh = nil}

  /// 40~190
  var thsLow: UInt32 {
    get {return _thsLow ?? 50}
    set {_thsLow = newValue}
  }
  /// Returns true if `thsLow` has been explicitly set.
  var hasThsLow: Bool {return self._thsLow != nil}
  /// Clears the value of `thsLow`. Subsequent reads from it will return its default value.
  mutating func clearThsLow() {self._thsLow = nil}

  /// seconds, trigger alarm when couter reaches this value
  var timeout: UInt32 {
    get {return _timeout ?? 30}
    set {_timeout = newValue}
  }
  /// Returns true if `timeout` has been explicitly set.
  var hasTimeout: Bool {return self._timeout != nil}
  /// Clears the value of `timeout`. Subsequent reads from it will return its default value.
  mutating func clearTimeout() {self._timeout = nil}

  /// minutes, re-alarm interval
  var interval: UInt32 {
    get {return _interval ?? 2}
    set {_interval = newValue}
  }
  /// Returns true if `interval` has been explicitly set.
  var hasInterval: Bool {return self._interval != nil}
  /// Clears the value of `interval`. Subsequent reads from it will return its default value.
  mutating func clearInterval() {self._interval = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hash: UInt32? = nil
  fileprivate var _enable: Bool? = nil
  fileprivate var _thsHigh: UInt32? = nil
  fileprivate var _thsLow: UInt32? = nil
  fileprivate var _timeout: UInt32? = nil
  fileprivate var _interval: UInt32? = nil
}

struct spo2AlarmConfv2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: UInt32 {
    get {return _hash ?? 0}
    set {_hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  var hasHash: Bool {return self._hash != nil}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  mutating func clearHash() {self._hash = nil}

  /// 0[default]: disable, 1: enable
  var enable: Bool {
    get {return _enable ?? false}
    set {_enable = newValue}
  }
  /// Returns true if `enable` has been explicitly set.
  var hasEnable: Bool {return self._enable != nil}
  /// Clears the value of `enable`. Subsequent reads from it will return its default value.
  mutating func clearEnable() {self._enable = nil}

  var thsLow: UInt32 {
    get {return _thsLow ?? 90}
    set {_thsLow = newValue}
  }
  /// Returns true if `thsLow` has been explicitly set.
  var hasThsLow: Bool {return self._thsLow != nil}
  /// Clears the value of `thsLow`. Subsequent reads from it will return its default value.
  mutating func clearThsLow() {self._thsLow = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hash: UInt32? = nil
  fileprivate var _enable: Bool? = nil
  fileprivate var _thsLow: UInt32? = nil
}

struct BpCustomConf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sbpHigh: UInt32 {
    get {return _sbpHigh ?? 0}
    set {_sbpHigh = newValue}
  }
  /// Returns true if `sbpHigh` has been explicitly set.
  var hasSbpHigh: Bool {return self._sbpHigh != nil}
  /// Clears the value of `sbpHigh`. Subsequent reads from it will return its default value.
  mutating func clearSbpHigh() {self._sbpHigh = nil}

  var sbpBelow: UInt32 {
    get {return _sbpBelow ?? 0}
    set {_sbpBelow = newValue}
  }
  /// Returns true if `sbpBelow` has been explicitly set.
  var hasSbpBelow: Bool {return self._sbpBelow != nil}
  /// Clears the value of `sbpBelow`. Subsequent reads from it will return its default value.
  mutating func clearSbpBelow() {self._sbpBelow = nil}

  var dbpHigh: UInt32 {
    get {return _dbpHigh ?? 0}
    set {_dbpHigh = newValue}
  }
  /// Returns true if `dbpHigh` has been explicitly set.
  var hasDbpHigh: Bool {return self._dbpHigh != nil}
  /// Clears the value of `dbpHigh`. Subsequent reads from it will return its default value.
  mutating func clearDbpHigh() {self._dbpHigh = nil}

  var dbpBelow: UInt32 {
    get {return _dbpBelow ?? 0}
    set {_dbpBelow = newValue}
  }
  /// Returns true if `dbpBelow` has been explicitly set.
  var hasDbpBelow: Bool {return self._dbpBelow != nil}
  /// Clears the value of `dbpBelow`. Subsequent reads from it will return its default value.
  mutating func clearDbpBelow() {self._dbpBelow = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sbpHigh: UInt32? = nil
  fileprivate var _sbpBelow: UInt32? = nil
  fileprivate var _dbpHigh: UInt32? = nil
  fileprivate var _dbpBelow: UInt32? = nil
}

struct BpAlarmCustomConf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 0[default]: disable, 1: enable
  var enable: Bool {
    get {return _enable ?? false}
    set {_enable = newValue}
  }
  /// Returns true if `enable` has been explicitly set.
  var hasEnable: Bool {return self._enable != nil}
  /// Clears the value of `enable`. Subsequent reads from it will return its default value.
  mutating func clearEnable() {self._enable = nil}

  var customConf: [BpCustomConf] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _enable: Bool? = nil
}

struct BpAlarmConfv2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 0[default]: disable, 1: enable
  var enable: Bool {
    get {return _enable ?? false}
    set {_enable = newValue}
  }
  /// Returns true if `enable` has been explicitly set.
  var hasEnable: Bool {return self._enable != nil}
  /// Clears the value of `enable`. Subsequent reads from it will return its default value.
  mutating func clearEnable() {self._enable = nil}

  var sbpHigh: UInt32 {
    get {return _sbpHigh ?? 0}
    set {_sbpHigh = newValue}
  }
  /// Returns true if `sbpHigh` has been explicitly set.
  var hasSbpHigh: Bool {return self._sbpHigh != nil}
  /// Clears the value of `sbpHigh`. Subsequent reads from it will return its default value.
  mutating func clearSbpHigh() {self._sbpHigh = nil}

  var sbpBelow: UInt32 {
    get {return _sbpBelow ?? 0}
    set {_sbpBelow = newValue}
  }
  /// Returns true if `sbpBelow` has been explicitly set.
  var hasSbpBelow: Bool {return self._sbpBelow != nil}
  /// Clears the value of `sbpBelow`. Subsequent reads from it will return its default value.
  mutating func clearSbpBelow() {self._sbpBelow = nil}

  var dbpHigh: UInt32 {
    get {return _dbpHigh ?? 0}
    set {_dbpHigh = newValue}
  }
  /// Returns true if `dbpHigh` has been explicitly set.
  var hasDbpHigh: Bool {return self._dbpHigh != nil}
  /// Clears the value of `dbpHigh`. Subsequent reads from it will return its default value.
  mutating func clearDbpHigh() {self._dbpHigh = nil}

  var dbpBelow: UInt32 {
    get {return _dbpBelow ?? 0}
    set {_dbpBelow = newValue}
  }
  /// Returns true if `dbpBelow` has been explicitly set.
  var hasDbpBelow: Bool {return self._dbpBelow != nil}
  /// Clears the value of `dbpBelow`. Subsequent reads from it will return its default value.
  mutating func clearDbpBelow() {self._dbpBelow = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _enable: Bool? = nil
  fileprivate var _sbpHigh: UInt32? = nil
  fileprivate var _sbpBelow: UInt32? = nil
  fileprivate var _dbpHigh: UInt32? = nil
  fileprivate var _dbpBelow: UInt32? = nil
}

struct TemperatureAlarmConfv2 {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 0[default]: disable, 1: enable
  var enable: Bool {
    get {return _enable ?? false}
    set {_enable = newValue}
  }
  /// Returns true if `enable` has been explicitly set.
  var hasEnable: Bool {return self._enable != nil}
  /// Clears the value of `enable`. Subsequent reads from it will return its default value.
  mutating func clearEnable() {self._enable = nil}

  var tempHigh: UInt32 {
    get {return _tempHigh ?? 0}
    set {_tempHigh = newValue}
  }
  /// Returns true if `tempHigh` has been explicitly set.
  var hasTempHigh: Bool {return self._tempHigh != nil}
  /// Clears the value of `tempHigh`. Subsequent reads from it will return its default value.
  mutating func clearTempHigh() {self._tempHigh = nil}

  var tempBelow: UInt32 {
    get {return _tempBelow ?? 0}
    set {_tempBelow = newValue}
  }
  /// Returns true if `tempBelow` has been explicitly set.
  var hasTempBelow: Bool {return self._tempBelow != nil}
  /// Clears the value of `tempBelow`. Subsequent reads from it will return its default value.
  mutating func clearTempBelow() {self._tempBelow = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _enable: Bool? = nil
  fileprivate var _tempHigh: UInt32? = nil
  fileprivate var _tempBelow: UInt32? = nil
}

struct GnssConf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: UInt32 {
    get {return _hash ?? 0}
    set {_hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  var hasHash: Bool {return self._hash != nil}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  mutating func clearHash() {self._hash = nil}

  var altitude: Float {
    get {return _altitude ?? 0}
    set {_altitude = newValue}
  }
  /// Returns true if `altitude` has been explicitly set.
  var hasAltitude: Bool {return self._altitude != nil}
  /// Clears the value of `altitude`. Subsequent reads from it will return its default value.
  mutating func clearAltitude() {self._altitude = nil}

  var latitude: Float {
    get {return _latitude ?? 0}
    set {_latitude = newValue}
  }
  /// Returns true if `latitude` has been explicitly set.
  var hasLatitude: Bool {return self._latitude != nil}
  /// Clears the value of `latitude`. Subsequent reads from it will return its default value.
  mutating func clearLatitude() {self._latitude = nil}

  var longitude: Float {
    get {return _longitude ?? 0}
    set {_longitude = newValue}
  }
  /// Returns true if `longitude` has been explicitly set.
  var hasLongitude: Bool {return self._longitude != nil}
  /// Clears the value of `longitude`. Subsequent reads from it will return its default value.
  mutating func clearLongitude() {self._longitude = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hash: UInt32? = nil
  fileprivate var _altitude: Float? = nil
  fileprivate var _latitude: Float? = nil
  fileprivate var _longitude: Float? = nil
}

struct BpCaliConf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: UInt32 {
    get {return _hash ?? 0}
    set {_hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  var hasHash: Bool {return self._hash != nil}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  mutating func clearHash() {self._hash = nil}

  var srcSbp: UInt32 {
    get {return _srcSbp ?? 0}
    set {_srcSbp = newValue}
  }
  /// Returns true if `srcSbp` has been explicitly set.
  var hasSrcSbp: Bool {return self._srcSbp != nil}
  /// Clears the value of `srcSbp`. Subsequent reads from it will return its default value.
  mutating func clearSrcSbp() {self._srcSbp = nil}

  var srcDbp: UInt32 {
    get {return _srcDbp ?? 0}
    set {_srcDbp = newValue}
  }
  /// Returns true if `srcDbp` has been explicitly set.
  var hasSrcDbp: Bool {return self._srcDbp != nil}
  /// Clears the value of `srcDbp`. Subsequent reads from it will return its default value.
  mutating func clearSrcDbp() {self._srcDbp = nil}

  var dstSbp: UInt32 {
    get {return _dstSbp ?? 0}
    set {_dstSbp = newValue}
  }
  /// Returns true if `dstSbp` has been explicitly set.
  var hasDstSbp: Bool {return self._dstSbp != nil}
  /// Clears the value of `dstSbp`. Subsequent reads from it will return its default value.
  mutating func clearDstSbp() {self._dstSbp = nil}

  var dstDbp: UInt32 {
    get {return _dstDbp ?? 0}
    set {_dstDbp = newValue}
  }
  /// Returns true if `dstDbp` has been explicitly set.
  var hasDstDbp: Bool {return self._dstDbp != nil}
  /// Clears the value of `dstDbp`. Subsequent reads from it will return its default value.
  mutating func clearDstDbp() {self._dstDbp = nil}

  var difSbp: Int32 {
    get {return _difSbp ?? 0}
    set {_difSbp = newValue}
  }
  /// Returns true if `difSbp` has been explicitly set.
  var hasDifSbp: Bool {return self._difSbp != nil}
  /// Clears the value of `difSbp`. Subsequent reads from it will return its default value.
  mutating func clearDifSbp() {self._difSbp = nil}

  var difDbp: Int32 {
    get {return _difDbp ?? 0}
    set {_difDbp = newValue}
  }
  /// Returns true if `difDbp` has been explicitly set.
  var hasDifDbp: Bool {return self._difDbp != nil}
  /// Clears the value of `difDbp`. Subsequent reads from it will return its default value.
  mutating func clearDifDbp() {self._difDbp = nil}

  var userName: String {
    get {return _userName ?? String()}
    set {_userName = newValue}
  }
  /// Returns true if `userName` has been explicitly set.
  var hasUserName: Bool {return self._userName != nil}
  /// Clears the value of `userName`. Subsequent reads from it will return its default value.
  mutating func clearUserName() {self._userName = nil}

  var takeMedicine: Bool {
    get {return _takeMedicine ?? false}
    set {_takeMedicine = newValue}
  }
  /// Returns true if `takeMedicine` has been explicitly set.
  var hasTakeMedicine: Bool {return self._takeMedicine != nil}
  /// Clears the value of `takeMedicine`. Subsequent reads from it will return its default value.
  mutating func clearTakeMedicine() {self._takeMedicine = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hash: UInt32? = nil
  fileprivate var _srcSbp: UInt32? = nil
  fileprivate var _srcDbp: UInt32? = nil
  fileprivate var _dstSbp: UInt32? = nil
  fileprivate var _dstDbp: UInt32? = nil
  fileprivate var _difSbp: Int32? = nil
  fileprivate var _difDbp: Int32? = nil
  fileprivate var _userName: String? = nil
  fileprivate var _takeMedicine: Bool? = nil
}

struct AfConf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: UInt32 {
    get {return _hash ?? 0}
    set {_hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  var hasHash: Bool {return self._hash != nil}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  mutating func clearHash() {self._hash = nil}

  var autoRun: Bool {
    get {return _autoRun ?? false}
    set {_autoRun = newValue}
  }
  /// Returns true if `autoRun` has been explicitly set.
  var hasAutoRun: Bool {return self._autoRun != nil}
  /// Clears the value of `autoRun`. Subsequent reads from it will return its default value.
  mutating func clearAutoRun() {self._autoRun = nil}

  /// minutes, 0: always run
  var interval: UInt32 {
    get {return _interval ?? 0}
    set {_interval = newValue}
  }
  /// Returns true if `interval` has been explicitly set.
  var hasInterval: Bool {return self._interval != nil}
  /// Clears the value of `interval`. Subsequent reads from it will return its default value.
  mutating func clearInterval() {self._interval = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hash: UInt32? = nil
  fileprivate var _autoRun: Bool? = nil
  fileprivate var _interval: UInt32? = nil
}

struct FemalHealthConf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: UInt32 {
    get {return _hash ?? 0}
    set {_hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  var hasHash: Bool {return self._hash != nil}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  mutating func clearHash() {self._hash = nil}

  /// 0[default]: disable, 1: enable
  var enable: Bool {
    get {return _enable ?? false}
    set {_enable = newValue}
  }
  /// Returns true if `enable` has been explicitly set.
  var hasEnable: Bool {return self._enable != nil}
  /// Clears the value of `enable`. Subsequent reads from it will return its default value.
  mutating func clearEnable() {self._enable = nil}

  ///seconds
  var startTimeMenstruation: RtTime {
    get {return _startTimeMenstruation ?? RtTime()}
    set {_startTimeMenstruation = newValue}
  }
  /// Returns true if `startTimeMenstruation` has been explicitly set.
  var hasStartTimeMenstruation: Bool {return self._startTimeMenstruation != nil}
  /// Clears the value of `startTimeMenstruation`. Subsequent reads from it will return its default value.
  mutating func clearStartTimeMenstruation() {self._startTimeMenstruation = nil}

  /// 17~60
  var cycleLength: UInt32 {
    get {return _cycleLength ?? 0}
    set {_cycleLength = newValue}
  }
  /// Returns true if `cycleLength` has been explicitly set.
  var hasCycleLength: Bool {return self._cycleLength != nil}
  /// Clears the value of `cycleLength`. Subsequent reads from it will return its default value.
  mutating func clearCycleLength() {self._cycleLength = nil}

  var daysAdvanceMenstruation: UInt32 {
    get {return _daysAdvanceMenstruation ?? 3}
    set {_daysAdvanceMenstruation = newValue}
  }
  /// Returns true if `daysAdvanceMenstruation` has been explicitly set.
  var hasDaysAdvanceMenstruation: Bool {return self._daysAdvanceMenstruation != nil}
  /// Clears the value of `daysAdvanceMenstruation`. Subsequent reads from it will return its default value.
  mutating func clearDaysAdvanceMenstruation() {self._daysAdvanceMenstruation = nil}

  var daysAdvanceOvulation: UInt32 {
    get {return _daysAdvanceOvulation ?? 3}
    set {_daysAdvanceOvulation = newValue}
  }
  /// Returns true if `daysAdvanceOvulation` has been explicitly set.
  var hasDaysAdvanceOvulation: Bool {return self._daysAdvanceOvulation != nil}
  /// Clears the value of `daysAdvanceOvulation`. Subsequent reads from it will return its default value.
  mutating func clearDaysAdvanceOvulation() {self._daysAdvanceOvulation = nil}

  var alarmMomentHour: UInt32 {
    get {return _alarmMomentHour ?? 20}
    set {_alarmMomentHour = newValue}
  }
  /// Returns true if `alarmMomentHour` has been explicitly set.
  var hasAlarmMomentHour: Bool {return self._alarmMomentHour != nil}
  /// Clears the value of `alarmMomentHour`. Subsequent reads from it will return its default value.
  mutating func clearAlarmMomentHour() {self._alarmMomentHour = nil}

  var alarmMomentMinute: UInt32 {
    get {return _alarmMomentMinute ?? 0}
    set {_alarmMomentMinute = newValue}
  }
  /// Returns true if `alarmMomentMinute` has been explicitly set.
  var hasAlarmMomentMinute: Bool {return self._alarmMomentMinute != nil}
  /// Clears the value of `alarmMomentMinute`. Subsequent reads from it will return its default value.
  mutating func clearAlarmMomentMinute() {self._alarmMomentMinute = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hash: UInt32? = nil
  fileprivate var _enable: Bool? = nil
  fileprivate var _startTimeMenstruation: RtTime? = nil
  fileprivate var _cycleLength: UInt32? = nil
  fileprivate var _daysAdvanceMenstruation: UInt32? = nil
  fileprivate var _daysAdvanceOvulation: UInt32? = nil
  fileprivate var _alarmMomentHour: UInt32? = nil
  fileprivate var _alarmMomentMinute: UInt32? = nil
}

struct PeerInfoNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var peerType: PeerInfoNotification.PeerType {
    get {return _storage._peerType ?? .appAndroid}
    set {_uniqueStorage()._peerType = newValue}
  }
  /// Returns true if `peerType` has been explicitly set.
  var hasPeerType: Bool {return _storage._peerType != nil}
  /// Clears the value of `peerType`. Subsequent reads from it will return its default value.
  mutating func clearPeerType() {_uniqueStorage()._peerType = nil}

  var peerStatus: PeerInfoNotification.PeerStatus {
    get {return _storage._peerStatus ?? .appBackground}
    set {_uniqueStorage()._peerStatus = newValue}
  }
  /// Returns true if `peerStatus` has been explicitly set.
  var hasPeerStatus: Bool {return _storage._peerStatus != nil}
  /// Clears the value of `peerStatus`. Subsequent reads from it will return its default value.
  mutating func clearPeerStatus() {_uniqueStorage()._peerStatus = nil}

  var dateTime: DateTime {
    get {return _storage._dateTime ?? DateTime()}
    set {_uniqueStorage()._dateTime = newValue}
  }
  /// Returns true if `dateTime` has been explicitly set.
  var hasDateTime: Bool {return _storage._dateTime != nil}
  /// Clears the value of `dateTime`. Subsequent reads from it will return its default value.
  mutating func clearDateTime() {_uniqueStorage()._dateTime = nil}

  var gnssConf: GnssConf {
    get {return _storage._gnssConf ?? GnssConf()}
    set {_uniqueStorage()._gnssConf = newValue}
  }
  /// Returns true if `gnssConf` has been explicitly set.
  var hasGnssConf: Bool {return _storage._gnssConf != nil}
  /// Clears the value of `gnssConf`. Subsequent reads from it will return its default value.
  mutating func clearGnssConf() {_uniqueStorage()._gnssConf = nil}

  var hrAlarmConf: HrAlarmConf {
    get {return _storage._hrAlarmConf ?? HrAlarmConf()}
    set {_uniqueStorage()._hrAlarmConf = newValue}
  }
  /// Returns true if `hrAlarmConf` has been explicitly set.
  var hasHrAlarmConf: Bool {return _storage._hrAlarmConf != nil}
  /// Clears the value of `hrAlarmConf`. Subsequent reads from it will return its default value.
  mutating func clearHrAlarmConf() {_uniqueStorage()._hrAlarmConf = nil}

  var userConf: UserConf {
    get {return _storage._userConf ?? UserConf()}
    set {_uniqueStorage()._userConf = newValue}
  }
  /// Returns true if `userConf` has been explicitly set.
  var hasUserConf: Bool {return _storage._userConf != nil}
  /// Clears the value of `userConf`. Subsequent reads from it will return its default value.
  mutating func clearUserConf() {_uniqueStorage()._userConf = nil}

  var goalConf: GoalConf {
    get {return _storage._goalConf ?? GoalConf()}
    set {_uniqueStorage()._goalConf = newValue}
  }
  /// Returns true if `goalConf` has been explicitly set.
  var hasGoalConf: Bool {return _storage._goalConf != nil}
  /// Clears the value of `goalConf`. Subsequent reads from it will return its default value.
  mutating func clearGoalConf() {_uniqueStorage()._goalConf = nil}

  var bpcaliConf: BpCaliConf {
    get {return _storage._bpcaliConf ?? BpCaliConf()}
    set {_uniqueStorage()._bpcaliConf = newValue}
  }
  /// Returns true if `bpcaliConf` has been explicitly set.
  var hasBpcaliConf: Bool {return _storage._bpcaliConf != nil}
  /// Clears the value of `bpcaliConf`. Subsequent reads from it will return its default value.
  mutating func clearBpcaliConf() {_uniqueStorage()._bpcaliConf = nil}

  var afConf: AfConf {
    get {return _storage._afConf ?? AfConf()}
    set {_uniqueStorage()._afConf = newValue}
  }
  /// Returns true if `afConf` has been explicitly set.
  var hasAfConf: Bool {return _storage._afConf != nil}
  /// Clears the value of `afConf`. Subsequent reads from it will return its default value.
  mutating func clearAfConf() {_uniqueStorage()._afConf = nil}

  var connectApp: Bool {
    get {return _storage._connectApp ?? false}
    set {_uniqueStorage()._connectApp = newValue}
  }
  /// Returns true if `connectApp` has been explicitly set.
  var hasConnectApp: Bool {return _storage._connectApp != nil}
  /// Clears the value of `connectApp`. Subsequent reads from it will return its default value.
  mutating func clearConnectApp() {_uniqueStorage()._connectApp = nil}

  var femalHealthConf: FemalHealthConf {
    get {return _storage._femalHealthConf ?? FemalHealthConf()}
    set {_uniqueStorage()._femalHealthConf = newValue}
  }
  /// Returns true if `femalHealthConf` has been explicitly set.
  var hasFemalHealthConf: Bool {return _storage._femalHealthConf != nil}
  /// Clears the value of `femalHealthConf`. Subsequent reads from it will return its default value.
  mutating func clearFemalHealthConf() {_uniqueStorage()._femalHealthConf = nil}

  var fallCheck: Bool {
    get {return _storage._fallCheck ?? false}
    set {_uniqueStorage()._fallCheck = newValue}
  }
  /// Returns true if `fallCheck` has been explicitly set.
  var hasFallCheck: Bool {return _storage._fallCheck != nil}
  /// Clears the value of `fallCheck`. Subsequent reads from it will return its default value.
  mutating func clearFallCheck() {_uniqueStorage()._fallCheck = nil}

  var spo2AlarmConf: spo2AlarmConfv2 {
    get {return _storage._spo2AlarmConf ?? spo2AlarmConfv2()}
    set {_uniqueStorage()._spo2AlarmConf = newValue}
  }
  /// Returns true if `spo2AlarmConf` has been explicitly set.
  var hasSpo2AlarmConf: Bool {return _storage._spo2AlarmConf != nil}
  /// Clears the value of `spo2AlarmConf`. Subsequent reads from it will return its default value.
  mutating func clearSpo2AlarmConf() {_uniqueStorage()._spo2AlarmConf = nil}

  var bpAlarmConf: BpAlarmConfv2 {
    get {return _storage._bpAlarmConf ?? BpAlarmConfv2()}
    set {_uniqueStorage()._bpAlarmConf = newValue}
  }
  /// Returns true if `bpAlarmConf` has been explicitly set.
  var hasBpAlarmConf: Bool {return _storage._bpAlarmConf != nil}
  /// Clears the value of `bpAlarmConf`. Subsequent reads from it will return its default value.
  mutating func clearBpAlarmConf() {_uniqueStorage()._bpAlarmConf = nil}

  var tempAlarmConf: TemperatureAlarmConfv2 {
    get {return _storage._tempAlarmConf ?? TemperatureAlarmConfv2()}
    set {_uniqueStorage()._tempAlarmConf = newValue}
  }
  /// Returns true if `tempAlarmConf` has been explicitly set.
  var hasTempAlarmConf: Bool {return _storage._tempAlarmConf != nil}
  /// Clears the value of `tempAlarmConf`. Subsequent reads from it will return its default value.
  mutating func clearTempAlarmConf() {_uniqueStorage()._tempAlarmConf = nil}

  var bpCustomConf: BpAlarmCustomConf {
    get {return _storage._bpCustomConf ?? BpAlarmCustomConf()}
    set {_uniqueStorage()._bpCustomConf = newValue}
  }
  /// Returns true if `bpCustomConf` has been explicitly set.
  var hasBpCustomConf: Bool {return _storage._bpCustomConf != nil}
  /// Clears the value of `bpCustomConf`. Subsequent reads from it will return its default value.
  mutating func clearBpCustomConf() {_uniqueStorage()._bpCustomConf = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum PeerType: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case appAndroid // = 0
    case appIos // = 1

    init() {
      self = .appAndroid
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .appAndroid
      case 1: self = .appIos
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .appAndroid: return 0
      case .appIos: return 1
      }
    }

  }

  enum PeerStatus: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case appBackground // = 0
    case appForeground // = 1

    init() {
      self = .appBackground
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .appBackground
      case 1: self = .appForeground
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .appBackground: return 0
      case .appForeground: return 1
      }
    }

  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=4.2)

extension PeerInfoNotification.PeerType: CaseIterable {
  // Support synthesized by the compiler.
}

extension PeerInfoNotification.PeerStatus: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

#if swift(>=5.5) && canImport(_Concurrency)
extension PeerInfoSubsriber: @unchecked Sendable {}
extension UserConf: @unchecked Sendable {}
extension GoalConf: @unchecked Sendable {}
extension HrAlarmConf: @unchecked Sendable {}
extension spo2AlarmConfv2: @unchecked Sendable {}
extension BpCustomConf: @unchecked Sendable {}
extension BpAlarmCustomConf: @unchecked Sendable {}
extension BpAlarmConfv2: @unchecked Sendable {}
extension TemperatureAlarmConfv2: @unchecked Sendable {}
extension GnssConf: @unchecked Sendable {}
extension BpCaliConf: @unchecked Sendable {}
extension AfConf: @unchecked Sendable {}
extension FemalHealthConf: @unchecked Sendable {}
extension PeerInfoNotification: @unchecked Sendable {}
extension PeerInfoNotification.PeerType: @unchecked Sendable {}
extension PeerInfoNotification.PeerStatus: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension PeerInfoSubsriber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PeerInfoSubsriber"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "support_peer_type"),
    2: .standard(proto: "support_peer_status"),
    3: .standard(proto: "support_date_time"),
    4: .standard(proto: "support_gnss_conf"),
    5: .standard(proto: "support_hr_alarm_conf"),
    6: .standard(proto: "support_user_conf"),
    7: .standard(proto: "support_goal_conf"),
    8: .standard(proto: "support_femal_health_conf"),
    9: .standard(proto: "hash_gnss_conf"),
    10: .standard(proto: "hash_hr_alarm_conf"),
    11: .standard(proto: "hash_user_conf"),
    12: .standard(proto: "hash_goal_conf"),
    13: .standard(proto: "support_bpcali_conf"),
    14: .standard(proto: "hash_bpcali_conf"),
    15: .standard(proto: "support_af_conf"),
    16: .standard(proto: "hash_af_conf"),
    17: .standard(proto: "hash_femal_health_conf"),
  ]

  fileprivate class _StorageClass {
    var _supportPeerType: Bool? = nil
    var _supportPeerStatus: Bool? = nil
    var _supportDateTime: Bool? = nil
    var _supportGnssConf: Bool? = nil
    var _supportHrAlarmConf: Bool? = nil
    var _supportUserConf: Bool? = nil
    var _supportGoalConf: Bool? = nil
    var _supportFemalHealthConf: Bool? = nil
    var _hashGnssConf: UInt32? = nil
    var _hashHrAlarmConf: UInt32? = nil
    var _hashUserConf: UInt32? = nil
    var _hashGoalConf: UInt32? = nil
    var _supportBpcaliConf: Bool? = nil
    var _hashBpcaliConf: Bool? = nil
    var _supportAfConf: Bool? = nil
    var _hashAfConf: UInt32? = nil
    var _hashFemalHealthConf: Bool? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _supportPeerType = source._supportPeerType
      _supportPeerStatus = source._supportPeerStatus
      _supportDateTime = source._supportDateTime
      _supportGnssConf = source._supportGnssConf
      _supportHrAlarmConf = source._supportHrAlarmConf
      _supportUserConf = source._supportUserConf
      _supportGoalConf = source._supportGoalConf
      _supportFemalHealthConf = source._supportFemalHealthConf
      _hashGnssConf = source._hashGnssConf
      _hashHrAlarmConf = source._hashHrAlarmConf
      _hashUserConf = source._hashUserConf
      _hashGoalConf = source._hashGoalConf
      _supportBpcaliConf = source._supportBpcaliConf
      _hashBpcaliConf = source._hashBpcaliConf
      _supportAfConf = source._supportAfConf
      _hashAfConf = source._hashAfConf
      _hashFemalHealthConf = source._hashFemalHealthConf
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._supportPeerType == nil {return false}
      if _storage._supportPeerStatus == nil {return false}
      if _storage._supportDateTime == nil {return false}
      if _storage._supportGnssConf == nil {return false}
      if _storage._supportHrAlarmConf == nil {return false}
      if _storage._supportUserConf == nil {return false}
      if _storage._supportGoalConf == nil {return false}
      if _storage._supportFemalHealthConf == nil {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularBoolField(value: &_storage._supportPeerType) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._supportPeerStatus) }()
        case 3: try { try decoder.decodeSingularBoolField(value: &_storage._supportDateTime) }()
        case 4: try { try decoder.decodeSingularBoolField(value: &_storage._supportGnssConf) }()
        case 5: try { try decoder.decodeSingularBoolField(value: &_storage._supportHrAlarmConf) }()
        case 6: try { try decoder.decodeSingularBoolField(value: &_storage._supportUserConf) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._supportGoalConf) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._supportFemalHealthConf) }()
        case 9: try { try decoder.decodeSingularFixed32Field(value: &_storage._hashGnssConf) }()
        case 10: try { try decoder.decodeSingularFixed32Field(value: &_storage._hashHrAlarmConf) }()
        case 11: try { try decoder.decodeSingularFixed32Field(value: &_storage._hashUserConf) }()
        case 12: try { try decoder.decodeSingularFixed32Field(value: &_storage._hashGoalConf) }()
        case 13: try { try decoder.decodeSingularBoolField(value: &_storage._supportBpcaliConf) }()
        case 14: try { try decoder.decodeSingularBoolField(value: &_storage._hashBpcaliConf) }()
        case 15: try { try decoder.decodeSingularBoolField(value: &_storage._supportAfConf) }()
        case 16: try { try decoder.decodeSingularFixed32Field(value: &_storage._hashAfConf) }()
        case 17: try { try decoder.decodeSingularBoolField(value: &_storage._hashFemalHealthConf) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._supportPeerType {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._supportPeerStatus {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._supportDateTime {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._supportGnssConf {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._supportHrAlarmConf {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._supportUserConf {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._supportGoalConf {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._supportFemalHealthConf {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._hashGnssConf {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._hashHrAlarmConf {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._hashUserConf {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._hashGoalConf {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._supportBpcaliConf {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._hashBpcaliConf {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._supportAfConf {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._hashAfConf {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._hashFemalHealthConf {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 17)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PeerInfoSubsriber, rhs: PeerInfoSubsriber) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._supportPeerType != rhs_storage._supportPeerType {return false}
        if _storage._supportPeerStatus != rhs_storage._supportPeerStatus {return false}
        if _storage._supportDateTime != rhs_storage._supportDateTime {return false}
        if _storage._supportGnssConf != rhs_storage._supportGnssConf {return false}
        if _storage._supportHrAlarmConf != rhs_storage._supportHrAlarmConf {return false}
        if _storage._supportUserConf != rhs_storage._supportUserConf {return false}
        if _storage._supportGoalConf != rhs_storage._supportGoalConf {return false}
        if _storage._supportFemalHealthConf != rhs_storage._supportFemalHealthConf {return false}
        if _storage._hashGnssConf != rhs_storage._hashGnssConf {return false}
        if _storage._hashHrAlarmConf != rhs_storage._hashHrAlarmConf {return false}
        if _storage._hashUserConf != rhs_storage._hashUserConf {return false}
        if _storage._hashGoalConf != rhs_storage._hashGoalConf {return false}
        if _storage._supportBpcaliConf != rhs_storage._supportBpcaliConf {return false}
        if _storage._hashBpcaliConf != rhs_storage._hashBpcaliConf {return false}
        if _storage._supportAfConf != rhs_storage._supportAfConf {return false}
        if _storage._hashAfConf != rhs_storage._hashAfConf {return false}
        if _storage._hashFemalHealthConf != rhs_storage._hashFemalHealthConf {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserConf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UserConf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "height"),
    3: .same(proto: "weight"),
    4: .same(proto: "gender"),
    5: .same(proto: "age"),
    6: .standard(proto: "calib_walk"),
    7: .standard(proto: "calib_run"),
    8: .same(proto: "grade"),
    9: .standard(proto: "Wrist_circumference"),
    10: .standard(proto: "History_of_hypertension"),
  ]

  public var isInitialized: Bool {
    if self._hash == nil {return false}
    if self._height == nil {return false}
    if self._weight == nil {return false}
    if self._gender == nil {return false}
    if self._age == nil {return false}
    if self._calibWalk == nil {return false}
    if self._calibRun == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._hash) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._height) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._weight) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._gender) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self._age) }()
      case 6: try { try decoder.decodeSingularFixed32Field(value: &self._calibWalk) }()
      case 7: try { try decoder.decodeSingularFixed32Field(value: &self._calibRun) }()
      case 8: try { try decoder.decodeSingularFixed32Field(value: &self._grade) }()
      case 9: try { try decoder.decodeSingularFixed32Field(value: &self._wristCircumference) }()
      case 10: try { try decoder.decodeSingularBoolField(value: &self._historyOfHypertension) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hash {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._height {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._weight {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._gender {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._age {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._calibWalk {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._calibRun {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._grade {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._wristCircumference {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._historyOfHypertension {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UserConf, rhs: UserConf) -> Bool {
    if lhs._hash != rhs._hash {return false}
    if lhs._height != rhs._height {return false}
    if lhs._weight != rhs._weight {return false}
    if lhs._gender != rhs._gender {return false}
    if lhs._age != rhs._age {return false}
    if lhs._calibWalk != rhs._calibWalk {return false}
    if lhs._calibRun != rhs._calibRun {return false}
    if lhs._grade != rhs._grade {return false}
    if lhs._wristCircumference != rhs._wristCircumference {return false}
    if lhs._historyOfHypertension != rhs._historyOfHypertension {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GoalConf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GoalConf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "distance"),
    3: .same(proto: "step"),
    4: .same(proto: "calorie"),
  ]

  public var isInitialized: Bool {
    if self._hash == nil {return false}
    if self._distance == nil {return false}
    if self._step == nil {return false}
    if self._calorie == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._hash) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._distance) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._step) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._calorie) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hash {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._distance {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._step {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._calorie {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GoalConf, rhs: GoalConf) -> Bool {
    if lhs._hash != rhs._hash {return false}
    if lhs._distance != rhs._distance {return false}
    if lhs._step != rhs._step {return false}
    if lhs._calorie != rhs._calorie {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HrAlarmConf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HrAlarmConf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "enable"),
    3: .standard(proto: "ths_high"),
    4: .standard(proto: "ths_low"),
    5: .same(proto: "timeout"),
    6: .same(proto: "interval"),
  ]

  public var isInitialized: Bool {
    if self._hash == nil {return false}
    if self._enable == nil {return false}
    if self._thsHigh == nil {return false}
    if self._thsLow == nil {return false}
    if self._timeout == nil {return false}
    if self._interval == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._hash) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._enable) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._thsHigh) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._thsLow) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self._timeout) }()
      case 6: try { try decoder.decodeSingularFixed32Field(value: &self._interval) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hash {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._enable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._thsHigh {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._thsLow {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._timeout {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._interval {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HrAlarmConf, rhs: HrAlarmConf) -> Bool {
    if lhs._hash != rhs._hash {return false}
    if lhs._enable != rhs._enable {return false}
    if lhs._thsHigh != rhs._thsHigh {return false}
    if lhs._thsLow != rhs._thsLow {return false}
    if lhs._timeout != rhs._timeout {return false}
    if lhs._interval != rhs._interval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension spo2AlarmConfv2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "spo2AlarmConfv2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "enable"),
    3: .standard(proto: "ths_low"),
  ]

  public var isInitialized: Bool {
    if self._hash == nil {return false}
    if self._enable == nil {return false}
    if self._thsLow == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._hash) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._enable) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._thsLow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hash {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._enable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._thsLow {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: spo2AlarmConfv2, rhs: spo2AlarmConfv2) -> Bool {
    if lhs._hash != rhs._hash {return false}
    if lhs._enable != rhs._enable {return false}
    if lhs._thsLow != rhs._thsLow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BpCustomConf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BpCustomConf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    2: .standard(proto: "sbp_high"),
    3: .standard(proto: "sbp_below"),
    4: .standard(proto: "dbp_high"),
    5: .standard(proto: "dbp_below"),
  ]

  public var isInitialized: Bool {
    if self._sbpHigh == nil {return false}
    if self._sbpBelow == nil {return false}
    if self._dbpHigh == nil {return false}
    if self._dbpBelow == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._sbpHigh) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._sbpBelow) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._dbpHigh) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self._dbpBelow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sbpHigh {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sbpBelow {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._dbpHigh {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._dbpBelow {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BpCustomConf, rhs: BpCustomConf) -> Bool {
    if lhs._sbpHigh != rhs._sbpHigh {return false}
    if lhs._sbpBelow != rhs._sbpBelow {return false}
    if lhs._dbpHigh != rhs._dbpHigh {return false}
    if lhs._dbpBelow != rhs._dbpBelow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BpAlarmCustomConf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BpAlarmCustomConf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
    2: .standard(proto: "Custom_conf"),
  ]

  public var isInitialized: Bool {
    if self._enable == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.customConf) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._enable) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.customConf) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._enable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    if !self.customConf.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customConf, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BpAlarmCustomConf, rhs: BpAlarmCustomConf) -> Bool {
    if lhs._enable != rhs._enable {return false}
    if lhs.customConf != rhs.customConf {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BpAlarmConfv2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BpAlarmConfv2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
    2: .standard(proto: "sbp_high"),
    3: .standard(proto: "sbp_below"),
    4: .standard(proto: "dbp_high"),
    5: .standard(proto: "dbp_below"),
  ]

  public var isInitialized: Bool {
    if self._enable == nil {return false}
    if self._sbpHigh == nil {return false}
    if self._sbpBelow == nil {return false}
    if self._dbpHigh == nil {return false}
    if self._dbpBelow == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._enable) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._sbpHigh) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._sbpBelow) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._dbpHigh) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self._dbpBelow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._enable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sbpHigh {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sbpBelow {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._dbpHigh {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._dbpBelow {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BpAlarmConfv2, rhs: BpAlarmConfv2) -> Bool {
    if lhs._enable != rhs._enable {return false}
    if lhs._sbpHigh != rhs._sbpHigh {return false}
    if lhs._sbpBelow != rhs._sbpBelow {return false}
    if lhs._dbpHigh != rhs._dbpHigh {return false}
    if lhs._dbpBelow != rhs._dbpBelow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TemperatureAlarmConfv2: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TemperatureAlarmConfv2"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "enable"),
    2: .standard(proto: "temp_high"),
    3: .standard(proto: "temp_below"),
  ]

  public var isInitialized: Bool {
    if self._enable == nil {return false}
    if self._tempHigh == nil {return false}
    if self._tempBelow == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._enable) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._tempHigh) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._tempBelow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._enable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tempHigh {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._tempBelow {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TemperatureAlarmConfv2, rhs: TemperatureAlarmConfv2) -> Bool {
    if lhs._enable != rhs._enable {return false}
    if lhs._tempHigh != rhs._tempHigh {return false}
    if lhs._tempBelow != rhs._tempBelow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GnssConf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GnssConf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "altitude"),
    3: .same(proto: "latitude"),
    4: .same(proto: "longitude"),
  ]

  public var isInitialized: Bool {
    if self._hash == nil {return false}
    if self._altitude == nil {return false}
    if self._latitude == nil {return false}
    if self._longitude == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._hash) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._altitude) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._latitude) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._longitude) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hash {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._altitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._latitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._longitude {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GnssConf, rhs: GnssConf) -> Bool {
    if lhs._hash != rhs._hash {return false}
    if lhs._altitude != rhs._altitude {return false}
    if lhs._latitude != rhs._latitude {return false}
    if lhs._longitude != rhs._longitude {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BpCaliConf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BpCaliConf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .standard(proto: "src_sbp"),
    3: .standard(proto: "src_dbp"),
    4: .standard(proto: "dst_sbp"),
    5: .standard(proto: "dst_dbp"),
    6: .standard(proto: "dif_sbp"),
    7: .standard(proto: "dif_dbp"),
    12: .standard(proto: "user_name"),
    13: .same(proto: "takeMedicine"),
  ]

  public var isInitialized: Bool {
    if self._hash == nil {return false}
    if self._srcSbp == nil {return false}
    if self._srcDbp == nil {return false}
    if self._dstSbp == nil {return false}
    if self._dstDbp == nil {return false}
    if self._difSbp == nil {return false}
    if self._difDbp == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._hash) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._srcSbp) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._srcDbp) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._dstSbp) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self._dstDbp) }()
      case 6: try { try decoder.decodeSingularSFixed32Field(value: &self._difSbp) }()
      case 7: try { try decoder.decodeSingularSFixed32Field(value: &self._difDbp) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._userName) }()
      case 13: try { try decoder.decodeSingularBoolField(value: &self._takeMedicine) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hash {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._srcSbp {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._srcDbp {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._dstSbp {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._dstDbp {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._difSbp {
      try visitor.visitSingularSFixed32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._difDbp {
      try visitor.visitSingularSFixed32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._userName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._takeMedicine {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 13)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BpCaliConf, rhs: BpCaliConf) -> Bool {
    if lhs._hash != rhs._hash {return false}
    if lhs._srcSbp != rhs._srcSbp {return false}
    if lhs._srcDbp != rhs._srcDbp {return false}
    if lhs._dstSbp != rhs._dstSbp {return false}
    if lhs._dstDbp != rhs._dstDbp {return false}
    if lhs._difSbp != rhs._difSbp {return false}
    if lhs._difDbp != rhs._difDbp {return false}
    if lhs._userName != rhs._userName {return false}
    if lhs._takeMedicine != rhs._takeMedicine {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AfConf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AfConf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .standard(proto: "auto_run"),
    3: .same(proto: "interval"),
  ]

  public var isInitialized: Bool {
    if self._hash == nil {return false}
    if self._autoRun == nil {return false}
    if self._interval == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._hash) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._autoRun) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._interval) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hash {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._autoRun {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._interval {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AfConf, rhs: AfConf) -> Bool {
    if lhs._hash != rhs._hash {return false}
    if lhs._autoRun != rhs._autoRun {return false}
    if lhs._interval != rhs._interval {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FemalHealthConf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FemalHealthConf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "enable"),
    3: .standard(proto: "start_time_menstruation"),
    4: .standard(proto: "cycle_length"),
    5: .standard(proto: "days_advance_menstruation"),
    6: .standard(proto: "days_advance_ovulation"),
    7: .standard(proto: "alarm_moment_hour"),
    8: .standard(proto: "alarm_moment_minute"),
  ]

  public var isInitialized: Bool {
    if self._hash == nil {return false}
    if self._enable == nil {return false}
    if self._startTimeMenstruation == nil {return false}
    if self._cycleLength == nil {return false}
    if self._daysAdvanceMenstruation == nil {return false}
    if self._daysAdvanceOvulation == nil {return false}
    if self._alarmMomentHour == nil {return false}
    if self._alarmMomentMinute == nil {return false}
    if let v = self._startTimeMenstruation, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._hash) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._enable) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._startTimeMenstruation) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._cycleLength) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self._daysAdvanceMenstruation) }()
      case 6: try { try decoder.decodeSingularFixed32Field(value: &self._daysAdvanceOvulation) }()
      case 7: try { try decoder.decodeSingularFixed32Field(value: &self._alarmMomentHour) }()
      case 8: try { try decoder.decodeSingularFixed32Field(value: &self._alarmMomentMinute) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hash {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._enable {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._startTimeMenstruation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._cycleLength {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._daysAdvanceMenstruation {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._daysAdvanceOvulation {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._alarmMomentHour {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._alarmMomentMinute {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FemalHealthConf, rhs: FemalHealthConf) -> Bool {
    if lhs._hash != rhs._hash {return false}
    if lhs._enable != rhs._enable {return false}
    if lhs._startTimeMenstruation != rhs._startTimeMenstruation {return false}
    if lhs._cycleLength != rhs._cycleLength {return false}
    if lhs._daysAdvanceMenstruation != rhs._daysAdvanceMenstruation {return false}
    if lhs._daysAdvanceOvulation != rhs._daysAdvanceOvulation {return false}
    if lhs._alarmMomentHour != rhs._alarmMomentHour {return false}
    if lhs._alarmMomentMinute != rhs._alarmMomentMinute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PeerInfoNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PeerInfoNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "peer_type"),
    2: .standard(proto: "peer_status"),
    3: .standard(proto: "date_time"),
    4: .standard(proto: "gnss_conf"),
    5: .standard(proto: "hr_alarm_conf"),
    6: .standard(proto: "user_conf"),
    7: .standard(proto: "goal_conf"),
    8: .standard(proto: "bpcali_conf"),
    9: .standard(proto: "af_conf"),
    10: .standard(proto: "connect_app"),
    11: .standard(proto: "femal_health_conf"),
    12: .standard(proto: "fall_check"),
    13: .standard(proto: "spo2_alarm_conf"),
    14: .standard(proto: "Bp_alarm_conf"),
    15: .standard(proto: "temp_alarm_conf"),
    16: .standard(proto: "Bp_Custom_conf"),
  ]

  fileprivate class _StorageClass {
    var _peerType: PeerInfoNotification.PeerType? = nil
    var _peerStatus: PeerInfoNotification.PeerStatus? = nil
    var _dateTime: DateTime? = nil
    var _gnssConf: GnssConf? = nil
    var _hrAlarmConf: HrAlarmConf? = nil
    var _userConf: UserConf? = nil
    var _goalConf: GoalConf? = nil
    var _bpcaliConf: BpCaliConf? = nil
    var _afConf: AfConf? = nil
    var _connectApp: Bool? = nil
    var _femalHealthConf: FemalHealthConf? = nil
    var _fallCheck: Bool? = nil
    var _spo2AlarmConf: spo2AlarmConfv2? = nil
    var _bpAlarmConf: BpAlarmConfv2? = nil
    var _tempAlarmConf: TemperatureAlarmConfv2? = nil
    var _bpCustomConf: BpAlarmCustomConf? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _peerType = source._peerType
      _peerStatus = source._peerStatus
      _dateTime = source._dateTime
      _gnssConf = source._gnssConf
      _hrAlarmConf = source._hrAlarmConf
      _userConf = source._userConf
      _goalConf = source._goalConf
      _bpcaliConf = source._bpcaliConf
      _afConf = source._afConf
      _connectApp = source._connectApp
      _femalHealthConf = source._femalHealthConf
      _fallCheck = source._fallCheck
      _spo2AlarmConf = source._spo2AlarmConf
      _bpAlarmConf = source._bpAlarmConf
      _tempAlarmConf = source._tempAlarmConf
      _bpCustomConf = source._bpCustomConf
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._dateTime, !v.isInitialized {return false}
      if let v = _storage._gnssConf, !v.isInitialized {return false}
      if let v = _storage._hrAlarmConf, !v.isInitialized {return false}
      if let v = _storage._userConf, !v.isInitialized {return false}
      if let v = _storage._goalConf, !v.isInitialized {return false}
      if let v = _storage._bpcaliConf, !v.isInitialized {return false}
      if let v = _storage._afConf, !v.isInitialized {return false}
      if let v = _storage._femalHealthConf, !v.isInitialized {return false}
      if let v = _storage._spo2AlarmConf, !v.isInitialized {return false}
      if let v = _storage._bpAlarmConf, !v.isInitialized {return false}
      if let v = _storage._tempAlarmConf, !v.isInitialized {return false}
      if let v = _storage._bpCustomConf, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._peerType) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._peerStatus) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._dateTime) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._gnssConf) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._hrAlarmConf) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._userConf) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._goalConf) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._bpcaliConf) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._afConf) }()
        case 10: try { try decoder.decodeSingularBoolField(value: &_storage._connectApp) }()
        case 11: try { try decoder.decodeSingularMessageField(value: &_storage._femalHealthConf) }()
        case 12: try { try decoder.decodeSingularBoolField(value: &_storage._fallCheck) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._spo2AlarmConf) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._bpAlarmConf) }()
        case 15: try { try decoder.decodeSingularMessageField(value: &_storage._tempAlarmConf) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._bpCustomConf) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._peerType {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._peerStatus {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._dateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._gnssConf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._hrAlarmConf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._userConf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._goalConf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._bpcaliConf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._afConf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._connectApp {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._femalHealthConf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._fallCheck {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._spo2AlarmConf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._bpAlarmConf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._tempAlarmConf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._bpCustomConf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PeerInfoNotification, rhs: PeerInfoNotification) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._peerType != rhs_storage._peerType {return false}
        if _storage._peerStatus != rhs_storage._peerStatus {return false}
        if _storage._dateTime != rhs_storage._dateTime {return false}
        if _storage._gnssConf != rhs_storage._gnssConf {return false}
        if _storage._hrAlarmConf != rhs_storage._hrAlarmConf {return false}
        if _storage._userConf != rhs_storage._userConf {return false}
        if _storage._goalConf != rhs_storage._goalConf {return false}
        if _storage._bpcaliConf != rhs_storage._bpcaliConf {return false}
        if _storage._afConf != rhs_storage._afConf {return false}
        if _storage._connectApp != rhs_storage._connectApp {return false}
        if _storage._femalHealthConf != rhs_storage._femalHealthConf {return false}
        if _storage._fallCheck != rhs_storage._fallCheck {return false}
        if _storage._spo2AlarmConf != rhs_storage._spo2AlarmConf {return false}
        if _storage._bpAlarmConf != rhs_storage._bpAlarmConf {return false}
        if _storage._tempAlarmConf != rhs_storage._tempAlarmConf {return false}
        if _storage._bpCustomConf != rhs_storage._bpCustomConf {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PeerInfoNotification.PeerType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APP_ANDROID"),
    1: .same(proto: "APP_IOS"),
  ]
}

extension PeerInfoNotification.PeerStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "APP_BACKGROUND"),
    1: .same(proto: "APP_FOREGROUND"),
  ]
}
