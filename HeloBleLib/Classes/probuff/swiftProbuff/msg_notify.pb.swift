// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: msg_notify.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// From peer to device
struct MsgHandler {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: UInt32 {
    get {return _hash ?? 0}
    set {_hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  var hasHash: Bool {return self._hash != nil}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  mutating func clearHash() {self._hash = nil}

  var policy: MsgHandler.Policy {
    get {return _policy ?? .storeAndPrompt}
    set {_policy = newValue}
  }
  /// Returns true if `policy` has been explicitly set.
  var hasPolicy: Bool {return self._policy != nil}
  /// Clears the value of `policy`. Subsequent reads from it will return its default value.
  mutating func clearPolicy() {self._policy = nil}

  var timing: MsgHandler.Timing {
    get {return _timing ?? MsgHandler.Timing()}
    set {_timing = newValue}
  }
  /// Returns true if `timing` has been explicitly set.
  var hasTiming: Bool {return self._timing != nil}
  /// Clears the value of `timing`. Subsequent reads from it will return its default value.
  mutating func clearTiming() {self._timing = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Policy: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case storeAndPrompt // = 0
    case storeNoPrompt // = 1
    case noStoreNoPrompt // = 2

    init() {
      self = .storeAndPrompt
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .storeAndPrompt
      case 1: self = .storeNoPrompt
      case 2: self = .noStoreNoPrompt
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .storeAndPrompt: return 0
      case .storeNoPrompt: return 1
      case .noStoreNoPrompt: return 2
      }
    }

  }

  struct Timing {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var startHour: UInt32 {
      get {return _startHour ?? 0}
      set {_startHour = newValue}
    }
    /// Returns true if `startHour` has been explicitly set.
    var hasStartHour: Bool {return self._startHour != nil}
    /// Clears the value of `startHour`. Subsequent reads from it will return its default value.
    mutating func clearStartHour() {self._startHour = nil}

    var startMinute: UInt32 {
      get {return _startMinute ?? 0}
      set {_startMinute = newValue}
    }
    /// Returns true if `startMinute` has been explicitly set.
    var hasStartMinute: Bool {return self._startMinute != nil}
    /// Clears the value of `startMinute`. Subsequent reads from it will return its default value.
    mutating func clearStartMinute() {self._startMinute = nil}

    var endHour: UInt32 {
      get {return _endHour ?? 0}
      set {_endHour = newValue}
    }
    /// Returns true if `endHour` has been explicitly set.
    var hasEndHour: Bool {return self._endHour != nil}
    /// Clears the value of `endHour`. Subsequent reads from it will return its default value.
    mutating func clearEndHour() {self._endHour = nil}

    var endMinute: UInt32 {
      get {return _endMinute ?? 0}
      set {_endMinute = newValue}
    }
    /// Returns true if `endMinute` has been explicitly set.
    var hasEndMinute: Bool {return self._endMinute != nil}
    /// Clears the value of `endMinute`. Subsequent reads from it will return its default value.
    mutating func clearEndMinute() {self._endMinute = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _startHour: UInt32? = nil
    fileprivate var _startMinute: UInt32? = nil
    fileprivate var _endHour: UInt32? = nil
    fileprivate var _endMinute: UInt32? = nil
  }

  init() {}

  fileprivate var _hash: UInt32? = nil
  fileprivate var _policy: MsgHandler.Policy? = nil
  fileprivate var _timing: MsgHandler.Timing? = nil
}

#if swift(>=4.2)

extension MsgHandler.Policy: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct MsgFilter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: UInt32 {
    get {return _hash ?? 0}
    set {_hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  var hasHash: Bool {return self._hash != nil}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  mutating func clearHash() {self._hash = nil}

  var id: [MsgFilter.ID] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct ID {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var id: String {
      get {return _id ?? String()}
      set {_id = newValue}
    }
    /// Returns true if `id` has been explicitly set.
    var hasID: Bool {return self._id != nil}
    /// Clears the value of `id`. Subsequent reads from it will return its default value.
    mutating func clearID() {self._id = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _id: String? = nil
  }

  init() {}

  fileprivate var _hash: UInt32? = nil
}

struct MsgNotify {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var type: MsgNotify.TypeEnum {
    get {return _type ?? .call}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var status: MsgNotify.Status {
    get {return _status ?? .added}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var option: MsgNotify.Option {
    get {return _option ?? MsgNotify.Option()}
    set {_option = newValue}
  }
  /// Returns true if `option` has been explicitly set.
  var hasOption: Bool {return self._option != nil}
  /// Clears the value of `option`. Subsequent reads from it will return its default value.
  mutating func clearOption() {self._option = nil}

  var title: String {
    get {return _title ?? String()}
    set {_title = newValue}
  }
  /// Returns true if `title` has been explicitly set.
  var hasTitle: Bool {return self._title != nil}
  /// Clears the value of `title`. Subsequent reads from it will return its default value.
  mutating func clearTitle() {self._title = nil}

  var detail: String {
    get {return _detail ?? String()}
    set {_detail = newValue}
  }
  /// Returns true if `detail` has been explicitly set.
  var hasDetail: Bool {return self._detail != nil}
  /// Clears the value of `detail`. Subsequent reads from it will return its default value.
  mutating func clearDetail() {self._detail = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum TypeEnum: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case call // = 128
    case sms // = 129

    init() {
      self = .call
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 128: self = .call
      case 129: self = .sms
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .call: return 128
      case .sms: return 129
      }
    }

  }

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// incoming call and sms
    case added // = 0

    /// incoming call accepted or rejected
    case removed // = 1

    /// incoming call turn to missed-call
    case updated // = 2

    init() {
      self = .added
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .added
      case 1: self = .removed
      case 2: self = .updated
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .added: return 0
      case .removed: return 1
      case .updated: return 2
      }
    }

  }

  struct Option {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var accept: Bool {
      get {return _accept ?? false}
      set {_accept = newValue}
    }
    /// Returns true if `accept` has been explicitly set.
    var hasAccept: Bool {return self._accept != nil}
    /// Clears the value of `accept`. Subsequent reads from it will return its default value.
    mutating func clearAccept() {self._accept = nil}

    var reject: Bool {
      get {return _reject ?? false}
      set {_reject = newValue}
    }
    /// Returns true if `reject` has been explicitly set.
    var hasReject: Bool {return self._reject != nil}
    /// Clears the value of `reject`. Subsequent reads from it will return its default value.
    mutating func clearReject() {self._reject = nil}

    var mute: Bool {
      get {return _mute ?? false}
      set {_mute = newValue}
    }
    /// Returns true if `mute` has been explicitly set.
    var hasMute: Bool {return self._mute != nil}
    /// Clears the value of `mute`. Subsequent reads from it will return its default value.
    mutating func clearMute() {self._mute = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _accept: Bool? = nil
    fileprivate var _reject: Bool? = nil
    fileprivate var _mute: Bool? = nil
  }

  init() {}

  fileprivate var _id: UInt32? = nil
  fileprivate var _type: MsgNotify.TypeEnum? = nil
  fileprivate var _status: MsgNotify.Status? = nil
  fileprivate var _option: MsgNotify.Option? = nil
  fileprivate var _title: String? = nil
  fileprivate var _detail: String? = nil
}

#if swift(>=4.2)

extension MsgNotify.TypeEnum: CaseIterable {
  // Support synthesized by the compiler.
}

extension MsgNotify.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct MsgNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var params: MsgNotification.OneOf_Params? = nil

  var handler: MsgHandler {
    get {
      if case .handler(let v)? = params {return v}
      return MsgHandler()
    }
    set {params = .handler(newValue)}
  }

  var filter: MsgFilter {
    get {
      if case .filter(let v)? = params {return v}
      return MsgFilter()
    }
    set {params = .filter(newValue)}
  }

  var notify: MsgNotify {
    get {
      if case .notify(let v)? = params {return v}
      return MsgNotify()
    }
    set {params = .notify(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Params: Equatable {
    case handler(MsgHandler)
    case filter(MsgFilter)
    case notify(MsgNotify)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .handler: return {
        guard case .handler(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .filter: return {
        guard case .filter(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .notify: return {
        guard case .notify(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      }
    }

  #if !swift(>=4.1)
    static func ==(lhs: MsgNotification.OneOf_Params, rhs: MsgNotification.OneOf_Params) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.handler, .handler): return {
        guard case .handler(let l) = lhs, case .handler(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.filter, .filter): return {
        guard case .filter(let l) = lhs, case .filter(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.notify, .notify): return {
        guard case .notify(let l) = lhs, case .notify(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

/// From device to peer
struct MsgRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var supportHandler: Bool {
    get {return _supportHandler ?? false}
    set {_supportHandler = newValue}
  }
  /// Returns true if `supportHandler` has been explicitly set.
  var hasSupportHandler: Bool {return self._supportHandler != nil}
  /// Clears the value of `supportHandler`. Subsequent reads from it will return its default value.
  mutating func clearSupportHandler() {self._supportHandler = nil}

  var supportFilter: Bool {
    get {return _supportFilter ?? false}
    set {_supportFilter = newValue}
  }
  /// Returns true if `supportFilter` has been explicitly set.
  var hasSupportFilter: Bool {return self._supportFilter != nil}
  /// Clears the value of `supportFilter`. Subsequent reads from it will return its default value.
  mutating func clearSupportFilter() {self._supportFilter = nil}

  var supportNotify: Bool {
    get {return _supportNotify ?? false}
    set {_supportNotify = newValue}
  }
  /// Returns true if `supportNotify` has been explicitly set.
  var hasSupportNotify: Bool {return self._supportNotify != nil}
  /// Clears the value of `supportNotify`. Subsequent reads from it will return its default value.
  mutating func clearSupportNotify() {self._supportNotify = nil}

  var handlerHash: UInt32 {
    get {return _handlerHash ?? 0}
    set {_handlerHash = newValue}
  }
  /// Returns true if `handlerHash` has been explicitly set.
  var hasHandlerHash: Bool {return self._handlerHash != nil}
  /// Clears the value of `handlerHash`. Subsequent reads from it will return its default value.
  mutating func clearHandlerHash() {self._handlerHash = nil}

  var filterHash: UInt32 {
    get {return _filterHash ?? 0}
    set {_filterHash = newValue}
  }
  /// Returns true if `filterHash` has been explicitly set.
  var hasFilterHash: Bool {return self._filterHash != nil}
  /// Clears the value of `filterHash`. Subsequent reads from it will return its default value.
  mutating func clearFilterHash() {self._filterHash = nil}

  var filterIDCount: UInt32 {
    get {return _filterIDCount ?? 0}
    set {_filterIDCount = newValue}
  }
  /// Returns true if `filterIDCount` has been explicitly set.
  var hasFilterIDCount: Bool {return self._filterIDCount != nil}
  /// Clears the value of `filterIDCount`. Subsequent reads from it will return its default value.
  mutating func clearFilterIDCount() {self._filterIDCount = nil}

  var notifyTitleLen: UInt32 {
    get {return _notifyTitleLen ?? 0}
    set {_notifyTitleLen = newValue}
  }
  /// Returns true if `notifyTitleLen` has been explicitly set.
  var hasNotifyTitleLen: Bool {return self._notifyTitleLen != nil}
  /// Clears the value of `notifyTitleLen`. Subsequent reads from it will return its default value.
  mutating func clearNotifyTitleLen() {self._notifyTitleLen = nil}

  var notifyDetailLen: UInt32 {
    get {return _notifyDetailLen ?? 0}
    set {_notifyDetailLen = newValue}
  }
  /// Returns true if `notifyDetailLen` has been explicitly set.
  var hasNotifyDetailLen: Bool {return self._notifyDetailLen != nil}
  /// Clears the value of `notifyDetailLen`. Subsequent reads from it will return its default value.
  mutating func clearNotifyDetailLen() {self._notifyDetailLen = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _supportHandler: Bool? = nil
  fileprivate var _supportFilter: Bool? = nil
  fileprivate var _supportNotify: Bool? = nil
  fileprivate var _handlerHash: UInt32? = nil
  fileprivate var _filterHash: UInt32? = nil
  fileprivate var _filterIDCount: UInt32? = nil
  fileprivate var _notifyTitleLen: UInt32? = nil
  fileprivate var _notifyDetailLen: UInt32? = nil
}

struct MsgOperation {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: UInt32 {
    get {return _id ?? 0}
    set {_id = newValue}
  }
  /// Returns true if `id` has been explicitly set.
  var hasID: Bool {return self._id != nil}
  /// Clears the value of `id`. Subsequent reads from it will return its default value.
  mutating func clearID() {self._id = nil}

  var option: MsgOperation.Option {
    get {return _option ?? .accept}
    set {_option = newValue}
  }
  /// Returns true if `option` has been explicitly set.
  var hasOption: Bool {return self._option != nil}
  /// Clears the value of `option`. Subsequent reads from it will return its default value.
  mutating func clearOption() {self._option = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Option: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case accept // = 0
    case reject // = 1
    case mute // = 2

    init() {
      self = .accept
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .accept
      case 1: self = .reject
      case 2: self = .mute
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .accept: return 0
      case .reject: return 1
      case .mute: return 2
      }
    }

  }

  init() {}

  fileprivate var _id: UInt32? = nil
  fileprivate var _option: MsgOperation.Option? = nil
}

#if swift(>=4.2)

extension MsgOperation.Option: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct MsgSubscriber {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: MsgSubscriber.OneOf_Data? = nil

  var request: MsgRequest {
    get {
      if case .request(let v)? = data {return v}
      return MsgRequest()
    }
    set {data = .request(newValue)}
  }

  var operation: MsgOperation {
    get {
      if case .operation(let v)? = data {return v}
      return MsgOperation()
    }
    set {data = .operation(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    case request(MsgRequest)
    case operation(MsgOperation)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .request: return {
        guard case .request(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .operation: return {
        guard case .operation(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      }
    }

  #if !swift(>=4.1)
    static func ==(lhs: MsgSubscriber.OneOf_Data, rhs: MsgSubscriber.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.request, .request): return {
        guard case .request(let l) = lhs, case .request(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.operation, .operation): return {
        guard case .operation(let l) = lhs, case .operation(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension MsgHandler: @unchecked Sendable {}
extension MsgHandler.Policy: @unchecked Sendable {}
extension MsgHandler.Timing: @unchecked Sendable {}
extension MsgFilter: @unchecked Sendable {}
extension MsgFilter.ID: @unchecked Sendable {}
extension MsgNotify: @unchecked Sendable {}
extension MsgNotify.TypeEnum: @unchecked Sendable {}
extension MsgNotify.Status: @unchecked Sendable {}
extension MsgNotify.Option: @unchecked Sendable {}
extension MsgNotification: @unchecked Sendable {}
extension MsgNotification.OneOf_Params: @unchecked Sendable {}
extension MsgRequest: @unchecked Sendable {}
extension MsgOperation: @unchecked Sendable {}
extension MsgOperation.Option: @unchecked Sendable {}
extension MsgSubscriber: @unchecked Sendable {}
extension MsgSubscriber.OneOf_Data: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension MsgHandler: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MsgHandler"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "policy"),
    3: .same(proto: "timing"),
  ]

  public var isInitialized: Bool {
    if self._hash == nil {return false}
    if self._policy == nil {return false}
    if self._timing == nil {return false}
    if let v = self._timing, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._hash) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._policy) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._timing) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hash {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._policy {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._timing {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MsgHandler, rhs: MsgHandler) -> Bool {
    if lhs._hash != rhs._hash {return false}
    if lhs._policy != rhs._policy {return false}
    if lhs._timing != rhs._timing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MsgHandler.Policy: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STORE_AND_PROMPT"),
    1: .same(proto: "STORE_NO_PROMPT"),
    2: .same(proto: "NO_STORE_NO_PROMPT"),
  ]
}

extension MsgHandler.Timing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = MsgHandler.protoMessageName + ".Timing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_hour"),
    2: .standard(proto: "start_minute"),
    3: .standard(proto: "end_hour"),
    4: .standard(proto: "end_minute"),
  ]

  public var isInitialized: Bool {
    if self._startHour == nil {return false}
    if self._startMinute == nil {return false}
    if self._endHour == nil {return false}
    if self._endMinute == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._startHour) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._startMinute) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._endHour) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._endMinute) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startHour {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._startMinute {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._endHour {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._endMinute {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MsgHandler.Timing, rhs: MsgHandler.Timing) -> Bool {
    if lhs._startHour != rhs._startHour {return false}
    if lhs._startMinute != rhs._startMinute {return false}
    if lhs._endHour != rhs._endHour {return false}
    if lhs._endMinute != rhs._endMinute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MsgFilter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MsgFilter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "id"),
  ]

  public var isInitialized: Bool {
    if self._hash == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.id) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._hash) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hash {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    if !self.id.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.id, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MsgFilter, rhs: MsgFilter) -> Bool {
    if lhs._hash != rhs._hash {return false}
    if lhs.id != rhs.id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MsgFilter.ID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = MsgFilter.protoMessageName + ".ID"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._id) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MsgFilter.ID, rhs: MsgFilter.ID) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MsgNotify: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MsgNotify"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "type"),
    3: .same(proto: "status"),
    4: .same(proto: "option"),
    5: .same(proto: "title"),
    6: .same(proto: "detail"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._type == nil {return false}
    if self._status == nil {return false}
    if self._option == nil {return false}
    if self._title == nil {return false}
    if self._detail == nil {return false}
    if let v = self._option, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._option) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._title) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._detail) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._option {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._title {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._detail {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MsgNotify, rhs: MsgNotify) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._type != rhs._type {return false}
    if lhs._status != rhs._status {return false}
    if lhs._option != rhs._option {return false}
    if lhs._title != rhs._title {return false}
    if lhs._detail != rhs._detail {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MsgNotify.TypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    128: .same(proto: "CALL"),
    129: .same(proto: "SMS"),
  ]
}

extension MsgNotify.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ADDED"),
    1: .same(proto: "REMOVED"),
    2: .same(proto: "UPDATED"),
  ]
}

extension MsgNotify.Option: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = MsgNotify.protoMessageName + ".Option"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "accept"),
    2: .same(proto: "reject"),
    3: .same(proto: "mute"),
  ]

  public var isInitialized: Bool {
    if self._accept == nil {return false}
    if self._reject == nil {return false}
    if self._mute == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._accept) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._reject) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._mute) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accept {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._reject {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mute {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MsgNotify.Option, rhs: MsgNotify.Option) -> Bool {
    if lhs._accept != rhs._accept {return false}
    if lhs._reject != rhs._reject {return false}
    if lhs._mute != rhs._mute {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MsgNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MsgNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "handler"),
    2: .same(proto: "filter"),
    3: .same(proto: "notify"),
  ]

  public var isInitialized: Bool {
    if let v = self.params, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: MsgHandler?
        var hadOneofValue = false
        if let current = self.params {
          hadOneofValue = true
          if case .handler(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.params = .handler(v)
        }
      }()
      case 2: try {
        var v: MsgFilter?
        var hadOneofValue = false
        if let current = self.params {
          hadOneofValue = true
          if case .filter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.params = .filter(v)
        }
      }()
      case 3: try {
        var v: MsgNotify?
        var hadOneofValue = false
        if let current = self.params {
          hadOneofValue = true
          if case .notify(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.params = .notify(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.params {
    case .handler?: try {
      guard case .handler(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .filter?: try {
      guard case .filter(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .notify?: try {
      guard case .notify(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MsgNotification, rhs: MsgNotification) -> Bool {
    if lhs.params != rhs.params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MsgRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MsgRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "support_handler"),
    2: .standard(proto: "support_filter"),
    3: .standard(proto: "support_notify"),
    4: .standard(proto: "handler_hash"),
    5: .standard(proto: "filter_hash"),
    6: .standard(proto: "filter_id_count"),
    7: .standard(proto: "notify_title_len"),
    8: .standard(proto: "notify_detail_len"),
  ]

  public var isInitialized: Bool {
    if self._supportHandler == nil {return false}
    if self._supportFilter == nil {return false}
    if self._supportNotify == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._supportHandler) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._supportFilter) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._supportNotify) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._handlerHash) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self._filterHash) }()
      case 6: try { try decoder.decodeSingularFixed32Field(value: &self._filterIDCount) }()
      case 7: try { try decoder.decodeSingularFixed32Field(value: &self._notifyTitleLen) }()
      case 8: try { try decoder.decodeSingularFixed32Field(value: &self._notifyDetailLen) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._supportHandler {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._supportFilter {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._supportNotify {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._handlerHash {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._filterHash {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._filterIDCount {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._notifyTitleLen {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._notifyDetailLen {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MsgRequest, rhs: MsgRequest) -> Bool {
    if lhs._supportHandler != rhs._supportHandler {return false}
    if lhs._supportFilter != rhs._supportFilter {return false}
    if lhs._supportNotify != rhs._supportNotify {return false}
    if lhs._handlerHash != rhs._handlerHash {return false}
    if lhs._filterHash != rhs._filterHash {return false}
    if lhs._filterIDCount != rhs._filterIDCount {return false}
    if lhs._notifyTitleLen != rhs._notifyTitleLen {return false}
    if lhs._notifyDetailLen != rhs._notifyDetailLen {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MsgOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MsgOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "option"),
  ]

  public var isInitialized: Bool {
    if self._id == nil {return false}
    if self._option == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._id) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._option) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._id {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._option {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MsgOperation, rhs: MsgOperation) -> Bool {
    if lhs._id != rhs._id {return false}
    if lhs._option != rhs._option {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MsgOperation.Option: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ACCEPT"),
    1: .same(proto: "REJECT"),
    2: .same(proto: "MUTE"),
  ]
}

extension MsgSubscriber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MsgSubscriber"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "request"),
    2: .same(proto: "operation"),
  ]

  public var isInitialized: Bool {
    if let v = self.data, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: MsgRequest?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .request(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .request(v)
        }
      }()
      case 2: try {
        var v: MsgOperation?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .operation(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .operation(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.data {
    case .request?: try {
      guard case .request(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .operation?: try {
      guard case .operation(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MsgSubscriber, rhs: MsgSubscriber) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
