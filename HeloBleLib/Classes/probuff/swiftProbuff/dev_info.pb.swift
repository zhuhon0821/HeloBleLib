// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: dev_info.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum DevInfoFota: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case non // = 0
  case cc2540 // = 1
  case nrf51 // = 2
  case da1468X // = 3
  case mt2523 // = 4
  case nrf52Ble // = 5
  case gh551XBle // = 6
  case ats3085Ble // = 7

  init() {
    self = .non
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .non
    case 1: self = .cc2540
    case 2: self = .nrf51
    case 3: self = .da1468X
    case 4: self = .mt2523
    case 5: self = .nrf52Ble
    case 6: self = .gh551XBle
    case 7: self = .ats3085Ble
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .non: return 0
    case .cc2540: return 1
    case .nrf51: return 2
    case .da1468X: return 3
    case .mt2523: return 4
    case .nrf52Ble: return 5
    case .gh551XBle: return 6
    case .ats3085Ble: return 7
    }
  }

}

#if swift(>=4.2)

extension DevInfoFota: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum DevInfoOperation: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case read // = 0
  case write // = 1

  init() {
    self = .read
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .read
    case 1: self = .write
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .read: return 0
    case .write: return 1
    }
  }

}

#if swift(>=4.2)

extension DevInfoOperation: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct DevInfoManu {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var date: String {
    get {return _date ?? String()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {self._date = nil}

  var factory: String {
    get {return _factory ?? String()}
    set {_factory = newValue}
  }
  /// Returns true if `factory` has been explicitly set.
  var hasFactory: Bool {return self._factory != nil}
  /// Clears the value of `factory`. Subsequent reads from it will return its default value.
  mutating func clearFactory() {self._factory = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _date: String? = nil
  fileprivate var _factory: String? = nil
}

struct DeviceInfoapn {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mcc: UInt32 {
    get {return _mcc ?? 0}
    set {_mcc = newValue}
  }
  /// Returns true if `mcc` has been explicitly set.
  var hasMcc: Bool {return self._mcc != nil}
  /// Clears the value of `mcc`. Subsequent reads from it will return its default value.
  mutating func clearMcc() {self._mcc = nil}

  var mnc: UInt32 {
    get {return _mnc ?? 0}
    set {_mnc = newValue}
  }
  /// Returns true if `mnc` has been explicitly set.
  var hasMnc: Bool {return self._mnc != nil}
  /// Clears the value of `mnc`. Subsequent reads from it will return its default value.
  mutating func clearMnc() {self._mnc = nil}

  var settingName: String {
    get {return _settingName ?? String()}
    set {_settingName = newValue}
  }
  /// Returns true if `settingName` has been explicitly set.
  var hasSettingName: Bool {return self._settingName != nil}
  /// Clears the value of `settingName`. Subsequent reads from it will return its default value.
  mutating func clearSettingName() {self._settingName = nil}

  var authType: UInt32 {
    get {return _authType ?? 0}
    set {_authType = newValue}
  }
  /// Returns true if `authType` has been explicitly set.
  var hasAuthType: Bool {return self._authType != nil}
  /// Clears the value of `authType`. Subsequent reads from it will return its default value.
  mutating func clearAuthType() {self._authType = nil}

  var roamingProtocol: UInt32 {
    get {return _roamingProtocol ?? 0}
    set {_roamingProtocol = newValue}
  }
  /// Returns true if `roamingProtocol` has been explicitly set.
  var hasRoamingProtocol: Bool {return self._roamingProtocol != nil}
  /// Clears the value of `roamingProtocol`. Subsequent reads from it will return its default value.
  mutating func clearRoamingProtocol() {self._roamingProtocol = nil}

  var apnStr: String {
    get {return _apnStr ?? String()}
    set {_apnStr = newValue}
  }
  /// Returns true if `apnStr` has been explicitly set.
  var hasApnStr: Bool {return self._apnStr != nil}
  /// Clears the value of `apnStr`. Subsequent reads from it will return its default value.
  mutating func clearApnStr() {self._apnStr = nil}

  var userName: String {
    get {return _userName ?? String()}
    set {_userName = newValue}
  }
  /// Returns true if `userName` has been explicitly set.
  var hasUserName: Bool {return self._userName != nil}
  /// Clears the value of `userName`. Subsequent reads from it will return its default value.
  mutating func clearUserName() {self._userName = nil}

  var password: String {
    get {return _password ?? String()}
    set {_password = newValue}
  }
  /// Returns true if `password` has been explicitly set.
  var hasPassword: Bool {return self._password != nil}
  /// Clears the value of `password`. Subsequent reads from it will return its default value.
  mutating func clearPassword() {self._password = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _mcc: UInt32? = nil
  fileprivate var _mnc: UInt32? = nil
  fileprivate var _settingName: String? = nil
  fileprivate var _authType: UInt32? = nil
  fileprivate var _roamingProtocol: UInt32? = nil
  fileprivate var _apnStr: String? = nil
  fileprivate var _userName: String? = nil
  fileprivate var _password: String? = nil
}

struct DeviceInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var model: String {
    get {return _model ?? String()}
    set {_model = newValue}
  }
  /// Returns true if `model` has been explicitly set.
  var hasModel: Bool {return self._model != nil}
  /// Clears the value of `model`. Subsequent reads from it will return its default value.
  mutating func clearModel() {self._model = nil}

  var version: String {
    get {return _version ?? String()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var mac: Data {
    get {return _mac ?? Data()}
    set {_mac = newValue}
  }
  /// Returns true if `mac` has been explicitly set.
  var hasMac: Bool {return self._mac != nil}
  /// Clears the value of `mac`. Subsequent reads from it will return its default value.
  mutating func clearMac() {self._mac = nil}

  var fota: DevInfoFota {
    get {return _fota ?? .non}
    set {_fota = newValue}
  }
  /// Returns true if `fota` has been explicitly set.
  var hasFota: Bool {return self._fota != nil}
  /// Clears the value of `fota`. Subsequent reads from it will return its default value.
  mutating func clearFota() {self._fota = nil}

  var manu: DevInfoManu {
    get {return _manu ?? DevInfoManu()}
    set {_manu = newValue}
  }
  /// Returns true if `manu` has been explicitly set.
  var hasManu: Bool {return self._manu != nil}
  /// Clears the value of `manu`. Subsequent reads from it will return its default value.
  mutating func clearManu() {self._manu = nil}

  var userData: Data {
    get {return _userData ?? Data()}
    set {_userData = newValue}
  }
  /// Returns true if `userData` has been explicitly set.
  var hasUserData: Bool {return self._userData != nil}
  /// Clears the value of `userData`. Subsequent reads from it will return its default value.
  mutating func clearUserData() {self._userData = nil}

  var pbVersion: String {
    get {return _pbVersion ?? String()}
    set {_pbVersion = newValue}
  }
  /// Returns true if `pbVersion` has been explicitly set.
  var hasPbVersion: Bool {return self._pbVersion != nil}
  /// Clears the value of `pbVersion`. Subsequent reads from it will return its default value.
  mutating func clearPbVersion() {self._pbVersion = nil}

  var ctpCs: UInt32 {
    get {return _ctpCs ?? 0}
    set {_ctpCs = newValue}
  }
  /// Returns true if `ctpCs` has been explicitly set.
  var hasCtpCs: Bool {return self._ctpCs != nil}
  /// Clears the value of `ctpCs`. Subsequent reads from it will return its default value.
  mutating func clearCtpCs() {self._ctpCs = nil}

  var programAddr: UInt32 {
    get {return _programAddr ?? 0}
    set {_programAddr = newValue}
  }
  /// Returns true if `programAddr` has been explicitly set.
  var hasProgramAddr: Bool {return self._programAddr != nil}
  /// Clears the value of `programAddr`. Subsequent reads from it will return its default value.
  mutating func clearProgramAddr() {self._programAddr = nil}

  var resourceAddr: UInt32 {
    get {return _resourceAddr ?? 0}
    set {_resourceAddr = newValue}
  }
  /// Returns true if `resourceAddr` has been explicitly set.
  var hasResourceAddr: Bool {return self._resourceAddr != nil}
  /// Clears the value of `resourceAddr`. Subsequent reads from it will return its default value.
  mutating func clearResourceAddr() {self._resourceAddr = nil}

  var apnContext: Bool {
    get {return _apnContext ?? false}
    set {_apnContext = newValue}
  }
  /// Returns true if `apnContext` has been explicitly set.
  var hasApnContext: Bool {return self._apnContext != nil}
  /// Clears the value of `apnContext`. Subsequent reads from it will return its default value.
  mutating func clearApnContext() {self._apnContext = nil}

  var bleName: String {
    get {return _bleName ?? String()}
    set {_bleName = newValue}
  }
  /// Returns true if `bleName` has been explicitly set.
  var hasBleName: Bool {return self._bleName != nil}
  /// Clears the value of `bleName`. Subsequent reads from it will return its default value.
  mutating func clearBleName() {self._bleName = nil}

  var encryptionStatus: UInt32 {
    get {return _encryptionStatus ?? 0}
    set {_encryptionStatus = newValue}
  }
  /// Returns true if `encryptionStatus` has been explicitly set.
  var hasEncryptionStatus: Bool {return self._encryptionStatus != nil}
  /// Clears the value of `encryptionStatus`. Subsequent reads from it will return its default value.
  mutating func clearEncryptionStatus() {self._encryptionStatus = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _model: String? = nil
  fileprivate var _version: String? = nil
  fileprivate var _mac: Data? = nil
  fileprivate var _fota: DevInfoFota? = nil
  fileprivate var _manu: DevInfoManu? = nil
  fileprivate var _userData: Data? = nil
  fileprivate var _pbVersion: String? = nil
  fileprivate var _ctpCs: UInt32? = nil
  fileprivate var _programAddr: UInt32? = nil
  fileprivate var _resourceAddr: UInt32? = nil
  fileprivate var _apnContext: Bool? = nil
  fileprivate var _bleName: String? = nil
  fileprivate var _encryptionStatus: UInt32? = nil
}

struct DeviceInfoCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userData: Data {
    get {return _userData ?? Data()}
    set {_userData = newValue}
  }
  /// Returns true if `userData` has been explicitly set.
  var hasUserData: Bool {return self._userData != nil}
  /// Clears the value of `userData`. Subsequent reads from it will return its default value.
  mutating func clearUserData() {self._userData = nil}

  var apnContext: DeviceInfoapn {
    get {return _apnContext ?? DeviceInfoapn()}
    set {_apnContext = newValue}
  }
  /// Returns true if `apnContext` has been explicitly set.
  var hasApnContext: Bool {return self._apnContext != nil}
  /// Clears the value of `apnContext`. Subsequent reads from it will return its default value.
  mutating func clearApnContext() {self._apnContext = nil}

  var dataURL: String {
    get {return _dataURL ?? String()}
    set {_dataURL = newValue}
  }
  /// Returns true if `dataURL` has been explicitly set.
  var hasDataURL: Bool {return self._dataURL != nil}
  /// Clears the value of `dataURL`. Subsequent reads from it will return its default value.
  mutating func clearDataURL() {self._dataURL = nil}

  var resonantFrequency: UInt32 {
    get {return _resonantFrequency ?? 0}
    set {_resonantFrequency = newValue}
  }
  /// Returns true if `resonantFrequency` has been explicitly set.
  var hasResonantFrequency: Bool {return self._resonantFrequency != nil}
  /// Clears the value of `resonantFrequency`. Subsequent reads from it will return its default value.
  mutating func clearResonantFrequency() {self._resonantFrequency = nil}

  var appQrURL: String {
    get {return _appQrURL ?? String()}
    set {_appQrURL = newValue}
  }
  /// Returns true if `appQrURL` has been explicitly set.
  var hasAppQrURL: Bool {return self._appQrURL != nil}
  /// Clears the value of `appQrURL`. Subsequent reads from it will return its default value.
  mutating func clearAppQrURL() {self._appQrURL = nil}

  var bleName: String {
    get {return _bleName ?? String()}
    set {_bleName = newValue}
  }
  /// Returns true if `bleName` has been explicitly set.
  var hasBleName: Bool {return self._bleName != nil}
  /// Clears the value of `bleName`. Subsequent reads from it will return its default value.
  mutating func clearBleName() {self._bleName = nil}

  var otherInfoData: Data {
    get {return _otherInfoData ?? Data()}
    set {_otherInfoData = newValue}
  }
  /// Returns true if `otherInfoData` has been explicitly set.
  var hasOtherInfoData: Bool {return self._otherInfoData != nil}
  /// Clears the value of `otherInfoData`. Subsequent reads from it will return its default value.
  mutating func clearOtherInfoData() {self._otherInfoData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _userData: Data? = nil
  fileprivate var _apnContext: DeviceInfoapn? = nil
  fileprivate var _dataURL: String? = nil
  fileprivate var _resonantFrequency: UInt32? = nil
  fileprivate var _appQrURL: String? = nil
  fileprivate var _bleName: String? = nil
  fileprivate var _otherInfoData: Data? = nil
}

struct DeviceInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reserved: UInt32 {
    get {return _reserved ?? 0}
    set {_reserved = newValue}
  }
  /// Returns true if `reserved` has been explicitly set.
  var hasReserved: Bool {return self._reserved != nil}
  /// Clears the value of `reserved`. Subsequent reads from it will return its default value.
  mutating func clearReserved() {self._reserved = nil}

  var operation: DevInfoOperation {
    get {return _operation ?? .read}
    set {_operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  var hasOperation: Bool {return self._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  mutating func clearOperation() {self._operation = nil}

  var devinfo: DeviceInfoCommand {
    get {return _devinfo ?? DeviceInfoCommand()}
    set {_devinfo = newValue}
  }
  /// Returns true if `devinfo` has been explicitly set.
  var hasDevinfo: Bool {return self._devinfo != nil}
  /// Clears the value of `devinfo`. Subsequent reads from it will return its default value.
  mutating func clearDevinfo() {self._devinfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _reserved: UInt32? = nil
  fileprivate var _operation: DevInfoOperation? = nil
  fileprivate var _devinfo: DeviceInfoCommand? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension DevInfoFota: @unchecked Sendable {}
extension DevInfoOperation: @unchecked Sendable {}
extension DevInfoManu: @unchecked Sendable {}
extension DeviceInfoapn: @unchecked Sendable {}
extension DeviceInfoResponse: @unchecked Sendable {}
extension DeviceInfoCommand: @unchecked Sendable {}
extension DeviceInfoRequest: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension DevInfoFota: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NON"),
    1: .same(proto: "CC2540"),
    2: .same(proto: "NRF51"),
    3: .same(proto: "DA1468X"),
    4: .same(proto: "MT2523"),
    5: .same(proto: "NRF52_BLE"),
    6: .same(proto: "GH551X_BLE"),
    7: .same(proto: "ATS3085_BLE"),
  ]
}

extension DevInfoOperation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Read"),
    1: .same(proto: "Write"),
  ]
}

extension DevInfoManu: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DevInfoManu"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "factory"),
  ]

  public var isInitialized: Bool {
    if self._date == nil {return false}
    if self._factory == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._date) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._factory) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._date {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._factory {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DevInfoManu, rhs: DevInfoManu) -> Bool {
    if lhs._date != rhs._date {return false}
    if lhs._factory != rhs._factory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceInfoapn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceInfoapn"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mcc"),
    2: .same(proto: "mnc"),
    3: .standard(proto: "setting_name"),
    4: .standard(proto: "auth_type"),
    5: .standard(proto: "roaming_protocol"),
    6: .standard(proto: "apn_str"),
    7: .standard(proto: "user_name"),
    8: .same(proto: "password"),
  ]

  public var isInitialized: Bool {
    if self._mcc == nil {return false}
    if self._mnc == nil {return false}
    if self._settingName == nil {return false}
    if self._authType == nil {return false}
    if self._roamingProtocol == nil {return false}
    if self._apnStr == nil {return false}
    if self._userName == nil {return false}
    if self._password == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._mcc) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._mnc) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._settingName) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._authType) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self._roamingProtocol) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._apnStr) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._userName) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._password) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._mcc {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._mnc {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._settingName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._authType {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._roamingProtocol {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._apnStr {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._userName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._password {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceInfoapn, rhs: DeviceInfoapn) -> Bool {
    if lhs._mcc != rhs._mcc {return false}
    if lhs._mnc != rhs._mnc {return false}
    if lhs._settingName != rhs._settingName {return false}
    if lhs._authType != rhs._authType {return false}
    if lhs._roamingProtocol != rhs._roamingProtocol {return false}
    if lhs._apnStr != rhs._apnStr {return false}
    if lhs._userName != rhs._userName {return false}
    if lhs._password != rhs._password {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "model"),
    2: .same(proto: "version"),
    3: .same(proto: "mac"),
    4: .same(proto: "fota"),
    5: .same(proto: "manu"),
    6: .standard(proto: "user_data"),
    7: .standard(proto: "pb_version"),
    8: .standard(proto: "ctp_cs"),
    9: .standard(proto: "program_addr"),
    10: .standard(proto: "resource_addr"),
    11: .standard(proto: "apn_context"),
    12: .standard(proto: "ble_name"),
    13: .standard(proto: "encryption_status"),
  ]

  public var isInitialized: Bool {
    if let v = self._manu, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._model) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._version) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._mac) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._fota) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._manu) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._userData) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._pbVersion) }()
      case 8: try { try decoder.decodeSingularFixed32Field(value: &self._ctpCs) }()
      case 9: try { try decoder.decodeSingularFixed32Field(value: &self._programAddr) }()
      case 10: try { try decoder.decodeSingularFixed32Field(value: &self._resourceAddr) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self._apnContext) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._bleName) }()
      case 13: try { try decoder.decodeSingularFixed32Field(value: &self._encryptionStatus) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._model {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._version {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mac {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._fota {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._manu {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._userData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._pbVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._ctpCs {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._programAddr {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._resourceAddr {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._apnContext {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._bleName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._encryptionStatus {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 13)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceInfoResponse, rhs: DeviceInfoResponse) -> Bool {
    if lhs._model != rhs._model {return false}
    if lhs._version != rhs._version {return false}
    if lhs._mac != rhs._mac {return false}
    if lhs._fota != rhs._fota {return false}
    if lhs._manu != rhs._manu {return false}
    if lhs._userData != rhs._userData {return false}
    if lhs._pbVersion != rhs._pbVersion {return false}
    if lhs._ctpCs != rhs._ctpCs {return false}
    if lhs._programAddr != rhs._programAddr {return false}
    if lhs._resourceAddr != rhs._resourceAddr {return false}
    if lhs._apnContext != rhs._apnContext {return false}
    if lhs._bleName != rhs._bleName {return false}
    if lhs._encryptionStatus != rhs._encryptionStatus {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceInfoCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceInfoCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_data"),
    2: .standard(proto: "apn_context"),
    3: .standard(proto: "data_url"),
    4: .standard(proto: "Resonant_frequency"),
    5: .standard(proto: "app_qr_url"),
    6: .standard(proto: "ble_name"),
    7: .standard(proto: "Other_info_data"),
  ]

  public var isInitialized: Bool {
    if let v = self._apnContext, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._userData) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._apnContext) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._dataURL) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._resonantFrequency) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self._appQrURL) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._bleName) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self._otherInfoData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._apnContext {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._dataURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._resonantFrequency {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._appQrURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._bleName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._otherInfoData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceInfoCommand, rhs: DeviceInfoCommand) -> Bool {
    if lhs._userData != rhs._userData {return false}
    if lhs._apnContext != rhs._apnContext {return false}
    if lhs._dataURL != rhs._dataURL {return false}
    if lhs._resonantFrequency != rhs._resonantFrequency {return false}
    if lhs._appQrURL != rhs._appQrURL {return false}
    if lhs._bleName != rhs._bleName {return false}
    if lhs._otherInfoData != rhs._otherInfoData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reserved"),
    2: .same(proto: "operation"),
    3: .same(proto: "devinfo"),
  ]

  public var isInitialized: Bool {
    if self._operation == nil {return false}
    if let v = self._devinfo, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._reserved) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._operation) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._devinfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._reserved {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._operation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._devinfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceInfoRequest, rhs: DeviceInfoRequest) -> Bool {
    if lhs._reserved != rhs._reserved {return false}
    if lhs._operation != rhs._operation {return false}
    if lhs._devinfo != rhs._devinfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
