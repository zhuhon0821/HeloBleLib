// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: his_data.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum HisOperation: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// get index table
  case itSync // = 0

  /// start sync
  case startSync // = 1

  /// stop sync
  case stopSync // = 2

  init() {
    self = .itSync
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .itSync
    case 1: self = .startSync
    case 2: self = .stopSync
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .itSync: return 0
    case .startSync: return 1
    case .stopSync: return 2
    }
  }

}

#if swift(>=4.2)

extension HisOperation: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum HisDataType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case healthData // = 0
  case gnssData // = 1
  case ecgData // = 2
  case ppgData // = 3
  case rriData // = 4
  case medicData // = 5
  case spo2Data // = 6
  case swimData // = 7
  case temperatureData // = 8
  case healthDataEncrypt // = 9
  case ecgDataEncrypt // = 10
  case ppgDataEncrypt // = 11
  case rriDataEncrypt // = 12
  case longEcgData // = 13

  init() {
    self = .healthData
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .healthData
    case 1: self = .gnssData
    case 2: self = .ecgData
    case 3: self = .ppgData
    case 4: self = .rriData
    case 5: self = .medicData
    case 6: self = .spo2Data
    case 7: self = .swimData
    case 8: self = .temperatureData
    case 9: self = .healthDataEncrypt
    case 10: self = .ecgDataEncrypt
    case 11: self = .ppgDataEncrypt
    case 12: self = .rriDataEncrypt
    case 13: self = .longEcgData
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .healthData: return 0
    case .gnssData: return 1
    case .ecgData: return 2
    case .ppgData: return 3
    case .rriData: return 4
    case .medicData: return 5
    case .spo2Data: return 6
    case .swimData: return 7
    case .temperatureData: return 8
    case .healthDataEncrypt: return 9
    case .ecgDataEncrypt: return 10
    case .ppgDataEncrypt: return 11
    case .rriDataEncrypt: return 12
    case .longEcgData: return 13
    }
  }

}

#if swift(>=4.2)

extension HisDataType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum HisDataStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case statusOk // = 0
  case statusInnerError // = 1
  case statusNvError // = 2
  case statusCrcError // = 3
  case statusTypeError // = 4
  case statusNotSupported // = 5

  init() {
    self = .statusOk
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .statusOk
    case 1: self = .statusInnerError
    case 2: self = .statusNvError
    case 3: self = .statusCrcError
    case 4: self = .statusTypeError
    case 5: self = .statusNotSupported
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .statusOk: return 0
    case .statusInnerError: return 1
    case .statusNvError: return 2
    case .statusCrcError: return 3
    case .statusTypeError: return 4
    case .statusNotSupported: return 5
    }
  }

}

#if swift(>=4.2)

extension HisDataStatus: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct HisBlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var startSeq: UInt32 {
    get {return _startSeq ?? 0}
    set {_startSeq = newValue}
  }
  /// Returns true if `startSeq` has been explicitly set.
  var hasStartSeq: Bool {return self._startSeq != nil}
  /// Clears the value of `startSeq`. Subsequent reads from it will return its default value.
  mutating func clearStartSeq() {self._startSeq = nil}

  var endSeq: UInt32 {
    get {return _endSeq ?? 0}
    set {_endSeq = newValue}
  }
  /// Returns true if `endSeq` has been explicitly set.
  var hasEndSeq: Bool {return self._endSeq != nil}
  /// Clears the value of `endSeq`. Subsequent reads from it will return its default value.
  mutating func clearEndSeq() {self._endSeq = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _startSeq: UInt32? = nil
  fileprivate var _endSeq: UInt32? = nil
}

struct HisITSync {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: HisDataType {
    get {return _type ?? .healthData}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: HisDataType? = nil
}

struct HisStartSync {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: HisDataType {
    get {return _type ?? .healthData}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var block: [HisBlock] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: HisDataType? = nil
}

struct HisStopSync {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: HisDataType {
    get {return _type ?? .healthData}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: HisDataType? = nil
}

struct HisSubscriber {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var operation: HisOperation {
    get {return _operation ?? .itSync}
    set {_operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  var hasOperation: Bool {return self._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  mutating func clearOperation() {self._operation = nil}

  var data: HisSubscriber.OneOf_Data? = nil

  var itSync: HisITSync {
    get {
      if case .itSync(let v)? = data {return v}
      return HisITSync()
    }
    set {data = .itSync(newValue)}
  }

  var startSync: HisStartSync {
    get {
      if case .startSync(let v)? = data {return v}
      return HisStartSync()
    }
    set {data = .startSync(newValue)}
  }

  var stopSync: HisStopSync {
    get {
      if case .stopSync(let v)? = data {return v}
      return HisStopSync()
    }
    set {data = .stopSync(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    case itSync(HisITSync)
    case startSync(HisStartSync)
    case stopSync(HisStopSync)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .itSync: return {
        guard case .itSync(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .startSync: return {
        guard case .startSync(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .stopSync: return {
        guard case .stopSync(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      }
    }

  #if !swift(>=4.1)
    static func ==(lhs: HisSubscriber.OneOf_Data, rhs: HisSubscriber.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.itSync, .itSync): return {
        guard case .itSync(let l) = lhs, case .itSync(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.startSync, .startSync): return {
        guard case .startSync(let l) = lhs, case .startSync(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.stopSync, .stopSync): return {
        guard case .stopSync(let l) = lhs, case .stopSync(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _operation: HisOperation? = nil
}

struct HisIndex {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var time: RtTime {
    get {return _time ?? RtTime()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var startSeq: UInt32 {
    get {return _startSeq ?? 0}
    set {_startSeq = newValue}
  }
  /// Returns true if `startSeq` has been explicitly set.
  var hasStartSeq: Bool {return self._startSeq != nil}
  /// Clears the value of `startSeq`. Subsequent reads from it will return its default value.
  mutating func clearStartSeq() {self._startSeq = nil}

  var endSeq: UInt32 {
    get {return _endSeq ?? 0}
    set {_endSeq = newValue}
  }
  /// Returns true if `endSeq` has been explicitly set.
  var hasEndSeq: Bool {return self._endSeq != nil}
  /// Clears the value of `endSeq`. Subsequent reads from it will return its default value.
  mutating func clearEndSeq() {self._endSeq = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _time: RtTime? = nil
  fileprivate var _startSeq: UInt32? = nil
  fileprivate var _endSeq: UInt32? = nil
}

struct HisIndexTable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var index: [HisIndex] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct HisData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var seq: UInt32 {
    get {return _seq ?? 0}
    set {_seq = newValue}
  }
  /// Returns true if `seq` has been explicitly set.
  var hasSeq: Bool {return self._seq != nil}
  /// Clears the value of `seq`. Subsequent reads from it will return its default value.
  mutating func clearSeq() {self._seq = nil}

  var data: HisData.OneOf_Data? = nil

  var status: HisDataStatus {
    get {
      if case .status(let v)? = data {return v}
      return .statusOk
    }
    set {data = .status(newValue)}
  }

  var health: HisDataHealth {
    get {
      if case .health(let v)? = data {return v}
      return HisDataHealth()
    }
    set {data = .health(newValue)}
  }

  var gnss: HisDataGNSS {
    get {
      if case .gnss(let v)? = data {return v}
      return HisDataGNSS()
    }
    set {data = .gnss(newValue)}
  }

  var ecg: HisDataECG {
    get {
      if case .ecg(let v)? = data {return v}
      return HisDataECG()
    }
    set {data = .ecg(newValue)}
  }

  var ppg: HisDataPPG {
    get {
      if case .ppg(let v)? = data {return v}
      return HisDataPPG()
    }
    set {data = .ppg(newValue)}
  }

  var rri: HisDataRRI {
    get {
      if case .rri(let v)? = data {return v}
      return HisDataRRI()
    }
    set {data = .rri(newValue)}
  }

  var medic: HisDataMedic {
    get {
      if case .medic(let v)? = data {return v}
      return HisDataMedic()
    }
    set {data = .medic(newValue)}
  }

  var spo2: HisDataSpo2 {
    get {
      if case .spo2(let v)? = data {return v}
      return HisDataSpo2()
    }
    set {data = .spo2(newValue)}
  }

  var swim: HisDataSwim {
    get {
      if case .swim(let v)? = data {return v}
      return HisDataSwim()
    }
    set {data = .swim(newValue)}
  }

  var temp: HisDataTemperature {
    get {
      if case .temp(let v)? = data {return v}
      return HisDataTemperature()
    }
    set {data = .temp(newValue)}
  }

  var healthencrypt: HisDataHealthEncrypt {
    get {
      if case .healthencrypt(let v)? = data {return v}
      return HisDataHealthEncrypt()
    }
    set {data = .healthencrypt(newValue)}
  }

  var ecgencrypt: HisDataECGEncrypt {
    get {
      if case .ecgencrypt(let v)? = data {return v}
      return HisDataECGEncrypt()
    }
    set {data = .ecgencrypt(newValue)}
  }

  var ppgencrypt: HisDataPPGEncrypt {
    get {
      if case .ppgencrypt(let v)? = data {return v}
      return HisDataPPGEncrypt()
    }
    set {data = .ppgencrypt(newValue)}
  }

  var rriencrypt: HisDataRRIEncrypt {
    get {
      if case .rriencrypt(let v)? = data {return v}
      return HisDataRRIEncrypt()
    }
    set {data = .rriencrypt(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    case status(HisDataStatus)
    case health(HisDataHealth)
    case gnss(HisDataGNSS)
    case ecg(HisDataECG)
    case ppg(HisDataPPG)
    case rri(HisDataRRI)
    case medic(HisDataMedic)
    case spo2(HisDataSpo2)
    case swim(HisDataSwim)
    case temp(HisDataTemperature)
    case healthencrypt(HisDataHealthEncrypt)
    case ecgencrypt(HisDataECGEncrypt)
    case ppgencrypt(HisDataPPGEncrypt)
    case rriencrypt(HisDataRRIEncrypt)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .health: return {
        guard case .health(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .gnss: return {
        guard case .gnss(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .ecg: return {
        guard case .ecg(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .ppg: return {
        guard case .ppg(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .rri: return {
        guard case .rri(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .medic: return {
        guard case .medic(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .spo2: return {
        guard case .spo2(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .swim: return {
        guard case .swim(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .temp: return {
        guard case .temp(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .healthencrypt: return {
        guard case .healthencrypt(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .ecgencrypt: return {
        guard case .ecgencrypt(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .ppgencrypt: return {
        guard case .ppgencrypt(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .rriencrypt: return {
        guard case .rriencrypt(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      default: return true
      }
    }

  #if !swift(>=4.1)
    static func ==(lhs: HisData.OneOf_Data, rhs: HisData.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.status, .status): return {
        guard case .status(let l) = lhs, case .status(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.health, .health): return {
        guard case .health(let l) = lhs, case .health(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.gnss, .gnss): return {
        guard case .gnss(let l) = lhs, case .gnss(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ecg, .ecg): return {
        guard case .ecg(let l) = lhs, case .ecg(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ppg, .ppg): return {
        guard case .ppg(let l) = lhs, case .ppg(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rri, .rri): return {
        guard case .rri(let l) = lhs, case .rri(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.medic, .medic): return {
        guard case .medic(let l) = lhs, case .medic(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.spo2, .spo2): return {
        guard case .spo2(let l) = lhs, case .spo2(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.swim, .swim): return {
        guard case .swim(let l) = lhs, case .swim(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.temp, .temp): return {
        guard case .temp(let l) = lhs, case .temp(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.healthencrypt, .healthencrypt): return {
        guard case .healthencrypt(let l) = lhs, case .healthencrypt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ecgencrypt, .ecgencrypt): return {
        guard case .ecgencrypt(let l) = lhs, case .ecgencrypt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.ppgencrypt, .ppgencrypt): return {
        guard case .ppgencrypt(let l) = lhs, case .ppgencrypt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.rriencrypt, .rriencrypt): return {
        guard case .rriencrypt(let l) = lhs, case .rriencrypt(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _seq: UInt32? = nil
}

struct HisConfirm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var operation: HisOperation {
    get {return _operation ?? .itSync}
    set {_operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  var hasOperation: Bool {return self._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  mutating func clearOperation() {self._operation = nil}

  var ret: Bool {
    get {return _ret ?? false}
    set {_ret = newValue}
  }
  /// Returns true if `ret` has been explicitly set.
  var hasRet: Bool {return self._ret != nil}
  /// Clears the value of `ret`. Subsequent reads from it will return its default value.
  mutating func clearRet() {self._ret = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _operation: HisOperation? = nil
  fileprivate var _ret: Bool? = nil
}

struct HisNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: HisDataType {
    get {return _type ?? .healthData}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var data: HisNotification.OneOf_Data? = nil

  var confirm: HisConfirm {
    get {
      if case .confirm(let v)? = data {return v}
      return HisConfirm()
    }
    set {data = .confirm(newValue)}
  }

  var indexTable: HisIndexTable {
    get {
      if case .indexTable(let v)? = data {return v}
      return HisIndexTable()
    }
    set {data = .indexTable(newValue)}
  }

  var hisData: HisData {
    get {
      if case .hisData(let v)? = data {return v}
      return HisData()
    }
    set {data = .hisData(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    case confirm(HisConfirm)
    case indexTable(HisIndexTable)
    case hisData(HisData)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .confirm: return {
        guard case .confirm(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .indexTable: return {
        guard case .indexTable(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .hisData: return {
        guard case .hisData(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      }
    }

  #if !swift(>=4.1)
    static func ==(lhs: HisNotification.OneOf_Data, rhs: HisNotification.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.confirm, .confirm): return {
        guard case .confirm(let l) = lhs, case .confirm(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.indexTable, .indexTable): return {
        guard case .indexTable(let l) = lhs, case .indexTable(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.hisData, .hisData): return {
        guard case .hisData(let l) = lhs, case .hisData(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _type: HisDataType? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension HisOperation: @unchecked Sendable {}
extension HisDataType: @unchecked Sendable {}
extension HisDataStatus: @unchecked Sendable {}
extension HisBlock: @unchecked Sendable {}
extension HisITSync: @unchecked Sendable {}
extension HisStartSync: @unchecked Sendable {}
extension HisStopSync: @unchecked Sendable {}
extension HisSubscriber: @unchecked Sendable {}
extension HisSubscriber.OneOf_Data: @unchecked Sendable {}
extension HisIndex: @unchecked Sendable {}
extension HisIndexTable: @unchecked Sendable {}
extension HisData: @unchecked Sendable {}
extension HisData.OneOf_Data: @unchecked Sendable {}
extension HisConfirm: @unchecked Sendable {}
extension HisNotification: @unchecked Sendable {}
extension HisNotification.OneOf_Data: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension HisOperation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "IT_SYNC"),
    1: .same(proto: "START_SYNC"),
    2: .same(proto: "STOP_SYNC"),
  ]
}

extension HisDataType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HEALTH_DATA"),
    1: .same(proto: "GNSS_DATA"),
    2: .same(proto: "ECG_DATA"),
    3: .same(proto: "PPG_DATA"),
    4: .same(proto: "RRI_DATA"),
    5: .same(proto: "MEDIC_DATA"),
    6: .same(proto: "SPO2_DATA"),
    7: .same(proto: "SWIM_DATA"),
    8: .same(proto: "TEMPERATURE_DATA"),
    9: .same(proto: "HEALTH_DATA_ENCRYPT"),
    10: .same(proto: "ECG_DATA_ENCRYPT"),
    11: .same(proto: "PPG_DATA_ENCRYPT"),
    12: .same(proto: "RRI_DATA_ENCRYPT"),
    13: .same(proto: "LONG_ECG_DATA"),
  ]
}

extension HisDataStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATUS_OK"),
    1: .same(proto: "STATUS_INNER_ERROR"),
    2: .same(proto: "STATUS_NV_ERROR"),
    3: .same(proto: "STATUS_CRC_ERROR"),
    4: .same(proto: "STATUS_TYPE_ERROR"),
    5: .same(proto: "STATUS_NOT_SUPPORTED"),
  ]
}

extension HisBlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HisBlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "start_seq"),
    2: .standard(proto: "end_seq"),
  ]

  public var isInitialized: Bool {
    if self._startSeq == nil {return false}
    if self._endSeq == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._startSeq) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._endSeq) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._startSeq {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._endSeq {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HisBlock, rhs: HisBlock) -> Bool {
    if lhs._startSeq != rhs._startSeq {return false}
    if lhs._endSeq != rhs._endSeq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HisITSync: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HisITSync"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HisITSync, rhs: HisITSync) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HisStartSync: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HisStartSync"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "block"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.block) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.block) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    if !self.block.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.block, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HisStartSync, rhs: HisStartSync) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.block != rhs.block {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HisStopSync: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HisStopSync"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HisStopSync, rhs: HisStopSync) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HisSubscriber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HisSubscriber"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
    2: .standard(proto: "it_sync"),
    3: .standard(proto: "start_sync"),
    4: .standard(proto: "stop_sync"),
  ]

  public var isInitialized: Bool {
    if self._operation == nil {return false}
    if let v = self.data, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._operation) }()
      case 2: try {
        var v: HisITSync?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .itSync(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .itSync(v)
        }
      }()
      case 3: try {
        var v: HisStartSync?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .startSync(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .startSync(v)
        }
      }()
      case 4: try {
        var v: HisStopSync?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .stopSync(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .stopSync(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._operation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    switch self.data {
    case .itSync?: try {
      guard case .itSync(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .startSync?: try {
      guard case .startSync(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .stopSync?: try {
      guard case .stopSync(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HisSubscriber, rhs: HisSubscriber) -> Bool {
    if lhs._operation != rhs._operation {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HisIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HisIndex"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "time"),
    2: .standard(proto: "start_seq"),
    3: .standard(proto: "end_seq"),
  ]

  public var isInitialized: Bool {
    if self._time == nil {return false}
    if self._startSeq == nil {return false}
    if self._endSeq == nil {return false}
    if let v = self._time, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._startSeq) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._endSeq) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._startSeq {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._endSeq {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HisIndex, rhs: HisIndex) -> Bool {
    if lhs._time != rhs._time {return false}
    if lhs._startSeq != rhs._startSeq {return false}
    if lhs._endSeq != rhs._endSeq {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HisIndexTable: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HisIndexTable"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "index"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.index) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.index) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.index.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.index, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HisIndexTable, rhs: HisIndexTable) -> Bool {
    if lhs.index != rhs.index {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HisData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HisData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "seq"),
    2: .same(proto: "status"),
    3: .same(proto: "health"),
    4: .same(proto: "gnss"),
    5: .same(proto: "ecg"),
    6: .same(proto: "ppg"),
    7: .same(proto: "rri"),
    8: .same(proto: "medic"),
    9: .same(proto: "spo2"),
    10: .same(proto: "swim"),
    11: .same(proto: "temp"),
    12: .same(proto: "healthencrypt"),
    13: .same(proto: "ecgencrypt"),
    14: .same(proto: "ppgencrypt"),
    15: .same(proto: "rriencrypt"),
  ]

  public var isInitialized: Bool {
    if self._seq == nil {return false}
    if let v = self.data, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._seq) }()
      case 2: try {
        var v: HisDataStatus?
        try decoder.decodeSingularEnumField(value: &v)
        if let v = v {
          if self.data != nil {try decoder.handleConflictingOneOf()}
          self.data = .status(v)
        }
      }()
      case 3: try {
        var v: HisDataHealth?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .health(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .health(v)
        }
      }()
      case 4: try {
        var v: HisDataGNSS?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .gnss(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .gnss(v)
        }
      }()
      case 5: try {
        var v: HisDataECG?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .ecg(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .ecg(v)
        }
      }()
      case 6: try {
        var v: HisDataPPG?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .ppg(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .ppg(v)
        }
      }()
      case 7: try {
        var v: HisDataRRI?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .rri(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .rri(v)
        }
      }()
      case 8: try {
        var v: HisDataMedic?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .medic(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .medic(v)
        }
      }()
      case 9: try {
        var v: HisDataSpo2?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .spo2(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .spo2(v)
        }
      }()
      case 10: try {
        var v: HisDataSwim?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .swim(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .swim(v)
        }
      }()
      case 11: try {
        var v: HisDataTemperature?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .temp(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .temp(v)
        }
      }()
      case 12: try {
        var v: HisDataHealthEncrypt?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .healthencrypt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .healthencrypt(v)
        }
      }()
      case 13: try {
        var v: HisDataECGEncrypt?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .ecgencrypt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .ecgencrypt(v)
        }
      }()
      case 14: try {
        var v: HisDataPPGEncrypt?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .ppgencrypt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .ppgencrypt(v)
        }
      }()
      case 15: try {
        var v: HisDataRRIEncrypt?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .rriencrypt(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .rriencrypt(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._seq {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    switch self.data {
    case .status?: try {
      guard case .status(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    }()
    case .health?: try {
      guard case .health(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .gnss?: try {
      guard case .gnss(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .ecg?: try {
      guard case .ecg(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .ppg?: try {
      guard case .ppg(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .rri?: try {
      guard case .rri(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .medic?: try {
      guard case .medic(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .spo2?: try {
      guard case .spo2(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .swim?: try {
      guard case .swim(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .temp?: try {
      guard case .temp(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .healthencrypt?: try {
      guard case .healthencrypt(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case .ecgencrypt?: try {
      guard case .ecgencrypt(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
    }()
    case .ppgencrypt?: try {
      guard case .ppgencrypt(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
    }()
    case .rriencrypt?: try {
      guard case .rriencrypt(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 15)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HisData, rhs: HisData) -> Bool {
    if lhs._seq != rhs._seq {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HisConfirm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HisConfirm"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
    2: .same(proto: "ret"),
  ]

  public var isInitialized: Bool {
    if self._operation == nil {return false}
    if self._ret == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._operation) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._ret) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._operation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._ret {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HisConfirm, rhs: HisConfirm) -> Bool {
    if lhs._operation != rhs._operation {return false}
    if lhs._ret != rhs._ret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HisNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HisNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "confirm"),
    3: .standard(proto: "index_table"),
    4: .standard(proto: "his_data"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if let v = self.data, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try {
        var v: HisConfirm?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .confirm(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .confirm(v)
        }
      }()
      case 3: try {
        var v: HisIndexTable?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .indexTable(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .indexTable(v)
        }
      }()
      case 4: try {
        var v: HisData?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .hisData(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .hisData(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    switch self.data {
    case .confirm?: try {
      guard case .confirm(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .indexTable?: try {
      guard case .indexTable(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .hisData?: try {
      guard case .hisData(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HisNotification, rhs: HisNotification) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
