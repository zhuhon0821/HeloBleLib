// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: factory_test.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum FactoryTestMode: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case dischargeMode // = 0
  case chargingMode // = 1
  case pressureMode // = 2
  case placeMode // = 3
  case sensorMode // = 4
  case autoTestMode // = 5
  case fullyAutoResultMode // = 6

  init() {
    self = .dischargeMode
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .dischargeMode
    case 1: self = .chargingMode
    case 2: self = .pressureMode
    case 3: self = .placeMode
    case 4: self = .sensorMode
    case 5: self = .autoTestMode
    case 6: self = .fullyAutoResultMode
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .dischargeMode: return 0
    case .chargingMode: return 1
    case .pressureMode: return 2
    case .placeMode: return 3
    case .sensorMode: return 4
    case .autoTestMode: return 5
    case .fullyAutoResultMode: return 6
    }
  }

}

#if swift(>=4.2)

extension FactoryTestMode: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum TestOperation: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case testStart // = 0
  case testStop // = 1
  case testResult // = 2
  case testLastResult // = 3

  init() {
    self = .testStart
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .testStart
    case 1: self = .testStop
    case 2: self = .testResult
    case 3: self = .testLastResult
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .testStart: return 0
    case .testStop: return 1
    case .testResult: return 2
    case .testLastResult: return 3
    }
  }

}

#if swift(>=4.2)

extension TestOperation: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct PlacementTestResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var placementTimes: [Int32] = []

  var placementResult: Bool {
    get {return _placementResult ?? false}
    set {_placementResult = newValue}
  }
  /// Returns true if `placementResult` has been explicitly set.
  var hasPlacementResult: Bool {return self._placementResult != nil}
  /// Clears the value of `placementResult`. Subsequent reads from it will return its default value.
  mutating func clearPlacementResult() {self._placementResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _placementResult: Bool? = nil
}

struct ChargeTestResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var chargeTimes: [Int32] = []

  var chargeResult: Bool {
    get {return _chargeResult ?? false}
    set {_chargeResult = newValue}
  }
  /// Returns true if `chargeResult` has been explicitly set.
  var hasChargeResult: Bool {return self._chargeResult != nil}
  /// Clears the value of `chargeResult`. Subsequent reads from it will return its default value.
  mutating func clearChargeResult() {self._chargeResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _chargeResult: Bool? = nil
}

struct DischargeTestResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dischargeTimes: [Int32] = []

  var dischargeResult: Bool {
    get {return _dischargeResult ?? false}
    set {_dischargeResult = newValue}
  }
  /// Returns true if `dischargeResult` has been explicitly set.
  var hasDischargeResult: Bool {return self._dischargeResult != nil}
  /// Clears the value of `dischargeResult`. Subsequent reads from it will return its default value.
  mutating func clearDischargeResult() {self._dischargeResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _dischargeResult: Bool? = nil
}

struct PressureTestResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var pressureTimes: [Int32] = []

  var pressureResult: Bool {
    get {return _pressureResult ?? false}
    set {_pressureResult = newValue}
  }
  /// Returns true if `pressureResult` has been explicitly set.
  var hasPressureResult: Bool {return self._pressureResult != nil}
  /// Clears the value of `pressureResult`. Subsequent reads from it will return its default value.
  mutating func clearPressureResult() {self._pressureResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _pressureResult: Bool? = nil
}

struct AutoTestResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var gsensorResult: UInt32 {
    get {return _gsensorResult ?? 0}
    set {_gsensorResult = newValue}
  }
  /// Returns true if `gsensorResult` has been explicitly set.
  var hasGsensorResult: Bool {return self._gsensorResult != nil}
  /// Clears the value of `gsensorResult`. Subsequent reads from it will return its default value.
  mutating func clearGsensorResult() {self._gsensorResult = nil}

  var gsensorChipID: UInt32 {
    get {return _gsensorChipID ?? 0}
    set {_gsensorChipID = newValue}
  }
  /// Returns true if `gsensorChipID` has been explicitly set.
  var hasGsensorChipID: Bool {return self._gsensorChipID != nil}
  /// Clears the value of `gsensorChipID`. Subsequent reads from it will return its default value.
  mutating func clearGsensorChipID() {self._gsensorChipID = nil}

  var ppgResult: UInt32 {
    get {return _ppgResult ?? 0}
    set {_ppgResult = newValue}
  }
  /// Returns true if `ppgResult` has been explicitly set.
  var hasPpgResult: Bool {return self._ppgResult != nil}
  /// Clears the value of `ppgResult`. Subsequent reads from it will return its default value.
  mutating func clearPpgResult() {self._ppgResult = nil}

  var ecgResult: UInt32 {
    get {return _ecgResult ?? 0}
    set {_ecgResult = newValue}
  }
  /// Returns true if `ecgResult` has been explicitly set.
  var hasEcgResult: Bool {return self._ecgResult != nil}
  /// Clears the value of `ecgResult`. Subsequent reads from it will return its default value.
  mutating func clearEcgResult() {self._ecgResult = nil}

  var bpResult: UInt32 {
    get {return _bpResult ?? 0}
    set {_bpResult = newValue}
  }
  /// Returns true if `bpResult` has been explicitly set.
  var hasBpResult: Bool {return self._bpResult != nil}
  /// Clears the value of `bpResult`. Subsequent reads from it will return its default value.
  mutating func clearBpResult() {self._bpResult = nil}

  var tempratureResult: UInt32 {
    get {return _tempratureResult ?? 0}
    set {_tempratureResult = newValue}
  }
  /// Returns true if `tempratureResult` has been explicitly set.
  var hasTempratureResult: Bool {return self._tempratureResult != nil}
  /// Clears the value of `tempratureResult`. Subsequent reads from it will return its default value.
  mutating func clearTempratureResult() {self._tempratureResult = nil}

  var spiFlashResult: UInt32 {
    get {return _spiFlashResult ?? 0}
    set {_spiFlashResult = newValue}
  }
  /// Returns true if `spiFlashResult` has been explicitly set.
  var hasSpiFlashResult: Bool {return self._spiFlashResult != nil}
  /// Clears the value of `spiFlashResult`. Subsequent reads from it will return its default value.
  mutating func clearSpiFlashResult() {self._spiFlashResult = nil}

  var encryptResult: UInt32 {
    get {return _encryptResult ?? 0}
    set {_encryptResult = newValue}
  }
  /// Returns true if `encryptResult` has been explicitly set.
  var hasEncryptResult: Bool {return self._encryptResult != nil}
  /// Clears the value of `encryptResult`. Subsequent reads from it will return its default value.
  mutating func clearEncryptResult() {self._encryptResult = nil}

  var bpVersion: UInt32 {
    get {return _bpVersion ?? 0}
    set {_bpVersion = newValue}
  }
  /// Returns true if `bpVersion` has been explicitly set.
  var hasBpVersion: Bool {return self._bpVersion != nil}
  /// Clears the value of `bpVersion`. Subsequent reads from it will return its default value.
  mutating func clearBpVersion() {self._bpVersion = nil}

  var oaqResult: UInt32 {
    get {return _oaqResult ?? 0}
    set {_oaqResult = newValue}
  }
  /// Returns true if `oaqResult` has been explicitly set.
  var hasOaqResult: Bool {return self._oaqResult != nil}
  /// Clears the value of `oaqResult`. Subsequent reads from it will return its default value.
  mutating func clearOaqResult() {self._oaqResult = nil}

  var iaqResult: UInt32 {
    get {return _iaqResult ?? 0}
    set {_iaqResult = newValue}
  }
  /// Returns true if `iaqResult` has been explicitly set.
  var hasIaqResult: Bool {return self._iaqResult != nil}
  /// Clears the value of `iaqResult`. Subsequent reads from it will return its default value.
  mutating func clearIaqResult() {self._iaqResult = nil}

  var humitureResult: UInt32 {
    get {return _humitureResult ?? 0}
    set {_humitureResult = newValue}
  }
  /// Returns true if `humitureResult` has been explicitly set.
  var hasHumitureResult: Bool {return self._humitureResult != nil}
  /// Clears the value of `humitureResult`. Subsequent reads from it will return its default value.
  mutating func clearHumitureResult() {self._humitureResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _gsensorResult: UInt32? = nil
  fileprivate var _gsensorChipID: UInt32? = nil
  fileprivate var _ppgResult: UInt32? = nil
  fileprivate var _ecgResult: UInt32? = nil
  fileprivate var _bpResult: UInt32? = nil
  fileprivate var _tempratureResult: UInt32? = nil
  fileprivate var _spiFlashResult: UInt32? = nil
  fileprivate var _encryptResult: UInt32? = nil
  fileprivate var _bpVersion: UInt32? = nil
  fileprivate var _oaqResult: UInt32? = nil
  fileprivate var _iaqResult: UInt32? = nil
  fileprivate var _humitureResult: UInt32? = nil
}

struct SensorTestResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var motorResult: UInt32 {
    get {return _motorResult ?? 0}
    set {_motorResult = newValue}
  }
  /// Returns true if `motorResult` has been explicitly set.
  var hasMotorResult: Bool {return self._motorResult != nil}
  /// Clears the value of `motorResult`. Subsequent reads from it will return its default value.
  mutating func clearMotorResult() {self._motorResult = nil}

  var lightResult: UInt32 {
    get {return _lightResult ?? 0}
    set {_lightResult = newValue}
  }
  /// Returns true if `lightResult` has been explicitly set.
  var hasLightResult: Bool {return self._lightResult != nil}
  /// Clears the value of `lightResult`. Subsequent reads from it will return its default value.
  mutating func clearLightResult() {self._lightResult = nil}

  var tempratureResult: UInt32 {
    get {return _tempratureResult ?? 0}
    set {_tempratureResult = newValue}
  }
  /// Returns true if `tempratureResult` has been explicitly set.
  var hasTempratureResult: Bool {return self._tempratureResult != nil}
  /// Clears the value of `tempratureResult`. Subsequent reads from it will return its default value.
  mutating func clearTempratureResult() {self._tempratureResult = nil}

  var hrResult: UInt32 {
    get {return _hrResult ?? 0}
    set {_hrResult = newValue}
  }
  /// Returns true if `hrResult` has been explicitly set.
  var hasHrResult: Bool {return self._hrResult != nil}
  /// Clears the value of `hrResult`. Subsequent reads from it will return its default value.
  mutating func clearHrResult() {self._hrResult = nil}

  var ecgTouchResult: UInt32 {
    get {return _ecgTouchResult ?? 0}
    set {_ecgTouchResult = newValue}
  }
  /// Returns true if `ecgTouchResult` has been explicitly set.
  var hasEcgTouchResult: Bool {return self._ecgTouchResult != nil}
  /// Clears the value of `ecgTouchResult`. Subsequent reads from it will return its default value.
  mutating func clearEcgTouchResult() {self._ecgTouchResult = nil}

  var hrvResult: UInt32 {
    get {return _hrvResult ?? 0}
    set {_hrvResult = newValue}
  }
  /// Returns true if `hrvResult` has been explicitly set.
  var hasHrvResult: Bool {return self._hrvResult != nil}
  /// Clears the value of `hrvResult`. Subsequent reads from it will return its default value.
  mutating func clearHrvResult() {self._hrvResult = nil}

  var lcdResult: UInt32 {
    get {return _lcdResult ?? 0}
    set {_lcdResult = newValue}
  }
  /// Returns true if `lcdResult` has been explicitly set.
  var hasLcdResult: Bool {return self._lcdResult != nil}
  /// Clears the value of `lcdResult`. Subsequent reads from it will return its default value.
  mutating func clearLcdResult() {self._lcdResult = nil}

  var tpResult: UInt32 {
    get {return _tpResult ?? 0}
    set {_tpResult = newValue}
  }
  /// Returns true if `tpResult` has been explicitly set.
  var hasTpResult: Bool {return self._tpResult != nil}
  /// Clears the value of `tpResult`. Subsequent reads from it will return its default value.
  mutating func clearTpResult() {self._tpResult = nil}

  var gpsResult: UInt32 {
    get {return _gpsResult ?? 0}
    set {_gpsResult = newValue}
  }
  /// Returns true if `gpsResult` has been explicitly set.
  var hasGpsResult: Bool {return self._gpsResult != nil}
  /// Clears the value of `gpsResult`. Subsequent reads from it will return its default value.
  mutating func clearGpsResult() {self._gpsResult = nil}

  var biozResult: UInt32 {
    get {return _biozResult ?? 0}
    set {_biozResult = newValue}
  }
  /// Returns true if `biozResult` has been explicitly set.
  var hasBiozResult: Bool {return self._biozResult != nil}
  /// Clears the value of `biozResult`. Subsequent reads from it will return its default value.
  mutating func clearBiozResult() {self._biozResult = nil}

  var max32664LeakResult: UInt32 {
    get {return _max32664LeakResult ?? 0}
    set {_max32664LeakResult = newValue}
  }
  /// Returns true if `max32664LeakResult` has been explicitly set.
  var hasMax32664LeakResult: Bool {return self._max32664LeakResult != nil}
  /// Clears the value of `max32664LeakResult`. Subsequent reads from it will return its default value.
  mutating func clearMax32664LeakResult() {self._max32664LeakResult = nil}

  var hrLeakResult: UInt32 {
    get {return _hrLeakResult ?? 0}
    set {_hrLeakResult = newValue}
  }
  /// Returns true if `hrLeakResult` has been explicitly set.
  var hasHrLeakResult: Bool {return self._hrLeakResult != nil}
  /// Clears the value of `hrLeakResult`. Subsequent reads from it will return its default value.
  mutating func clearHrLeakResult() {self._hrLeakResult = nil}

  var greyCardResult: UInt32 {
    get {return _greyCardResult ?? 0}
    set {_greyCardResult = newValue}
  }
  /// Returns true if `greyCardResult` has been explicitly set.
  var hasGreyCardResult: Bool {return self._greyCardResult != nil}
  /// Clears the value of `greyCardResult`. Subsequent reads from it will return its default value.
  mutating func clearGreyCardResult() {self._greyCardResult = nil}

  var gsensorResult: UInt32 {
    get {return _gsensorResult ?? 0}
    set {_gsensorResult = newValue}
  }
  /// Returns true if `gsensorResult` has been explicitly set.
  var hasGsensorResult: Bool {return self._gsensorResult != nil}
  /// Clears the value of `gsensorResult`. Subsequent reads from it will return its default value.
  mutating func clearGsensorResult() {self._gsensorResult = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _motorResult: UInt32? = nil
  fileprivate var _lightResult: UInt32? = nil
  fileprivate var _tempratureResult: UInt32? = nil
  fileprivate var _hrResult: UInt32? = nil
  fileprivate var _ecgTouchResult: UInt32? = nil
  fileprivate var _hrvResult: UInt32? = nil
  fileprivate var _lcdResult: UInt32? = nil
  fileprivate var _tpResult: UInt32? = nil
  fileprivate var _gpsResult: UInt32? = nil
  fileprivate var _biozResult: UInt32? = nil
  fileprivate var _max32664LeakResult: UInt32? = nil
  fileprivate var _hrLeakResult: UInt32? = nil
  fileprivate var _greyCardResult: UInt32? = nil
  fileprivate var _gsensorResult: UInt32? = nil
}

struct FactoryTestNotify {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mode: FactoryTestMode {
    get {return _storage._mode ?? .dischargeMode}
    set {_uniqueStorage()._mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  var hasMode: Bool {return _storage._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  mutating func clearMode() {_uniqueStorage()._mode = nil}

  var operation: TestOperation {
    get {return _storage._operation ?? .testStart}
    set {_uniqueStorage()._operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  var hasOperation: Bool {return _storage._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  mutating func clearOperation() {_uniqueStorage()._operation = nil}

  var sensorResult: SensorTestResult {
    get {return _storage._sensorResult ?? SensorTestResult()}
    set {_uniqueStorage()._sensorResult = newValue}
  }
  /// Returns true if `sensorResult` has been explicitly set.
  var hasSensorResult: Bool {return _storage._sensorResult != nil}
  /// Clears the value of `sensorResult`. Subsequent reads from it will return its default value.
  mutating func clearSensorResult() {_uniqueStorage()._sensorResult = nil}

  var pressureHour: UInt32 {
    get {return _storage._pressureHour ?? 0}
    set {_uniqueStorage()._pressureHour = newValue}
  }
  /// Returns true if `pressureHour` has been explicitly set.
  var hasPressureHour: Bool {return _storage._pressureHour != nil}
  /// Clears the value of `pressureHour`. Subsequent reads from it will return its default value.
  mutating func clearPressureHour() {_uniqueStorage()._pressureHour = nil}

  var placementHour: UInt32 {
    get {return _storage._placementHour ?? 0}
    set {_uniqueStorage()._placementHour = newValue}
  }
  /// Returns true if `placementHour` has been explicitly set.
  var hasPlacementHour: Bool {return _storage._placementHour != nil}
  /// Clears the value of `placementHour`. Subsequent reads from it will return its default value.
  mutating func clearPlacementHour() {_uniqueStorage()._placementHour = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct FactoryTestConfim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mode: FactoryTestMode {
    get {return _storage._mode ?? .dischargeMode}
    set {_uniqueStorage()._mode = newValue}
  }
  /// Returns true if `mode` has been explicitly set.
  var hasMode: Bool {return _storage._mode != nil}
  /// Clears the value of `mode`. Subsequent reads from it will return its default value.
  mutating func clearMode() {_uniqueStorage()._mode = nil}

  var ret: Bool {
    get {return _storage._ret ?? false}
    set {_uniqueStorage()._ret = newValue}
  }
  /// Returns true if `ret` has been explicitly set.
  var hasRet: Bool {return _storage._ret != nil}
  /// Clears the value of `ret`. Subsequent reads from it will return its default value.
  mutating func clearRet() {_uniqueStorage()._ret = nil}

  var operation: TestOperation {
    get {return _storage._operation ?? .testStart}
    set {_uniqueStorage()._operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  var hasOperation: Bool {return _storage._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  mutating func clearOperation() {_uniqueStorage()._operation = nil}

  var params: OneOf_Params? {
    get {return _storage._params}
    set {_uniqueStorage()._params = newValue}
  }

  var dischargeResult: DischargeTestResult {
    get {
      if case .dischargeResult(let v)? = _storage._params {return v}
      return DischargeTestResult()
    }
    set {_uniqueStorage()._params = .dischargeResult(newValue)}
  }

  var chargeResult: ChargeTestResult {
    get {
      if case .chargeResult(let v)? = _storage._params {return v}
      return ChargeTestResult()
    }
    set {_uniqueStorage()._params = .chargeResult(newValue)}
  }

  var pressureResult: PressureTestResult {
    get {
      if case .pressureResult(let v)? = _storage._params {return v}
      return PressureTestResult()
    }
    set {_uniqueStorage()._params = .pressureResult(newValue)}
  }

  var placementResult: PlacementTestResult {
    get {
      if case .placementResult(let v)? = _storage._params {return v}
      return PlacementTestResult()
    }
    set {_uniqueStorage()._params = .placementResult(newValue)}
  }

  var autoResult: AutoTestResult {
    get {
      if case .autoResult(let v)? = _storage._params {return v}
      return AutoTestResult()
    }
    set {_uniqueStorage()._params = .autoResult(newValue)}
  }

  var sensorResult: SensorTestResult {
    get {
      if case .sensorResult(let v)? = _storage._params {return v}
      return SensorTestResult()
    }
    set {_uniqueStorage()._params = .sensorResult(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Params: Equatable {
    case dischargeResult(DischargeTestResult)
    case chargeResult(ChargeTestResult)
    case pressureResult(PressureTestResult)
    case placementResult(PlacementTestResult)
    case autoResult(AutoTestResult)
    case sensorResult(SensorTestResult)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .dischargeResult: return {
        guard case .dischargeResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .chargeResult: return {
        guard case .chargeResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .pressureResult: return {
        guard case .pressureResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .placementResult: return {
        guard case .placementResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .autoResult: return {
        guard case .autoResult(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      default: return true
      }
    }

  #if !swift(>=4.1)
    static func ==(lhs: FactoryTestConfim.OneOf_Params, rhs: FactoryTestConfim.OneOf_Params) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.dischargeResult, .dischargeResult): return {
        guard case .dischargeResult(let l) = lhs, case .dischargeResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.chargeResult, .chargeResult): return {
        guard case .chargeResult(let l) = lhs, case .chargeResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.pressureResult, .pressureResult): return {
        guard case .pressureResult(let l) = lhs, case .pressureResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.placementResult, .placementResult): return {
        guard case .placementResult(let l) = lhs, case .placementResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.autoResult, .autoResult): return {
        guard case .autoResult(let l) = lhs, case .autoResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sensorResult, .sensorResult): return {
        guard case .sensorResult(let l) = lhs, case .sensorResult(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

#if swift(>=5.5) && canImport(_Concurrency)
extension FactoryTestMode: @unchecked Sendable {}
extension TestOperation: @unchecked Sendable {}
extension PlacementTestResult: @unchecked Sendable {}
extension ChargeTestResult: @unchecked Sendable {}
extension DischargeTestResult: @unchecked Sendable {}
extension PressureTestResult: @unchecked Sendable {}
extension AutoTestResult: @unchecked Sendable {}
extension SensorTestResult: @unchecked Sendable {}
extension FactoryTestNotify: @unchecked Sendable {}
extension FactoryTestConfim: @unchecked Sendable {}
extension FactoryTestConfim.OneOf_Params: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension FactoryTestMode: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "DISCHARGE_MODE"),
    1: .same(proto: "CHARGING_MODE"),
    2: .same(proto: "PRESSURE_MODE"),
    3: .same(proto: "PLACE_MODE"),
    4: .same(proto: "SENSOR_MODE"),
    5: .same(proto: "AUTO_TEST_MODE"),
    6: .same(proto: "FULLY_AUTO_RESULT_MODE"),
  ]
}

extension TestOperation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TEST_START"),
    1: .same(proto: "TEST_STOP"),
    2: .same(proto: "TEST_RESULT"),
    3: .same(proto: "TEST_LAST_RESULT"),
  ]
}

extension PlacementTestResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PlacementTestResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "placement_times"),
    2: .standard(proto: "placement_result"),
  ]

  public var isInitialized: Bool {
    if self._placementResult == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedSFixed32Field(value: &self.placementTimes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._placementResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.placementTimes.isEmpty {
      try visitor.visitPackedSFixed32Field(value: self.placementTimes, fieldNumber: 1)
    }
    try { if let v = self._placementResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PlacementTestResult, rhs: PlacementTestResult) -> Bool {
    if lhs.placementTimes != rhs.placementTimes {return false}
    if lhs._placementResult != rhs._placementResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ChargeTestResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ChargeTestResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "charge_times"),
    2: .standard(proto: "charge_result"),
  ]

  public var isInitialized: Bool {
    if self._chargeResult == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedSFixed32Field(value: &self.chargeTimes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._chargeResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.chargeTimes.isEmpty {
      try visitor.visitPackedSFixed32Field(value: self.chargeTimes, fieldNumber: 1)
    }
    try { if let v = self._chargeResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ChargeTestResult, rhs: ChargeTestResult) -> Bool {
    if lhs.chargeTimes != rhs.chargeTimes {return false}
    if lhs._chargeResult != rhs._chargeResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DischargeTestResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DischargeTestResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "discharge_times"),
    2: .standard(proto: "discharge_result"),
  ]

  public var isInitialized: Bool {
    if self._dischargeResult == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedSFixed32Field(value: &self.dischargeTimes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._dischargeResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.dischargeTimes.isEmpty {
      try visitor.visitPackedSFixed32Field(value: self.dischargeTimes, fieldNumber: 1)
    }
    try { if let v = self._dischargeResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DischargeTestResult, rhs: DischargeTestResult) -> Bool {
    if lhs.dischargeTimes != rhs.dischargeTimes {return false}
    if lhs._dischargeResult != rhs._dischargeResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension PressureTestResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "PressureTestResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pressure_times"),
    2: .standard(proto: "pressure_result"),
  ]

  public var isInitialized: Bool {
    if self._pressureResult == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedSFixed32Field(value: &self.pressureTimes) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._pressureResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.pressureTimes.isEmpty {
      try visitor.visitPackedSFixed32Field(value: self.pressureTimes, fieldNumber: 1)
    }
    try { if let v = self._pressureResult {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: PressureTestResult, rhs: PressureTestResult) -> Bool {
    if lhs.pressureTimes != rhs.pressureTimes {return false}
    if lhs._pressureResult != rhs._pressureResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AutoTestResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AutoTestResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "gsensor_result"),
    2: .standard(proto: "gsensor_chip_id"),
    3: .standard(proto: "ppg_result"),
    4: .standard(proto: "ecg_result"),
    5: .standard(proto: "bp_result"),
    6: .standard(proto: "temprature_result"),
    7: .standard(proto: "spi_flash_result"),
    8: .standard(proto: "encrypt_result"),
    9: .standard(proto: "bp_version"),
    10: .standard(proto: "oaq_result"),
    11: .standard(proto: "iaq_result"),
    12: .standard(proto: "humiture_result"),
  ]

  public var isInitialized: Bool {
    if self._gsensorResult == nil {return false}
    if self._gsensorChipID == nil {return false}
    if self._ppgResult == nil {return false}
    if self._ecgResult == nil {return false}
    if self._bpResult == nil {return false}
    if self._tempratureResult == nil {return false}
    if self._spiFlashResult == nil {return false}
    if self._encryptResult == nil {return false}
    if self._bpVersion == nil {return false}
    if self._oaqResult == nil {return false}
    if self._iaqResult == nil {return false}
    if self._humitureResult == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._gsensorResult) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._gsensorChipID) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._ppgResult) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._ecgResult) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self._bpResult) }()
      case 6: try { try decoder.decodeSingularFixed32Field(value: &self._tempratureResult) }()
      case 7: try { try decoder.decodeSingularFixed32Field(value: &self._spiFlashResult) }()
      case 8: try { try decoder.decodeSingularFixed32Field(value: &self._encryptResult) }()
      case 9: try { try decoder.decodeSingularFixed32Field(value: &self._bpVersion) }()
      case 10: try { try decoder.decodeSingularFixed32Field(value: &self._oaqResult) }()
      case 11: try { try decoder.decodeSingularFixed32Field(value: &self._iaqResult) }()
      case 12: try { try decoder.decodeSingularFixed32Field(value: &self._humitureResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._gsensorResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._gsensorChipID {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._ppgResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._ecgResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._bpResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._tempratureResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._spiFlashResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._encryptResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._bpVersion {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._oaqResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._iaqResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._humitureResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AutoTestResult, rhs: AutoTestResult) -> Bool {
    if lhs._gsensorResult != rhs._gsensorResult {return false}
    if lhs._gsensorChipID != rhs._gsensorChipID {return false}
    if lhs._ppgResult != rhs._ppgResult {return false}
    if lhs._ecgResult != rhs._ecgResult {return false}
    if lhs._bpResult != rhs._bpResult {return false}
    if lhs._tempratureResult != rhs._tempratureResult {return false}
    if lhs._spiFlashResult != rhs._spiFlashResult {return false}
    if lhs._encryptResult != rhs._encryptResult {return false}
    if lhs._bpVersion != rhs._bpVersion {return false}
    if lhs._oaqResult != rhs._oaqResult {return false}
    if lhs._iaqResult != rhs._iaqResult {return false}
    if lhs._humitureResult != rhs._humitureResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SensorTestResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SensorTestResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "motor_result"),
    2: .standard(proto: "light_result"),
    3: .standard(proto: "temprature_result"),
    4: .standard(proto: "hr_result"),
    5: .standard(proto: "ecg_touch_result"),
    6: .standard(proto: "hrv_result"),
    7: .standard(proto: "lcd_result"),
    8: .standard(proto: "tp_result"),
    9: .standard(proto: "gps_result"),
    10: .standard(proto: "bioz_result"),
    11: .standard(proto: "max32664_leak_result"),
    12: .standard(proto: "hr_leak_result"),
    13: .standard(proto: "grey_card_result"),
    14: .standard(proto: "gsensor_result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._motorResult) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._lightResult) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._tempratureResult) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._hrResult) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self._ecgTouchResult) }()
      case 6: try { try decoder.decodeSingularFixed32Field(value: &self._hrvResult) }()
      case 7: try { try decoder.decodeSingularFixed32Field(value: &self._lcdResult) }()
      case 8: try { try decoder.decodeSingularFixed32Field(value: &self._tpResult) }()
      case 9: try { try decoder.decodeSingularFixed32Field(value: &self._gpsResult) }()
      case 10: try { try decoder.decodeSingularFixed32Field(value: &self._biozResult) }()
      case 11: try { try decoder.decodeSingularFixed32Field(value: &self._max32664LeakResult) }()
      case 12: try { try decoder.decodeSingularFixed32Field(value: &self._hrLeakResult) }()
      case 13: try { try decoder.decodeSingularFixed32Field(value: &self._greyCardResult) }()
      case 14: try { try decoder.decodeSingularFixed32Field(value: &self._gsensorResult) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._motorResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._lightResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._tempratureResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._hrResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._ecgTouchResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._hrvResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._lcdResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._tpResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._gpsResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._biozResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._max32664LeakResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._hrLeakResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._greyCardResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 13)
    } }()
    try { if let v = self._gsensorResult {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 14)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SensorTestResult, rhs: SensorTestResult) -> Bool {
    if lhs._motorResult != rhs._motorResult {return false}
    if lhs._lightResult != rhs._lightResult {return false}
    if lhs._tempratureResult != rhs._tempratureResult {return false}
    if lhs._hrResult != rhs._hrResult {return false}
    if lhs._ecgTouchResult != rhs._ecgTouchResult {return false}
    if lhs._hrvResult != rhs._hrvResult {return false}
    if lhs._lcdResult != rhs._lcdResult {return false}
    if lhs._tpResult != rhs._tpResult {return false}
    if lhs._gpsResult != rhs._gpsResult {return false}
    if lhs._biozResult != rhs._biozResult {return false}
    if lhs._max32664LeakResult != rhs._max32664LeakResult {return false}
    if lhs._hrLeakResult != rhs._hrLeakResult {return false}
    if lhs._greyCardResult != rhs._greyCardResult {return false}
    if lhs._gsensorResult != rhs._gsensorResult {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FactoryTestNotify: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FactoryTestNotify"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .same(proto: "operation"),
    3: .standard(proto: "Sensor_Result"),
    4: .standard(proto: "pressure_hour"),
    5: .standard(proto: "Placement_hour"),
  ]

  fileprivate class _StorageClass {
    var _mode: FactoryTestMode? = nil
    var _operation: TestOperation? = nil
    var _sensorResult: SensorTestResult? = nil
    var _pressureHour: UInt32? = nil
    var _placementHour: UInt32? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _mode = source._mode
      _operation = source._operation
      _sensorResult = source._sensorResult
      _pressureHour = source._pressureHour
      _placementHour = source._placementHour
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._mode == nil {return false}
      if _storage._operation == nil {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._mode) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._operation) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._sensorResult) }()
        case 4: try { try decoder.decodeSingularFixed32Field(value: &_storage._pressureHour) }()
        case 5: try { try decoder.decodeSingularFixed32Field(value: &_storage._placementHour) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._mode {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._operation {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._sensorResult {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._pressureHour {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._placementHour {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FactoryTestNotify, rhs: FactoryTestNotify) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._mode != rhs_storage._mode {return false}
        if _storage._operation != rhs_storage._operation {return false}
        if _storage._sensorResult != rhs_storage._sensorResult {return false}
        if _storage._pressureHour != rhs_storage._pressureHour {return false}
        if _storage._placementHour != rhs_storage._placementHour {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FactoryTestConfim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FactoryTestConfim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mode"),
    2: .same(proto: "ret"),
    3: .same(proto: "operation"),
    4: .standard(proto: "discharge_Result"),
    5: .standard(proto: "charge_Result"),
    6: .standard(proto: "pressure_Result"),
    7: .standard(proto: "placement_Result"),
    8: .standard(proto: "Auto_Result"),
    9: .standard(proto: "Sensor_Result"),
  ]

  fileprivate class _StorageClass {
    var _mode: FactoryTestMode? = nil
    var _ret: Bool? = nil
    var _operation: TestOperation? = nil
    var _params: FactoryTestConfim.OneOf_Params?

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _mode = source._mode
      _ret = source._ret
      _operation = source._operation
      _params = source._params
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._mode == nil {return false}
      if _storage._ret == nil {return false}
      if _storage._operation == nil {return false}
      if let v = _storage._params, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._mode) }()
        case 2: try { try decoder.decodeSingularBoolField(value: &_storage._ret) }()
        case 3: try { try decoder.decodeSingularEnumField(value: &_storage._operation) }()
        case 4: try {
          var v: DischargeTestResult?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .dischargeResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .dischargeResult(v)
          }
        }()
        case 5: try {
          var v: ChargeTestResult?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .chargeResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .chargeResult(v)
          }
        }()
        case 6: try {
          var v: PressureTestResult?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .pressureResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .pressureResult(v)
          }
        }()
        case 7: try {
          var v: PlacementTestResult?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .placementResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .placementResult(v)
          }
        }()
        case 8: try {
          var v: AutoTestResult?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .autoResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .autoResult(v)
          }
        }()
        case 9: try {
          var v: SensorTestResult?
          var hadOneofValue = false
          if let current = _storage._params {
            hadOneofValue = true
            if case .sensorResult(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {
            if hadOneofValue {try decoder.handleConflictingOneOf()}
            _storage._params = .sensorResult(v)
          }
        }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._mode {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._ret {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._operation {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
      } }()
      switch _storage._params {
      case .dischargeResult?: try {
        guard case .dischargeResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }()
      case .chargeResult?: try {
        guard case .chargeResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }()
      case .pressureResult?: try {
        guard case .pressureResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      }()
      case .placementResult?: try {
        guard case .placementResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }()
      case .autoResult?: try {
        guard case .autoResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      }()
      case .sensorResult?: try {
        guard case .sensorResult(let v)? = _storage._params else { preconditionFailure() }
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      }()
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FactoryTestConfim, rhs: FactoryTestConfim) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._mode != rhs_storage._mode {return false}
        if _storage._ret != rhs_storage._ret {return false}
        if _storage._operation != rhs_storage._operation {return false}
        if _storage._params != rhs_storage._params {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
