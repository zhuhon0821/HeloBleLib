// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: c110_cmd.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum C110Operation: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case read // = 0
  case write // = 1

  init() {
    self = .read
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .read
    case 1: self = .write
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .read: return 0
    case .write: return 1
    }
  }

}

#if swift(>=4.2)

extension C110Operation: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum C110AQI: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case good // = 0
  case normal // = 1
  case bad // = 2
  case worst // = 3

  init() {
    self = .good
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .good
    case 1: self = .normal
    case 2: self = .bad
    case 3: self = .worst
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .good: return 0
    case .normal: return 1
    case .bad: return 2
    case .worst: return 3
    }
  }

}

#if swift(>=4.2)

extension C110AQI: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum C110EcgSymptom: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case sinusRhythm // = 0
  case sinusArhythmia // = 1
  case sinusTachycardia // = 2
  case sinusBradycardia // = 3
  case atrialFibrillation // = 4
  case atrialFlutter // = 5
  case atrialPrematureBeats // = 6
  case ventricularPrematureBeats // = 7
  case leftVentricularHypertrophy // = 8
  case rightBundleBranchBlock // = 9
  case leftBundleBranchBlock // = 10

  init() {
    self = .sinusRhythm
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sinusRhythm
    case 1: self = .sinusArhythmia
    case 2: self = .sinusTachycardia
    case 3: self = .sinusBradycardia
    case 4: self = .atrialFibrillation
    case 5: self = .atrialFlutter
    case 6: self = .atrialPrematureBeats
    case 7: self = .ventricularPrematureBeats
    case 8: self = .leftVentricularHypertrophy
    case 9: self = .rightBundleBranchBlock
    case 10: self = .leftBundleBranchBlock
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .sinusRhythm: return 0
    case .sinusArhythmia: return 1
    case .sinusTachycardia: return 2
    case .sinusBradycardia: return 3
    case .atrialFibrillation: return 4
    case .atrialFlutter: return 5
    case .atrialPrematureBeats: return 6
    case .ventricularPrematureBeats: return 7
    case .leftVentricularHypertrophy: return 8
    case .rightBundleBranchBlock: return 9
    case .leftBundleBranchBlock: return 10
    }
  }

}

#if swift(>=4.2)

extension C110EcgSymptom: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum HealthAlarmState: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case notifyAndPrompt // = 0
  case notifyAndNoPrompt // = 1
  case noNotifyAndPrompt // = 2
  case noNotifyAndNoPrompt // = 3

  init() {
    self = .notifyAndPrompt
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .notifyAndPrompt
    case 1: self = .notifyAndNoPrompt
    case 2: self = .noNotifyAndPrompt
    case 3: self = .noNotifyAndNoPrompt
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .notifyAndPrompt: return 0
    case .notifyAndNoPrompt: return 1
    case .noNotifyAndPrompt: return 2
    case .noNotifyAndNoPrompt: return 3
    }
  }

}

#if swift(>=4.2)

extension HealthAlarmState: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum HealthAlarmType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case hrAlarm // = 0
  case breathAlarm // = 1
  case bpAlarm // = 2
  case spo2Alarm // = 3
  case tempAlarm // = 4
  case fallAlarm // = 5
  case afAlarm // = 6

  init() {
    self = .hrAlarm
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .hrAlarm
    case 1: self = .breathAlarm
    case 2: self = .bpAlarm
    case 3: self = .spo2Alarm
    case 4: self = .tempAlarm
    case 5: self = .fallAlarm
    case 6: self = .afAlarm
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .hrAlarm: return 0
    case .breathAlarm: return 1
    case .bpAlarm: return 2
    case .spo2Alarm: return 3
    case .tempAlarm: return 4
    case .fallAlarm: return 5
    case .afAlarm: return 6
    }
  }

}

#if swift(>=4.2)

extension HealthAlarmType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct C110BodyData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///0.0 - 99.9 
  var bmi: Float {
    get {return _bmi ?? 0}
    set {_bmi = newValue}
  }
  /// Returns true if `bmi` has been explicitly set.
  var hasBmi: Bool {return self._bmi != nil}
  /// Clears the value of `bmi`. Subsequent reads from it will return its default value.
  mutating func clearBmi() {self._bmi = nil}

  ///0.0 - 9999.9 
  var bmr: Float {
    get {return _bmr ?? 0}
    set {_bmr = newValue}
  }
  /// Returns true if `bmr` has been explicitly set.
  var hasBmr: Bool {return self._bmr != nil}
  /// Clears the value of `bmr`. Subsequent reads from it will return its default value.
  mutating func clearBmr() {self._bmr = nil}

  ///0.0% - 99.9
  var bodyFat: Float {
    get {return _bodyFat ?? 0}
    set {_bodyFat = newValue}
  }
  /// Returns true if `bodyFat` has been explicitly set.
  var hasBodyFat: Bool {return self._bodyFat != nil}
  /// Clears the value of `bodyFat`. Subsequent reads from it will return its default value.
  mutating func clearBodyFat() {self._bodyFat = nil}

  ///0.0 - 99.9
  var visceralFatLevel: Float {
    get {return _visceralFatLevel ?? 0}
    set {_visceralFatLevel = newValue}
  }
  /// Returns true if `visceralFatLevel` has been explicitly set.
  var hasVisceralFatLevel: Bool {return self._visceralFatLevel != nil}
  /// Clears the value of `visceralFatLevel`. Subsequent reads from it will return its default value.
  mutating func clearVisceralFatLevel() {self._visceralFatLevel = nil}

  ///0.0 - 99.9
  var muscleMass: Float {
    get {return _muscleMass ?? 0}
    set {_muscleMass = newValue}
  }
  /// Returns true if `muscleMass` has been explicitly set.
  var hasMuscleMass: Bool {return self._muscleMass != nil}
  /// Clears the value of `muscleMass`. Subsequent reads from it will return its default value.
  mutating func clearMuscleMass() {self._muscleMass = nil}

  ///0.0 - 99.9
  var boneMass: Float {
    get {return _boneMass ?? 0}
    set {_boneMass = newValue}
  }
  /// Returns true if `boneMass` has been explicitly set.
  var hasBoneMass: Bool {return self._boneMass != nil}
  /// Clears the value of `boneMass`. Subsequent reads from it will return its default value.
  mutating func clearBoneMass() {self._boneMass = nil}

  ///0.0 - 999.9 
  var weight: Float {
    get {return _weight ?? 0}
    set {_weight = newValue}
  }
  /// Returns true if `weight` has been explicitly set.
  var hasWeight: Bool {return self._weight != nil}
  /// Clears the value of `weight`. Subsequent reads from it will return its default value.
  mutating func clearWeight() {self._weight = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bmi: Float? = nil
  fileprivate var _bmr: Float? = nil
  fileprivate var _bodyFat: Float? = nil
  fileprivate var _visceralFatLevel: Float? = nil
  fileprivate var _muscleMass: Float? = nil
  fileprivate var _boneMass: Float? = nil
  fileprivate var _weight: Float? = nil
}

struct LifeQualityData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var wellNessValue: UInt32 {
    get {return _wellNessValue ?? 0}
    set {_wellNessValue = newValue}
  }
  /// Returns true if `wellNessValue` has been explicitly set.
  var hasWellNessValue: Bool {return self._wellNessValue != nil}
  /// Clears the value of `wellNessValue`. Subsequent reads from it will return its default value.
  mutating func clearWellNessValue() {self._wellNessValue = nil}

  var activityValue: UInt32 {
    get {return _activityValue ?? 0}
    set {_activityValue = newValue}
  }
  /// Returns true if `activityValue` has been explicitly set.
  var hasActivityValue: Bool {return self._activityValue != nil}
  /// Clears the value of `activityValue`. Subsequent reads from it will return its default value.
  mutating func clearActivityValue() {self._activityValue = nil}

  var moodSwingsValue: UInt32 {
    get {return _moodSwingsValue ?? 0}
    set {_moodSwingsValue = newValue}
  }
  /// Returns true if `moodSwingsValue` has been explicitly set.
  var hasMoodSwingsValue: Bool {return self._moodSwingsValue != nil}
  /// Clears the value of `moodSwingsValue`. Subsequent reads from it will return its default value.
  mutating func clearMoodSwingsValue() {self._moodSwingsValue = nil}

  var lifestyleIndexValue: UInt32 {
    get {return _lifestyleIndexValue ?? 0}
    set {_lifestyleIndexValue = newValue}
  }
  /// Returns true if `lifestyleIndexValue` has been explicitly set.
  var hasLifestyleIndexValue: Bool {return self._lifestyleIndexValue != nil}
  /// Clears the value of `lifestyleIndexValue`. Subsequent reads from it will return its default value.
  mutating func clearLifestyleIndexValue() {self._lifestyleIndexValue = nil}

  var time: RtTime {
    get {return _time ?? RtTime()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _wellNessValue: UInt32? = nil
  fileprivate var _activityValue: UInt32? = nil
  fileprivate var _moodSwingsValue: UInt32? = nil
  fileprivate var _lifestyleIndexValue: UInt32? = nil
  fileprivate var _time: RtTime? = nil
}

struct DailyMeasure {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timeStamp: DateTime {
    get {return _timeStamp ?? DateTime()}
    set {_timeStamp = newValue}
  }
  /// Returns true if `timeStamp` has been explicitly set.
  var hasTimeStamp: Bool {return self._timeStamp != nil}
  /// Clears the value of `timeStamp`. Subsequent reads from it will return its default value.
  mutating func clearTimeStamp() {self._timeStamp = nil}

  var measures: UInt32 {
    get {return _measures ?? 0}
    set {_measures = newValue}
  }
  /// Returns true if `measures` has been explicitly set.
  var hasMeasures: Bool {return self._measures != nil}
  /// Clears the value of `measures`. Subsequent reads from it will return its default value.
  mutating func clearMeasures() {self._measures = nil}

  var blocks: UInt32 {
    get {return _blocks ?? 0}
    set {_blocks = newValue}
  }
  /// Returns true if `blocks` has been explicitly set.
  var hasBlocks: Bool {return self._blocks != nil}
  /// Clears the value of `blocks`. Subsequent reads from it will return its default value.
  mutating func clearBlocks() {self._blocks = nil}

  var rewards: UInt32 {
    get {return _rewards ?? 0}
    set {_rewards = newValue}
  }
  /// Returns true if `rewards` has been explicitly set.
  var hasRewards: Bool {return self._rewards != nil}
  /// Clears the value of `rewards`. Subsequent reads from it will return its default value.
  mutating func clearRewards() {self._rewards = nil}

  var tokens: UInt32 {
    get {return _tokens ?? 0}
    set {_tokens = newValue}
  }
  /// Returns true if `tokens` has been explicitly set.
  var hasTokens: Bool {return self._tokens != nil}
  /// Clears the value of `tokens`. Subsequent reads from it will return its default value.
  mutating func clearTokens() {self._tokens = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _timeStamp: DateTime? = nil
  fileprivate var _measures: UInt32? = nil
  fileprivate var _blocks: UInt32? = nil
  fileprivate var _rewards: UInt32? = nil
  fileprivate var _tokens: UInt32? = nil
}

struct VyvoWallet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var totalMeasures: UInt32 {
    get {return _totalMeasures ?? 0}
    set {_totalMeasures = newValue}
  }
  /// Returns true if `totalMeasures` has been explicitly set.
  var hasTotalMeasures: Bool {return self._totalMeasures != nil}
  /// Clears the value of `totalMeasures`. Subsequent reads from it will return its default value.
  mutating func clearTotalMeasures() {self._totalMeasures = nil}

  var totalBlocks: UInt32 {
    get {return _totalBlocks ?? 0}
    set {_totalBlocks = newValue}
  }
  /// Returns true if `totalBlocks` has been explicitly set.
  var hasTotalBlocks: Bool {return self._totalBlocks != nil}
  /// Clears the value of `totalBlocks`. Subsequent reads from it will return its default value.
  mutating func clearTotalBlocks() {self._totalBlocks = nil}

  var totalRewards: UInt32 {
    get {return _totalRewards ?? 0}
    set {_totalRewards = newValue}
  }
  /// Returns true if `totalRewards` has been explicitly set.
  var hasTotalRewards: Bool {return self._totalRewards != nil}
  /// Clears the value of `totalRewards`. Subsequent reads from it will return its default value.
  mutating func clearTotalRewards() {self._totalRewards = nil}

  var totalTokens: UInt32 {
    get {return _totalTokens ?? 0}
    set {_totalTokens = newValue}
  }
  /// Returns true if `totalTokens` has been explicitly set.
  var hasTotalTokens: Bool {return self._totalTokens != nil}
  /// Clears the value of `totalTokens`. Subsequent reads from it will return its default value.
  mutating func clearTotalTokens() {self._totalTokens = nil}

  var dailyMeasure: [DailyMeasure] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _totalMeasures: UInt32? = nil
  fileprivate var _totalBlocks: UInt32? = nil
  fileprivate var _totalRewards: UInt32? = nil
  fileprivate var _totalTokens: UInt32? = nil
}

struct SOSAlarm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ret: UInt32 {
    get {return _ret ?? 0}
    set {_ret = newValue}
  }
  /// Returns true if `ret` has been explicitly set.
  var hasRet: Bool {return self._ret != nil}
  /// Clears the value of `ret`. Subsequent reads from it will return its default value.
  mutating func clearRet() {self._ret = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ret: UInt32? = nil
}

struct HrAlarm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hr: UInt32 {
    get {return _hr ?? 0}
    set {_hr = newValue}
  }
  /// Returns true if `hr` has been explicitly set.
  var hasHr: Bool {return self._hr != nil}
  /// Clears the value of `hr`. Subsequent reads from it will return its default value.
  mutating func clearHr() {self._hr = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hr: UInt32? = nil
}

struct BreathAlarm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var breath: UInt32 {
    get {return _breath ?? 0}
    set {_breath = newValue}
  }
  /// Returns true if `breath` has been explicitly set.
  var hasBreath: Bool {return self._breath != nil}
  /// Clears the value of `breath`. Subsequent reads from it will return its default value.
  mutating func clearBreath() {self._breath = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _breath: UInt32? = nil
}

struct BpAlarm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sbp: UInt32 {
    get {return _sbp ?? 0}
    set {_sbp = newValue}
  }
  /// Returns true if `sbp` has been explicitly set.
  var hasSbp: Bool {return self._sbp != nil}
  /// Clears the value of `sbp`. Subsequent reads from it will return its default value.
  mutating func clearSbp() {self._sbp = nil}

  var dbp: UInt32 {
    get {return _dbp ?? 0}
    set {_dbp = newValue}
  }
  /// Returns true if `dbp` has been explicitly set.
  var hasDbp: Bool {return self._dbp != nil}
  /// Clears the value of `dbp`. Subsequent reads from it will return its default value.
  mutating func clearDbp() {self._dbp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sbp: UInt32? = nil
  fileprivate var _dbp: UInt32? = nil
}

struct Spo2Alarm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var spo2: UInt32 {
    get {return _spo2 ?? 0}
    set {_spo2 = newValue}
  }
  /// Returns true if `spo2` has been explicitly set.
  var hasSpo2: Bool {return self._spo2 != nil}
  /// Clears the value of `spo2`. Subsequent reads from it will return its default value.
  mutating func clearSpo2() {self._spo2 = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _spo2: UInt32? = nil
}

struct FallAlarm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fallAlarm: Bool {
    get {return _fallAlarm ?? false}
    set {_fallAlarm = newValue}
  }
  /// Returns true if `fallAlarm` has been explicitly set.
  var hasFallAlarm: Bool {return self._fallAlarm != nil}
  /// Clears the value of `fallAlarm`. Subsequent reads from it will return its default value.
  mutating func clearFallAlarm() {self._fallAlarm = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fallAlarm: Bool? = nil
}

struct AfAlarm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var isAlarm: UInt32 {
    get {return _isAlarm ?? 0}
    set {_isAlarm = newValue}
  }
  /// Returns true if `isAlarm` has been explicitly set.
  var hasIsAlarm: Bool {return self._isAlarm != nil}
  /// Clears the value of `isAlarm`. Subsequent reads from it will return its default value.
  mutating func clearIsAlarm() {self._isAlarm = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _isAlarm: UInt32? = nil
}

struct TemperatureAlarm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var temperature: UInt32 {
    get {return _temperature ?? 0}
    set {_temperature = newValue}
  }
  /// Returns true if `temperature` has been explicitly set.
  var hasTemperature: Bool {return self._temperature != nil}
  /// Clears the value of `temperature`. Subsequent reads from it will return its default value.
  mutating func clearTemperature() {self._temperature = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _temperature: UInt32? = nil
}

struct HealthAlarmdata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var timeStamp: DateTime {
    get {return _timeStamp ?? DateTime()}
    set {_timeStamp = newValue}
  }
  /// Returns true if `timeStamp` has been explicitly set.
  var hasTimeStamp: Bool {return self._timeStamp != nil}
  /// Clears the value of `timeStamp`. Subsequent reads from it will return its default value.
  mutating func clearTimeStamp() {self._timeStamp = nil}

  var alarmType: HealthAlarmType {
    get {return _alarmType ?? .hrAlarm}
    set {_alarmType = newValue}
  }
  /// Returns true if `alarmType` has been explicitly set.
  var hasAlarmType: Bool {return self._alarmType != nil}
  /// Clears the value of `alarmType`. Subsequent reads from it will return its default value.
  mutating func clearAlarmType() {self._alarmType = nil}

  var alarmvalue: [UInt32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _timeStamp: DateTime? = nil
  fileprivate var _alarmType: HealthAlarmType? = nil
}

struct HealthAlarminfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var alarmdata: [HealthAlarmdata] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct HealthAlarm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var alarmSos: SOSAlarm {
    get {return _alarmSos ?? SOSAlarm()}
    set {_alarmSos = newValue}
  }
  /// Returns true if `alarmSos` has been explicitly set.
  var hasAlarmSos: Bool {return self._alarmSos != nil}
  /// Clears the value of `alarmSos`. Subsequent reads from it will return its default value.
  mutating func clearAlarmSos() {self._alarmSos = nil}

  var alarmHr: HrAlarm {
    get {return _alarmHr ?? HrAlarm()}
    set {_alarmHr = newValue}
  }
  /// Returns true if `alarmHr` has been explicitly set.
  var hasAlarmHr: Bool {return self._alarmHr != nil}
  /// Clears the value of `alarmHr`. Subsequent reads from it will return its default value.
  mutating func clearAlarmHr() {self._alarmHr = nil}

  var alarmBreath: BreathAlarm {
    get {return _alarmBreath ?? BreathAlarm()}
    set {_alarmBreath = newValue}
  }
  /// Returns true if `alarmBreath` has been explicitly set.
  var hasAlarmBreath: Bool {return self._alarmBreath != nil}
  /// Clears the value of `alarmBreath`. Subsequent reads from it will return its default value.
  mutating func clearAlarmBreath() {self._alarmBreath = nil}

  var alarmBp: BpAlarm {
    get {return _alarmBp ?? BpAlarm()}
    set {_alarmBp = newValue}
  }
  /// Returns true if `alarmBp` has been explicitly set.
  var hasAlarmBp: Bool {return self._alarmBp != nil}
  /// Clears the value of `alarmBp`. Subsequent reads from it will return its default value.
  mutating func clearAlarmBp() {self._alarmBp = nil}

  var alarmSpo2: Spo2Alarm {
    get {return _alarmSpo2 ?? Spo2Alarm()}
    set {_alarmSpo2 = newValue}
  }
  /// Returns true if `alarmSpo2` has been explicitly set.
  var hasAlarmSpo2: Bool {return self._alarmSpo2 != nil}
  /// Clears the value of `alarmSpo2`. Subsequent reads from it will return its default value.
  mutating func clearAlarmSpo2() {self._alarmSpo2 = nil}

  var alarmFall: FallAlarm {
    get {return _alarmFall ?? FallAlarm()}
    set {_alarmFall = newValue}
  }
  /// Returns true if `alarmFall` has been explicitly set.
  var hasAlarmFall: Bool {return self._alarmFall != nil}
  /// Clears the value of `alarmFall`. Subsequent reads from it will return its default value.
  mutating func clearAlarmFall() {self._alarmFall = nil}

  var alarmTemp: TemperatureAlarm {
    get {return _alarmTemp ?? TemperatureAlarm()}
    set {_alarmTemp = newValue}
  }
  /// Returns true if `alarmTemp` has been explicitly set.
  var hasAlarmTemp: Bool {return self._alarmTemp != nil}
  /// Clears the value of `alarmTemp`. Subsequent reads from it will return its default value.
  mutating func clearAlarmTemp() {self._alarmTemp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _alarmSos: SOSAlarm? = nil
  fileprivate var _alarmHr: HrAlarm? = nil
  fileprivate var _alarmBreath: BreathAlarm? = nil
  fileprivate var _alarmBp: BpAlarm? = nil
  fileprivate var _alarmSpo2: Spo2Alarm? = nil
  fileprivate var _alarmFall: FallAlarm? = nil
  fileprivate var _alarmTemp: TemperatureAlarm? = nil
}

struct HeartrateAlarmConf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hrHigh: UInt32 {
    get {return _hrHigh ?? 0}
    set {_hrHigh = newValue}
  }
  /// Returns true if `hrHigh` has been explicitly set.
  var hasHrHigh: Bool {return self._hrHigh != nil}
  /// Clears the value of `hrHigh`. Subsequent reads from it will return its default value.
  mutating func clearHrHigh() {self._hrHigh = nil}

  var hrBelow: UInt32 {
    get {return _hrBelow ?? 0}
    set {_hrBelow = newValue}
  }
  /// Returns true if `hrBelow` has been explicitly set.
  var hasHrBelow: Bool {return self._hrBelow != nil}
  /// Clears the value of `hrBelow`. Subsequent reads from it will return its default value.
  mutating func clearHrBelow() {self._hrBelow = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hrHigh: UInt32? = nil
  fileprivate var _hrBelow: UInt32? = nil
}

struct BreathAlarmConf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var breathHigh: UInt32 {
    get {return _breathHigh ?? 0}
    set {_breathHigh = newValue}
  }
  /// Returns true if `breathHigh` has been explicitly set.
  var hasBreathHigh: Bool {return self._breathHigh != nil}
  /// Clears the value of `breathHigh`. Subsequent reads from it will return its default value.
  mutating func clearBreathHigh() {self._breathHigh = nil}

  var breathBelow: UInt32 {
    get {return _breathBelow ?? 0}
    set {_breathBelow = newValue}
  }
  /// Returns true if `breathBelow` has been explicitly set.
  var hasBreathBelow: Bool {return self._breathBelow != nil}
  /// Clears the value of `breathBelow`. Subsequent reads from it will return its default value.
  mutating func clearBreathBelow() {self._breathBelow = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _breathHigh: UInt32? = nil
  fileprivate var _breathBelow: UInt32? = nil
}

struct BpAlarmConf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sbpHigh: UInt32 {
    get {return _sbpHigh ?? 0}
    set {_sbpHigh = newValue}
  }
  /// Returns true if `sbpHigh` has been explicitly set.
  var hasSbpHigh: Bool {return self._sbpHigh != nil}
  /// Clears the value of `sbpHigh`. Subsequent reads from it will return its default value.
  mutating func clearSbpHigh() {self._sbpHigh = nil}

  var sbpBelow: UInt32 {
    get {return _sbpBelow ?? 0}
    set {_sbpBelow = newValue}
  }
  /// Returns true if `sbpBelow` has been explicitly set.
  var hasSbpBelow: Bool {return self._sbpBelow != nil}
  /// Clears the value of `sbpBelow`. Subsequent reads from it will return its default value.
  mutating func clearSbpBelow() {self._sbpBelow = nil}

  var dbpHigh: UInt32 {
    get {return _dbpHigh ?? 0}
    set {_dbpHigh = newValue}
  }
  /// Returns true if `dbpHigh` has been explicitly set.
  var hasDbpHigh: Bool {return self._dbpHigh != nil}
  /// Clears the value of `dbpHigh`. Subsequent reads from it will return its default value.
  mutating func clearDbpHigh() {self._dbpHigh = nil}

  var dbpBelow: UInt32 {
    get {return _dbpBelow ?? 0}
    set {_dbpBelow = newValue}
  }
  /// Returns true if `dbpBelow` has been explicitly set.
  var hasDbpBelow: Bool {return self._dbpBelow != nil}
  /// Clears the value of `dbpBelow`. Subsequent reads from it will return its default value.
  mutating func clearDbpBelow() {self._dbpBelow = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _sbpHigh: UInt32? = nil
  fileprivate var _sbpBelow: UInt32? = nil
  fileprivate var _dbpHigh: UInt32? = nil
  fileprivate var _dbpBelow: UInt32? = nil
}

struct Spo2AlarmConf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var spo2Below: UInt32 {
    get {return _spo2Below ?? 0}
    set {_spo2Below = newValue}
  }
  /// Returns true if `spo2Below` has been explicitly set.
  var hasSpo2Below: Bool {return self._spo2Below != nil}
  /// Clears the value of `spo2Below`. Subsequent reads from it will return its default value.
  mutating func clearSpo2Below() {self._spo2Below = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _spo2Below: UInt32? = nil
}

struct FallAlarmConf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fallCheck: Bool {
    get {return _fallCheck ?? false}
    set {_fallCheck = newValue}
  }
  /// Returns true if `fallCheck` has been explicitly set.
  var hasFallCheck: Bool {return self._fallCheck != nil}
  /// Clears the value of `fallCheck`. Subsequent reads from it will return its default value.
  mutating func clearFallCheck() {self._fallCheck = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fallCheck: Bool? = nil
}

struct TemperatureAlarmConf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var tempHigh: UInt32 {
    get {return _tempHigh ?? 0}
    set {_tempHigh = newValue}
  }
  /// Returns true if `tempHigh` has been explicitly set.
  var hasTempHigh: Bool {return self._tempHigh != nil}
  /// Clears the value of `tempHigh`. Subsequent reads from it will return its default value.
  mutating func clearTempHigh() {self._tempHigh = nil}

  var tempBelow: UInt32 {
    get {return _tempBelow ?? 0}
    set {_tempBelow = newValue}
  }
  /// Returns true if `tempBelow` has been explicitly set.
  var hasTempBelow: Bool {return self._tempBelow != nil}
  /// Clears the value of `tempBelow`. Subsequent reads from it will return its default value.
  mutating func clearTempBelow() {self._tempBelow = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _tempHigh: UInt32? = nil
  fileprivate var _tempBelow: UInt32? = nil
}

struct HealthAlarmConf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var confHr: HeartrateAlarmConf {
    get {return _confHr ?? HeartrateAlarmConf()}
    set {_confHr = newValue}
  }
  /// Returns true if `confHr` has been explicitly set.
  var hasConfHr: Bool {return self._confHr != nil}
  /// Clears the value of `confHr`. Subsequent reads from it will return its default value.
  mutating func clearConfHr() {self._confHr = nil}

  var confBreath: BreathAlarmConf {
    get {return _confBreath ?? BreathAlarmConf()}
    set {_confBreath = newValue}
  }
  /// Returns true if `confBreath` has been explicitly set.
  var hasConfBreath: Bool {return self._confBreath != nil}
  /// Clears the value of `confBreath`. Subsequent reads from it will return its default value.
  mutating func clearConfBreath() {self._confBreath = nil}

  var confBp: BpAlarmConf {
    get {return _confBp ?? BpAlarmConf()}
    set {_confBp = newValue}
  }
  /// Returns true if `confBp` has been explicitly set.
  var hasConfBp: Bool {return self._confBp != nil}
  /// Clears the value of `confBp`. Subsequent reads from it will return its default value.
  mutating func clearConfBp() {self._confBp = nil}

  var confSpo2: Spo2AlarmConf {
    get {return _confSpo2 ?? Spo2AlarmConf()}
    set {_confSpo2 = newValue}
  }
  /// Returns true if `confSpo2` has been explicitly set.
  var hasConfSpo2: Bool {return self._confSpo2 != nil}
  /// Clears the value of `confSpo2`. Subsequent reads from it will return its default value.
  mutating func clearConfSpo2() {self._confSpo2 = nil}

  var confFall: FallAlarmConf {
    get {return _confFall ?? FallAlarmConf()}
    set {_confFall = newValue}
  }
  /// Returns true if `confFall` has been explicitly set.
  var hasConfFall: Bool {return self._confFall != nil}
  /// Clears the value of `confFall`. Subsequent reads from it will return its default value.
  mutating func clearConfFall() {self._confFall = nil}

  var confTemp: TemperatureAlarmConf {
    get {return _confTemp ?? TemperatureAlarmConf()}
    set {_confTemp = newValue}
  }
  /// Returns true if `confTemp` has been explicitly set.
  var hasConfTemp: Bool {return self._confTemp != nil}
  /// Clears the value of `confTemp`. Subsequent reads from it will return its default value.
  mutating func clearConfTemp() {self._confTemp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _confHr: HeartrateAlarmConf? = nil
  fileprivate var _confBreath: BreathAlarmConf? = nil
  fileprivate var _confBp: BpAlarmConf? = nil
  fileprivate var _confSpo2: Spo2AlarmConf? = nil
  fileprivate var _confFall: FallAlarmConf? = nil
  fileprivate var _confTemp: TemperatureAlarmConf? = nil
}

struct C110Data {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bodyData: C110BodyData {
    get {return _storage._bodyData ?? C110BodyData()}
    set {_uniqueStorage()._bodyData = newValue}
  }
  /// Returns true if `bodyData` has been explicitly set.
  var hasBodyData: Bool {return _storage._bodyData != nil}
  /// Clears the value of `bodyData`. Subsequent reads from it will return its default value.
  mutating func clearBodyData() {_uniqueStorage()._bodyData = nil}

  var aqiValue: C110AQI {
    get {return _storage._aqiValue ?? .good}
    set {_uniqueStorage()._aqiValue = newValue}
  }
  /// Returns true if `aqiValue` has been explicitly set.
  var hasAqiValue: Bool {return _storage._aqiValue != nil}
  /// Clears the value of `aqiValue`. Subsequent reads from it will return its default value.
  mutating func clearAqiValue() {_uniqueStorage()._aqiValue = nil}

  var symptoms: [C110EcgSymptom] {
    get {return _storage._symptoms}
    set {_uniqueStorage()._symptoms = newValue}
  }

  var lifeQuality: LifeQualityData {
    get {return _storage._lifeQuality ?? LifeQualityData()}
    set {_uniqueStorage()._lifeQuality = newValue}
  }
  /// Returns true if `lifeQuality` has been explicitly set.
  var hasLifeQuality: Bool {return _storage._lifeQuality != nil}
  /// Clears the value of `lifeQuality`. Subsequent reads from it will return its default value.
  mutating func clearLifeQuality() {_uniqueStorage()._lifeQuality = nil}

  var wallet: VyvoWallet {
    get {return _storage._wallet ?? VyvoWallet()}
    set {_uniqueStorage()._wallet = newValue}
  }
  /// Returns true if `wallet` has been explicitly set.
  var hasWallet: Bool {return _storage._wallet != nil}
  /// Clears the value of `wallet`. Subsequent reads from it will return its default value.
  mutating func clearWallet() {_uniqueStorage()._wallet = nil}

  var conf: HealthAlarmConf {
    get {return _storage._conf ?? HealthAlarmConf()}
    set {_uniqueStorage()._conf = newValue}
  }
  /// Returns true if `conf` has been explicitly set.
  var hasConf: Bool {return _storage._conf != nil}
  /// Clears the value of `conf`. Subsequent reads from it will return its default value.
  mutating func clearConf() {_uniqueStorage()._conf = nil}

  var sosRet: Bool {
    get {return _storage._sosRet ?? false}
    set {_uniqueStorage()._sosRet = newValue}
  }
  /// Returns true if `sosRet` has been explicitly set.
  var hasSosRet: Bool {return _storage._sosRet != nil}
  /// Clears the value of `sosRet`. Subsequent reads from it will return its default value.
  mutating func clearSosRet() {_uniqueStorage()._sosRet = nil}

  var fallRet: Bool {
    get {return _storage._fallRet ?? false}
    set {_uniqueStorage()._fallRet = newValue}
  }
  /// Returns true if `fallRet` has been explicitly set.
  var hasFallRet: Bool {return _storage._fallRet != nil}
  /// Clears the value of `fallRet`. Subsequent reads from it will return its default value.
  mutating func clearFallRet() {_uniqueStorage()._fallRet = nil}

  var afAlarm: AfAlarm {
    get {return _storage._afAlarm ?? AfAlarm()}
    set {_uniqueStorage()._afAlarm = newValue}
  }
  /// Returns true if `afAlarm` has been explicitly set.
  var hasAfAlarm: Bool {return _storage._afAlarm != nil}
  /// Clears the value of `afAlarm`. Subsequent reads from it will return its default value.
  mutating func clearAfAlarm() {_uniqueStorage()._afAlarm = nil}

  var state: HealthAlarmState {
    get {return _storage._state ?? .notifyAndPrompt}
    set {_uniqueStorage()._state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  var hasState: Bool {return _storage._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  mutating func clearState() {_uniqueStorage()._state = nil}

  var checkAlarm: Bool {
    get {return _storage._checkAlarm ?? false}
    set {_uniqueStorage()._checkAlarm = newValue}
  }
  /// Returns true if `checkAlarm` has been explicitly set.
  var hasCheckAlarm: Bool {return _storage._checkAlarm != nil}
  /// Clears the value of `checkAlarm`. Subsequent reads from it will return its default value.
  mutating func clearCheckAlarm() {_uniqueStorage()._checkAlarm = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct C110Command {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var operation: C110Operation {
    get {return _operation ?? .read}
    set {_operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  var hasOperation: Bool {return self._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  mutating func clearOperation() {self._operation = nil}

  var data: C110Data {
    get {return _data ?? C110Data()}
    set {_data = newValue}
  }
  /// Returns true if `data` has been explicitly set.
  var hasData: Bool {return self._data != nil}
  /// Clears the value of `data`. Subsequent reads from it will return its default value.
  mutating func clearData() {self._data = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _operation: C110Operation? = nil
  fileprivate var _data: C110Data? = nil
}

struct C110Response {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var operation: C110Operation {
    get {return _operation ?? .read}
    set {_operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  var hasOperation: Bool {return self._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  mutating func clearOperation() {self._operation = nil}

  var params: C110Response.OneOf_Params? = nil

  var ret: Bool {
    get {
      if case .ret(let v)? = params {return v}
      return false
    }
    set {params = .ret(newValue)}
  }

  var data: C110Data {
    get {
      if case .data(let v)? = params {return v}
      return C110Data()
    }
    set {params = .data(newValue)}
  }

  var alarm: HealthAlarm {
    get {
      if case .alarm(let v)? = params {return v}
      return HealthAlarm()
    }
    set {params = .alarm(newValue)}
  }

  var alarminfo: HealthAlarminfo {
    get {
      if case .alarminfo(let v)? = params {return v}
      return HealthAlarminfo()
    }
    set {params = .alarminfo(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Params: Equatable {
    case ret(Bool)
    case data(C110Data)
    case alarm(HealthAlarm)
    case alarminfo(HealthAlarminfo)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .data: return {
        guard case .data(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .alarm: return {
        guard case .alarm(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .alarminfo: return {
        guard case .alarminfo(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      default: return true
      }
    }

  #if !swift(>=4.1)
    static func ==(lhs: C110Response.OneOf_Params, rhs: C110Response.OneOf_Params) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.ret, .ret): return {
        guard case .ret(let l) = lhs, case .ret(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.alarm, .alarm): return {
        guard case .alarm(let l) = lhs, case .alarm(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.alarminfo, .alarminfo): return {
        guard case .alarminfo(let l) = lhs, case .alarminfo(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _operation: C110Operation? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension C110Operation: @unchecked Sendable {}
extension C110AQI: @unchecked Sendable {}
extension C110EcgSymptom: @unchecked Sendable {}
extension HealthAlarmState: @unchecked Sendable {}
extension HealthAlarmType: @unchecked Sendable {}
extension C110BodyData: @unchecked Sendable {}
extension LifeQualityData: @unchecked Sendable {}
extension DailyMeasure: @unchecked Sendable {}
extension VyvoWallet: @unchecked Sendable {}
extension SOSAlarm: @unchecked Sendable {}
extension HrAlarm: @unchecked Sendable {}
extension BreathAlarm: @unchecked Sendable {}
extension BpAlarm: @unchecked Sendable {}
extension Spo2Alarm: @unchecked Sendable {}
extension FallAlarm: @unchecked Sendable {}
extension AfAlarm: @unchecked Sendable {}
extension TemperatureAlarm: @unchecked Sendable {}
extension HealthAlarmdata: @unchecked Sendable {}
extension HealthAlarminfo: @unchecked Sendable {}
extension HealthAlarm: @unchecked Sendable {}
extension HeartrateAlarmConf: @unchecked Sendable {}
extension BreathAlarmConf: @unchecked Sendable {}
extension BpAlarmConf: @unchecked Sendable {}
extension Spo2AlarmConf: @unchecked Sendable {}
extension FallAlarmConf: @unchecked Sendable {}
extension TemperatureAlarmConf: @unchecked Sendable {}
extension HealthAlarmConf: @unchecked Sendable {}
extension C110Data: @unchecked Sendable {}
extension C110Command: @unchecked Sendable {}
extension C110Response: @unchecked Sendable {}
extension C110Response.OneOf_Params: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension C110Operation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "READ"),
    1: .same(proto: "WRITE"),
  ]
}

extension C110AQI: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GOOD"),
    1: .same(proto: "NORMAL"),
    2: .same(proto: "BAD"),
    3: .same(proto: "WORST"),
  ]
}

extension C110EcgSymptom: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Sinus_rhythm"),
    1: .same(proto: "Sinus_arhythmia"),
    2: .same(proto: "Sinus_tachycardia"),
    3: .same(proto: "Sinus_bradycardia"),
    4: .same(proto: "Atrial_fibrillation"),
    5: .same(proto: "Atrial_flutter"),
    6: .same(proto: "Atrial_premature_beats"),
    7: .same(proto: "Ventricular_premature_beats"),
    8: .same(proto: "Left_ventricular_hypertrophy"),
    9: .same(proto: "Right_bundle_branch_block"),
    10: .same(proto: "Left_bundle_branch_block"),
  ]
}

extension HealthAlarmState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NOTIFY_AND_PROMPT"),
    1: .same(proto: "NOTIFY_AND_NO_PROMPT"),
    2: .same(proto: "NO_NOTIFY_AND_PROMPT"),
    3: .same(proto: "NO_NOTIFY_AND_NO_PROMPT"),
  ]
}

extension HealthAlarmType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "HR_ALARM"),
    1: .same(proto: "BREATH_ALARM"),
    2: .same(proto: "BP_ALARM"),
    3: .same(proto: "Spo2_ALARM"),
    4: .same(proto: "TEMP_ALARM"),
    5: .same(proto: "FALL_ALARM"),
    6: .same(proto: "AF_ALARM"),
  ]
}

extension C110BodyData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "C110BodyData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "BMI"),
    2: .same(proto: "BMR"),
    3: .same(proto: "BodyFat"),
    4: .same(proto: "VisceralFatLevel"),
    5: .same(proto: "MuscleMass"),
    6: .same(proto: "BoneMass"),
    7: .same(proto: "Weight"),
  ]

  public var isInitialized: Bool {
    if self._bmi == nil {return false}
    if self._bmr == nil {return false}
    if self._bodyFat == nil {return false}
    if self._visceralFatLevel == nil {return false}
    if self._muscleMass == nil {return false}
    if self._boneMass == nil {return false}
    if self._weight == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFloatField(value: &self._bmi) }()
      case 2: try { try decoder.decodeSingularFloatField(value: &self._bmr) }()
      case 3: try { try decoder.decodeSingularFloatField(value: &self._bodyFat) }()
      case 4: try { try decoder.decodeSingularFloatField(value: &self._visceralFatLevel) }()
      case 5: try { try decoder.decodeSingularFloatField(value: &self._muscleMass) }()
      case 6: try { try decoder.decodeSingularFloatField(value: &self._boneMass) }()
      case 7: try { try decoder.decodeSingularFloatField(value: &self._weight) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bmi {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._bmr {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._bodyFat {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._visceralFatLevel {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._muscleMass {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._boneMass {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._weight {
      try visitor.visitSingularFloatField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: C110BodyData, rhs: C110BodyData) -> Bool {
    if lhs._bmi != rhs._bmi {return false}
    if lhs._bmr != rhs._bmr {return false}
    if lhs._bodyFat != rhs._bodyFat {return false}
    if lhs._visceralFatLevel != rhs._visceralFatLevel {return false}
    if lhs._muscleMass != rhs._muscleMass {return false}
    if lhs._boneMass != rhs._boneMass {return false}
    if lhs._weight != rhs._weight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension LifeQualityData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "LifeQualityData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "wellNessValue"),
    2: .same(proto: "activityValue"),
    3: .same(proto: "moodSwingsValue"),
    4: .same(proto: "lifestyleIndexValue"),
    5: .same(proto: "time"),
  ]

  public var isInitialized: Bool {
    if let v = self._time, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._wellNessValue) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._activityValue) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._moodSwingsValue) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._lifestyleIndexValue) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._wellNessValue {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._activityValue {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._moodSwingsValue {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._lifestyleIndexValue {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: LifeQualityData, rhs: LifeQualityData) -> Bool {
    if lhs._wellNessValue != rhs._wellNessValue {return false}
    if lhs._activityValue != rhs._activityValue {return false}
    if lhs._moodSwingsValue != rhs._moodSwingsValue {return false}
    if lhs._lifestyleIndexValue != rhs._lifestyleIndexValue {return false}
    if lhs._time != rhs._time {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DailyMeasure: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DailyMeasure"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_stamp"),
    2: .same(proto: "measures"),
    3: .same(proto: "blocks"),
    4: .same(proto: "rewards"),
    5: .same(proto: "tokens"),
  ]

  public var isInitialized: Bool {
    if self._timeStamp == nil {return false}
    if self._measures == nil {return false}
    if self._blocks == nil {return false}
    if self._rewards == nil {return false}
    if self._tokens == nil {return false}
    if let v = self._timeStamp, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timeStamp) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._measures) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._blocks) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._rewards) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self._tokens) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timeStamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._measures {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._blocks {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._rewards {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._tokens {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DailyMeasure, rhs: DailyMeasure) -> Bool {
    if lhs._timeStamp != rhs._timeStamp {return false}
    if lhs._measures != rhs._measures {return false}
    if lhs._blocks != rhs._blocks {return false}
    if lhs._rewards != rhs._rewards {return false}
    if lhs._tokens != rhs._tokens {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension VyvoWallet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "VyvoWallet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "total_measures"),
    2: .standard(proto: "total_blocks"),
    3: .standard(proto: "total_rewards"),
    4: .standard(proto: "total_tokens"),
    5: .standard(proto: "daily_measure"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.dailyMeasure) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._totalMeasures) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._totalBlocks) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._totalRewards) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._totalTokens) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.dailyMeasure) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._totalMeasures {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._totalBlocks {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._totalRewards {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._totalTokens {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    if !self.dailyMeasure.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dailyMeasure, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: VyvoWallet, rhs: VyvoWallet) -> Bool {
    if lhs._totalMeasures != rhs._totalMeasures {return false}
    if lhs._totalBlocks != rhs._totalBlocks {return false}
    if lhs._totalRewards != rhs._totalRewards {return false}
    if lhs._totalTokens != rhs._totalTokens {return false}
    if lhs.dailyMeasure != rhs.dailyMeasure {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SOSAlarm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SOSAlarm"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ret"),
  ]

  public var isInitialized: Bool {
    if self._ret == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._ret) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ret {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SOSAlarm, rhs: SOSAlarm) -> Bool {
    if lhs._ret != rhs._ret {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HrAlarm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HrAlarm"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hr"),
  ]

  public var isInitialized: Bool {
    if self._hr == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._hr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hr {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HrAlarm, rhs: HrAlarm) -> Bool {
    if lhs._hr != rhs._hr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BreathAlarm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BreathAlarm"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "breath"),
  ]

  public var isInitialized: Bool {
    if self._breath == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._breath) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._breath {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BreathAlarm, rhs: BreathAlarm) -> Bool {
    if lhs._breath != rhs._breath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BpAlarm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BpAlarm"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sbp"),
    2: .same(proto: "dbp"),
  ]

  public var isInitialized: Bool {
    if self._sbp == nil {return false}
    if self._dbp == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._sbp) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._dbp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sbp {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._dbp {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BpAlarm, rhs: BpAlarm) -> Bool {
    if lhs._sbp != rhs._sbp {return false}
    if lhs._dbp != rhs._dbp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Spo2Alarm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Spo2Alarm"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "spo2"),
  ]

  public var isInitialized: Bool {
    if self._spo2 == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._spo2) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spo2 {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Spo2Alarm, rhs: Spo2Alarm) -> Bool {
    if lhs._spo2 != rhs._spo2 {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FallAlarm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FallAlarm"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fall_alarm"),
  ]

  public var isInitialized: Bool {
    if self._fallAlarm == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._fallAlarm) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fallAlarm {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FallAlarm, rhs: FallAlarm) -> Bool {
    if lhs._fallAlarm != rhs._fallAlarm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AfAlarm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AfAlarm"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_alarm"),
  ]

  public var isInitialized: Bool {
    if self._isAlarm == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._isAlarm) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._isAlarm {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AfAlarm, rhs: AfAlarm) -> Bool {
    if lhs._isAlarm != rhs._isAlarm {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TemperatureAlarm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TemperatureAlarm"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "temperature"),
  ]

  public var isInitialized: Bool {
    if self._temperature == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._temperature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._temperature {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TemperatureAlarm, rhs: TemperatureAlarm) -> Bool {
    if lhs._temperature != rhs._temperature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HealthAlarmdata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HealthAlarmdata"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_stamp"),
    2: .same(proto: "AlarmType"),
    3: .same(proto: "Alarmvalue"),
  ]

  public var isInitialized: Bool {
    if self._timeStamp == nil {return false}
    if self._alarmType == nil {return false}
    if let v = self._timeStamp, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._timeStamp) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._alarmType) }()
      case 3: try { try decoder.decodeRepeatedFixed32Field(value: &self.alarmvalue) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._timeStamp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._alarmType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    if !self.alarmvalue.isEmpty {
      try visitor.visitRepeatedFixed32Field(value: self.alarmvalue, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthAlarmdata, rhs: HealthAlarmdata) -> Bool {
    if lhs._timeStamp != rhs._timeStamp {return false}
    if lhs._alarmType != rhs._alarmType {return false}
    if lhs.alarmvalue != rhs.alarmvalue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HealthAlarminfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HealthAlarminfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Alarmdata"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.alarmdata) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.alarmdata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.alarmdata.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.alarmdata, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthAlarminfo, rhs: HealthAlarminfo) -> Bool {
    if lhs.alarmdata != rhs.alarmdata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HealthAlarm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HealthAlarm"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "alarm_sos"),
    2: .standard(proto: "alarm_hr"),
    3: .standard(proto: "alarm_breath"),
    4: .standard(proto: "alarm_bp"),
    5: .standard(proto: "alarm_spo2"),
    6: .standard(proto: "alarm_fall"),
    7: .standard(proto: "alarm_temp"),
  ]

  public var isInitialized: Bool {
    if let v = self._alarmSos, !v.isInitialized {return false}
    if let v = self._alarmHr, !v.isInitialized {return false}
    if let v = self._alarmBreath, !v.isInitialized {return false}
    if let v = self._alarmBp, !v.isInitialized {return false}
    if let v = self._alarmSpo2, !v.isInitialized {return false}
    if let v = self._alarmFall, !v.isInitialized {return false}
    if let v = self._alarmTemp, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._alarmSos) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._alarmHr) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._alarmBreath) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._alarmBp) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._alarmSpo2) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._alarmFall) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._alarmTemp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._alarmSos {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._alarmHr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._alarmBreath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._alarmBp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._alarmSpo2 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._alarmFall {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._alarmTemp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthAlarm, rhs: HealthAlarm) -> Bool {
    if lhs._alarmSos != rhs._alarmSos {return false}
    if lhs._alarmHr != rhs._alarmHr {return false}
    if lhs._alarmBreath != rhs._alarmBreath {return false}
    if lhs._alarmBp != rhs._alarmBp {return false}
    if lhs._alarmSpo2 != rhs._alarmSpo2 {return false}
    if lhs._alarmFall != rhs._alarmFall {return false}
    if lhs._alarmTemp != rhs._alarmTemp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HeartrateAlarmConf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HeartrateAlarmConf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hr_high"),
    2: .standard(proto: "hr_below"),
  ]

  public var isInitialized: Bool {
    if self._hrHigh == nil {return false}
    if self._hrBelow == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._hrHigh) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._hrBelow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hrHigh {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._hrBelow {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HeartrateAlarmConf, rhs: HeartrateAlarmConf) -> Bool {
    if lhs._hrHigh != rhs._hrHigh {return false}
    if lhs._hrBelow != rhs._hrBelow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BreathAlarmConf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BreathAlarmConf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "breath_high"),
    2: .standard(proto: "breath_below"),
  ]

  public var isInitialized: Bool {
    if self._breathHigh == nil {return false}
    if self._breathBelow == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._breathHigh) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._breathBelow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._breathHigh {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._breathBelow {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BreathAlarmConf, rhs: BreathAlarmConf) -> Bool {
    if lhs._breathHigh != rhs._breathHigh {return false}
    if lhs._breathBelow != rhs._breathBelow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BpAlarmConf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "BpAlarmConf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "sbp_high"),
    2: .standard(proto: "sbp_below"),
    3: .standard(proto: "dbp_high"),
    4: .standard(proto: "dbp_below"),
  ]

  public var isInitialized: Bool {
    if self._sbpHigh == nil {return false}
    if self._sbpBelow == nil {return false}
    if self._dbpHigh == nil {return false}
    if self._dbpBelow == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._sbpHigh) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._sbpBelow) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._dbpHigh) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._dbpBelow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sbpHigh {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sbpBelow {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._dbpHigh {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._dbpBelow {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BpAlarmConf, rhs: BpAlarmConf) -> Bool {
    if lhs._sbpHigh != rhs._sbpHigh {return false}
    if lhs._sbpBelow != rhs._sbpBelow {return false}
    if lhs._dbpHigh != rhs._dbpHigh {return false}
    if lhs._dbpBelow != rhs._dbpBelow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Spo2AlarmConf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Spo2AlarmConf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "spo2_below"),
  ]

  public var isInitialized: Bool {
    if self._spo2Below == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._spo2Below) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._spo2Below {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Spo2AlarmConf, rhs: Spo2AlarmConf) -> Bool {
    if lhs._spo2Below != rhs._spo2Below {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FallAlarmConf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FallAlarmConf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fall_check"),
  ]

  public var isInitialized: Bool {
    if self._fallCheck == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self._fallCheck) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fallCheck {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FallAlarmConf, rhs: FallAlarmConf) -> Bool {
    if lhs._fallCheck != rhs._fallCheck {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TemperatureAlarmConf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TemperatureAlarmConf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "temp_high"),
    2: .standard(proto: "temp_below"),
  ]

  public var isInitialized: Bool {
    if self._tempHigh == nil {return false}
    if self._tempBelow == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._tempHigh) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._tempBelow) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._tempHigh {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._tempBelow {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TemperatureAlarmConf, rhs: TemperatureAlarmConf) -> Bool {
    if lhs._tempHigh != rhs._tempHigh {return false}
    if lhs._tempBelow != rhs._tempBelow {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HealthAlarmConf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HealthAlarmConf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "conf_hr"),
    2: .standard(proto: "conf_breath"),
    3: .standard(proto: "conf_bp"),
    4: .standard(proto: "conf_spo2"),
    5: .standard(proto: "conf_fall"),
    6: .standard(proto: "conf_temp"),
  ]

  public var isInitialized: Bool {
    if let v = self._confHr, !v.isInitialized {return false}
    if let v = self._confBreath, !v.isInitialized {return false}
    if let v = self._confBp, !v.isInitialized {return false}
    if let v = self._confSpo2, !v.isInitialized {return false}
    if let v = self._confFall, !v.isInitialized {return false}
    if let v = self._confTemp, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._confHr) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._confBreath) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._confBp) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._confSpo2) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._confFall) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._confTemp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._confHr {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._confBreath {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._confBp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._confSpo2 {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._confFall {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._confTemp {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthAlarmConf, rhs: HealthAlarmConf) -> Bool {
    if lhs._confHr != rhs._confHr {return false}
    if lhs._confBreath != rhs._confBreath {return false}
    if lhs._confBp != rhs._confBp {return false}
    if lhs._confSpo2 != rhs._confSpo2 {return false}
    if lhs._confFall != rhs._confFall {return false}
    if lhs._confTemp != rhs._confTemp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension C110Data: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "C110Data"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "body_data"),
    2: .standard(proto: "aqi_value"),
    3: .same(proto: "symptoms"),
    4: .same(proto: "lifeQuality"),
    5: .same(proto: "wallet"),
    6: .same(proto: "conf"),
    7: .standard(proto: "sos_ret"),
    8: .standard(proto: "fall_ret"),
    9: .standard(proto: "af_alarm"),
    10: .same(proto: "state"),
    11: .standard(proto: "Check_Alarm"),
  ]

  fileprivate class _StorageClass {
    var _bodyData: C110BodyData? = nil
    var _aqiValue: C110AQI? = nil
    var _symptoms: [C110EcgSymptom] = []
    var _lifeQuality: LifeQualityData? = nil
    var _wallet: VyvoWallet? = nil
    var _conf: HealthAlarmConf? = nil
    var _sosRet: Bool? = nil
    var _fallRet: Bool? = nil
    var _afAlarm: AfAlarm? = nil
    var _state: HealthAlarmState? = nil
    var _checkAlarm: Bool? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _bodyData = source._bodyData
      _aqiValue = source._aqiValue
      _symptoms = source._symptoms
      _lifeQuality = source._lifeQuality
      _wallet = source._wallet
      _conf = source._conf
      _sosRet = source._sosRet
      _fallRet = source._fallRet
      _afAlarm = source._afAlarm
      _state = source._state
      _checkAlarm = source._checkAlarm
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._bodyData, !v.isInitialized {return false}
      if let v = _storage._lifeQuality, !v.isInitialized {return false}
      if let v = _storage._wallet, !v.isInitialized {return false}
      if let v = _storage._conf, !v.isInitialized {return false}
      if let v = _storage._afAlarm, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._bodyData) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._aqiValue) }()
        case 3: try { try decoder.decodeRepeatedEnumField(value: &_storage._symptoms) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._lifeQuality) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._wallet) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._conf) }()
        case 7: try { try decoder.decodeSingularBoolField(value: &_storage._sosRet) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._fallRet) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._afAlarm) }()
        case 10: try { try decoder.decodeSingularEnumField(value: &_storage._state) }()
        case 11: try { try decoder.decodeSingularBoolField(value: &_storage._checkAlarm) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._bodyData {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._aqiValue {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      } }()
      if !_storage._symptoms.isEmpty {
        try visitor.visitRepeatedEnumField(value: _storage._symptoms, fieldNumber: 3)
      }
      try { if let v = _storage._lifeQuality {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._wallet {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._conf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._sosRet {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._fallRet {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._afAlarm {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._state {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._checkAlarm {
        try visitor.visitSingularBoolField(value: v, fieldNumber: 11)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: C110Data, rhs: C110Data) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._bodyData != rhs_storage._bodyData {return false}
        if _storage._aqiValue != rhs_storage._aqiValue {return false}
        if _storage._symptoms != rhs_storage._symptoms {return false}
        if _storage._lifeQuality != rhs_storage._lifeQuality {return false}
        if _storage._wallet != rhs_storage._wallet {return false}
        if _storage._conf != rhs_storage._conf {return false}
        if _storage._sosRet != rhs_storage._sosRet {return false}
        if _storage._fallRet != rhs_storage._fallRet {return false}
        if _storage._afAlarm != rhs_storage._afAlarm {return false}
        if _storage._state != rhs_storage._state {return false}
        if _storage._checkAlarm != rhs_storage._checkAlarm {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension C110Command: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "C110Command"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
    2: .same(proto: "data"),
  ]

  public var isInitialized: Bool {
    if self._operation == nil {return false}
    if let v = self._data, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._operation) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._operation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._data {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: C110Command, rhs: C110Command) -> Bool {
    if lhs._operation != rhs._operation {return false}
    if lhs._data != rhs._data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension C110Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "C110Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
    2: .same(proto: "ret"),
    3: .same(proto: "data"),
    4: .same(proto: "alarm"),
    5: .same(proto: "Alarminfo"),
  ]

  public var isInitialized: Bool {
    if self._operation == nil {return false}
    if let v = self.params, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._operation) }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.params != nil {try decoder.handleConflictingOneOf()}
          self.params = .ret(v)
        }
      }()
      case 3: try {
        var v: C110Data?
        var hadOneofValue = false
        if let current = self.params {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.params = .data(v)
        }
      }()
      case 4: try {
        var v: HealthAlarm?
        var hadOneofValue = false
        if let current = self.params {
          hadOneofValue = true
          if case .alarm(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.params = .alarm(v)
        }
      }()
      case 5: try {
        var v: HealthAlarminfo?
        var hadOneofValue = false
        if let current = self.params {
          hadOneofValue = true
          if case .alarminfo(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.params = .alarminfo(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._operation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    switch self.params {
    case .ret?: try {
      guard case .ret(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case .data?: try {
      guard case .data(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .alarm?: try {
      guard case .alarm(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .alarminfo?: try {
      guard case .alarminfo(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: C110Response, rhs: C110Response) -> Bool {
    if lhs._operation != rhs._operation {return false}
    if lhs.params != rhs.params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
