// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: custom_dial.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum DialIndex: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case dialIndex1 // = 1
  case dialIndex2 // = 2

  init() {
    self = .dialIndex1
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .dialIndex1
    case 2: self = .dialIndex2
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .dialIndex1: return 1
    case .dialIndex2: return 2
    }
  }

}

#if swift(>=4.2)

extension DialIndex: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum Operation: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case read // = 1
  case clear // = 2
  case write // = 3

  init() {
    self = .read
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .read
    case 2: self = .clear
    case 3: self = .write
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .read: return 1
    case .clear: return 2
    case .write: return 3
    }
  }

}

#if swift(>=4.2)

extension Operation: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum ElementType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case elementBat // = 1
  case elementCalorie // = 2
  case elementStep // = 3
  case elementDistance // = 4
  case elementStand // = 5
  case elementHr // = 6
  case elementSpo2 // = 7

  init() {
    self = .elementBat
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .elementBat
    case 2: self = .elementCalorie
    case 3: self = .elementStep
    case 4: self = .elementDistance
    case 5: self = .elementStand
    case 6: self = .elementHr
    case 7: self = .elementSpo2
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .elementBat: return 1
    case .elementCalorie: return 2
    case .elementStep: return 3
    case .elementDistance: return 4
    case .elementStand: return 5
    case .elementHr: return 6
    case .elementSpo2: return 7
    }
  }

}

#if swift(>=4.2)

extension ElementType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum TimeRealStyle: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case timerealStyle1 // = 0
  case timerealStyle2 // = 1
  case timerealStyle3 // = 2
  case timerealStyle4 // = 3

  init() {
    self = .timerealStyle1
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .timerealStyle1
    case 1: self = .timerealStyle2
    case 2: self = .timerealStyle3
    case 3: self = .timerealStyle4
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .timerealStyle1: return 0
    case .timerealStyle2: return 1
    case .timerealStyle3: return 2
    case .timerealStyle4: return 3
    }
  }

}

#if swift(>=4.2)

extension TimeRealStyle: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum StateType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case stateBle // = 0
  case stateMsg // = 1
  case stateMisscall // = 2
  case stateNodisturb // = 3
  case stateAf // = 4

  init() {
    self = .stateBle
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .stateBle
    case 1: self = .stateMsg
    case 2: self = .stateMisscall
    case 3: self = .stateNodisturb
    case 4: self = .stateAf
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .stateBle: return 0
    case .stateMsg: return 1
    case .stateMisscall: return 2
    case .stateNodisturb: return 3
    case .stateAf: return 4
    }
  }

}

#if swift(>=4.2)

extension StateType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct InfoIcon {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///(2h:x,2l:y)
  var position: UInt32 {
    get {return _position ?? 0}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  ///(24-31:index, 12-23:x_size, 0-11:y_size)
  var iconInfo: UInt32 {
    get {return _iconInfo ?? 0}
    set {_iconInfo = newValue}
  }
  /// Returns true if `iconInfo` has been explicitly set.
  var hasIconInfo: Bool {return self._iconInfo != nil}
  /// Clears the value of `iconInfo`. Subsequent reads from it will return its default value.
  mutating func clearIconInfo() {self._iconInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _position: UInt32? = nil
  fileprivate var _iconInfo: UInt32? = nil
}

struct InfoStr {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///(2h:x, 2l:y)
  var position: UInt32 {
    get {return _position ?? 0}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  ///(1h:al, 3l:co)
  var alignColor: UInt32 {
    get {return _alignColor ?? 0}
    set {_alignColor = newValue}
  }
  /// Returns true if `alignColor` has been explicitly set.
  var hasAlignColor: Bool {return self._alignColor != nil}
  /// Clears the value of `alignColor`. Subsequent reads from it will return its default value.
  mutating func clearAlignColor() {self._alignColor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _position: UInt32? = nil
  fileprivate var _alignColor: UInt32? = nil
}

struct InfoProgressBarCircle {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///(2h:x,2l:y)
  var position: UInt32 {
    get {return _position ?? 0}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var radius: UInt32 {
    get {return _radius ?? 0}
    set {_radius = newValue}
  }
  /// Returns true if `radius` has been explicitly set.
  var hasRadius: Bool {return self._radius != nil}
  /// Clears the value of `radius`. Subsequent reads from it will return its default value.
  mutating func clearRadius() {self._radius = nil}

  var color: UInt32 {
    get {return _color ?? 0}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {self._color = nil}

  var bgColor: UInt32 {
    get {return _bgColor ?? 0}
    set {_bgColor = newValue}
  }
  /// Returns true if `bgColor` has been explicitly set.
  var hasBgColor: Bool {return self._bgColor != nil}
  /// Clears the value of `bgColor`. Subsequent reads from it will return its default value.
  mutating func clearBgColor() {self._bgColor = nil}

  var penSize: UInt32 {
    get {return _penSize ?? 0}
    set {_penSize = newValue}
  }
  /// Returns true if `penSize` has been explicitly set.
  var hasPenSize: Bool {return self._penSize != nil}
  /// Clears the value of `penSize`. Subsequent reads from it will return its default value.
  mutating func clearPenSize() {self._penSize = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _position: UInt32? = nil
  fileprivate var _radius: UInt32? = nil
  fileprivate var _color: UInt32? = nil
  fileprivate var _bgColor: UInt32? = nil
  fileprivate var _penSize: UInt32? = nil
}

struct InfoProgressBarRec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///(2h:x,2l:y)
  var position: UInt32 {
    get {return _position ?? 0}
    set {_position = newValue}
  }
  /// Returns true if `position` has been explicitly set.
  var hasPosition: Bool {return self._position != nil}
  /// Clears the value of `position`. Subsequent reads from it will return its default value.
  mutating func clearPosition() {self._position = nil}

  var len: UInt32 {
    get {return _len ?? 0}
    set {_len = newValue}
  }
  /// Returns true if `len` has been explicitly set.
  var hasLen: Bool {return self._len != nil}
  /// Clears the value of `len`. Subsequent reads from it will return its default value.
  mutating func clearLen() {self._len = nil}

  var color: UInt32 {
    get {return _color ?? 0}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {self._color = nil}

  var bgColor: UInt32 {
    get {return _bgColor ?? 0}
    set {_bgColor = newValue}
  }
  /// Returns true if `bgColor` has been explicitly set.
  var hasBgColor: Bool {return self._bgColor != nil}
  /// Clears the value of `bgColor`. Subsequent reads from it will return its default value.
  mutating func clearBgColor() {self._bgColor = nil}

  ///(2h:radius, 2l:pen)
  var size: UInt32 {
    get {return _size ?? 0}
    set {_size = newValue}
  }
  /// Returns true if `size` has been explicitly set.
  var hasSize: Bool {return self._size != nil}
  /// Clears the value of `size`. Subsequent reads from it will return its default value.
  mutating func clearSize() {self._size = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _position: UInt32? = nil
  fileprivate var _len: UInt32? = nil
  fileprivate var _color: UInt32? = nil
  fileprivate var _bgColor: UInt32? = nil
  fileprivate var _size: UInt32? = nil
}

struct InfoProgressBar {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: InfoProgressBar.OneOf_Data? = nil

  var barCircle: InfoProgressBarCircle {
    get {
      if case .barCircle(let v)? = data {return v}
      return InfoProgressBarCircle()
    }
    set {data = .barCircle(newValue)}
  }

  var barRec: InfoProgressBarRec {
    get {
      if case .barRec(let v)? = data {return v}
      return InfoProgressBarRec()
    }
    set {data = .barRec(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    case barCircle(InfoProgressBarCircle)
    case barRec(InfoProgressBarRec)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .barCircle: return {
        guard case .barCircle(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .barRec: return {
        guard case .barRec(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      }
    }

  #if !swift(>=4.1)
    static func ==(lhs: InfoProgressBar.OneOf_Data, rhs: InfoProgressBar.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.barCircle, .barCircle): return {
        guard case .barCircle(let l) = lhs, case .barCircle(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.barRec, .barRec): return {
        guard case .barRec(let l) = lhs, case .barRec(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct InfoTimeReal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var style: UInt32 {
    get {return _style ?? 0}
    set {_style = newValue}
  }
  /// Returns true if `style` has been explicitly set.
  var hasStyle: Bool {return self._style != nil}
  /// Clears the value of `style`. Subsequent reads from it will return its default value.
  mutating func clearStyle() {self._style = nil}

  var color: UInt32 {
    get {return _color ?? 0}
    set {_color = newValue}
  }
  /// Returns true if `color` has been explicitly set.
  var hasColor: Bool {return self._color != nil}
  /// Clears the value of `color`. Subsequent reads from it will return its default value.
  mutating func clearColor() {self._color = nil}

  var hourColor: UInt32 {
    get {return _hourColor ?? 0}
    set {_hourColor = newValue}
  }
  /// Returns true if `hourColor` has been explicitly set.
  var hasHourColor: Bool {return self._hourColor != nil}
  /// Clears the value of `hourColor`. Subsequent reads from it will return its default value.
  mutating func clearHourColor() {self._hourColor = nil}

  var minColor: UInt32 {
    get {return _minColor ?? 0}
    set {_minColor = newValue}
  }
  /// Returns true if `minColor` has been explicitly set.
  var hasMinColor: Bool {return self._minColor != nil}
  /// Clears the value of `minColor`. Subsequent reads from it will return its default value.
  mutating func clearMinColor() {self._minColor = nil}

  var secColor: UInt32 {
    get {return _secColor ?? 0}
    set {_secColor = newValue}
  }
  /// Returns true if `secColor` has been explicitly set.
  var hasSecColor: Bool {return self._secColor != nil}
  /// Clears the value of `secColor`. Subsequent reads from it will return its default value.
  mutating func clearSecColor() {self._secColor = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _style: UInt32? = nil
  fileprivate var _color: UInt32? = nil
  fileprivate var _hourColor: UInt32? = nil
  fileprivate var _minColor: UInt32? = nil
  fileprivate var _secColor: UInt32? = nil
}

struct InfoTimeDeg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hourIcon: InfoIcon {
    get {return _hourIcon ?? InfoIcon()}
    set {_hourIcon = newValue}
  }
  /// Returns true if `hourIcon` has been explicitly set.
  var hasHourIcon: Bool {return self._hourIcon != nil}
  /// Clears the value of `hourIcon`. Subsequent reads from it will return its default value.
  mutating func clearHourIcon() {self._hourIcon = nil}

  var separatorIcon: InfoIcon {
    get {return _separatorIcon ?? InfoIcon()}
    set {_separatorIcon = newValue}
  }
  /// Returns true if `separatorIcon` has been explicitly set.
  var hasSeparatorIcon: Bool {return self._separatorIcon != nil}
  /// Clears the value of `separatorIcon`. Subsequent reads from it will return its default value.
  mutating func clearSeparatorIcon() {self._separatorIcon = nil}

  var minIcon: InfoIcon {
    get {return _minIcon ?? InfoIcon()}
    set {_minIcon = newValue}
  }
  /// Returns true if `minIcon` has been explicitly set.
  var hasMinIcon: Bool {return self._minIcon != nil}
  /// Clears the value of `minIcon`. Subsequent reads from it will return its default value.
  mutating func clearMinIcon() {self._minIcon = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hourIcon: InfoIcon? = nil
  fileprivate var _separatorIcon: InfoIcon? = nil
  fileprivate var _minIcon: InfoIcon? = nil
}

struct InfoTime {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: InfoTime.OneOf_Data? = nil

  var timeReal: InfoTimeReal {
    get {
      if case .timeReal(let v)? = data {return v}
      return InfoTimeReal()
    }
    set {data = .timeReal(newValue)}
  }

  var timeDeg: InfoTimeDeg {
    get {
      if case .timeDeg(let v)? = data {return v}
      return InfoTimeDeg()
    }
    set {data = .timeDeg(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    case timeReal(InfoTimeReal)
    case timeDeg(InfoTimeDeg)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .timeReal: return {
        guard case .timeReal(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .timeDeg: return {
        guard case .timeDeg(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      }
    }

  #if !swift(>=4.1)
    static func ==(lhs: InfoTime.OneOf_Data, rhs: InfoTime.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.timeReal, .timeReal): return {
        guard case .timeReal(let l) = lhs, case .timeReal(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.timeDeg, .timeDeg): return {
        guard case .timeDeg(let l) = lhs, case .timeDeg(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Element {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: ElementType {
    get {return _type ?? .elementBat}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var icon: InfoIcon {
    get {return _icon ?? InfoIcon()}
    set {_icon = newValue}
  }
  /// Returns true if `icon` has been explicitly set.
  var hasIcon: Bool {return self._icon != nil}
  /// Clears the value of `icon`. Subsequent reads from it will return its default value.
  mutating func clearIcon() {self._icon = nil}

  var bar: InfoProgressBar {
    get {return _bar ?? InfoProgressBar()}
    set {_bar = newValue}
  }
  /// Returns true if `bar` has been explicitly set.
  var hasBar: Bool {return self._bar != nil}
  /// Clears the value of `bar`. Subsequent reads from it will return its default value.
  mutating func clearBar() {self._bar = nil}

  var str: InfoStr {
    get {return _str ?? InfoStr()}
    set {_str = newValue}
  }
  /// Returns true if `str` has been explicitly set.
  var hasStr: Bool {return self._str != nil}
  /// Clears the value of `str`. Subsequent reads from it will return its default value.
  mutating func clearStr() {self._str = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: ElementType? = nil
  fileprivate var _icon: InfoIcon? = nil
  fileprivate var _bar: InfoProgressBar? = nil
  fileprivate var _str: InfoStr? = nil
}

struct State {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: StateType {
    get {return _type ?? .stateBle}
    set {_type = newValue}
  }
  /// Returns true if `type` has been explicitly set.
  var hasType: Bool {return self._type != nil}
  /// Clears the value of `type`. Subsequent reads from it will return its default value.
  mutating func clearType() {self._type = nil}

  var icon: InfoIcon {
    get {return _icon ?? InfoIcon()}
    set {_icon = newValue}
  }
  /// Returns true if `icon` has been explicitly set.
  var hasIcon: Bool {return self._icon != nil}
  /// Clears the value of `icon`. Subsequent reads from it will return its default value.
  mutating func clearIcon() {self._icon = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _type: StateType? = nil
  fileprivate var _icon: InfoIcon? = nil
}

struct CustomDialIndexGroup {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: UInt32 {
    get {return _hash ?? 0}
    set {_hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  var hasHash: Bool {return self._hash != nil}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  mutating func clearHash() {self._hash = nil}

  var dial: DialIndex {
    get {return _dial ?? .dialIndex1}
    set {_dial = newValue}
  }
  /// Returns true if `dial` has been explicitly set.
  var hasDial: Bool {return self._dial != nil}
  /// Clears the value of `dial`. Subsequent reads from it will return its default value.
  mutating func clearDial() {self._dial = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _hash: UInt32? = nil
  fileprivate var _dial: DialIndex? = nil
}

struct CustomDialConf {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var bg: InfoIcon {
    get {return _bg ?? InfoIcon()}
    set {_bg = newValue}
  }
  /// Returns true if `bg` has been explicitly set.
  var hasBg: Bool {return self._bg != nil}
  /// Clears the value of `bg`. Subsequent reads from it will return its default value.
  mutating func clearBg() {self._bg = nil}

  var time: InfoTime {
    get {return _time ?? InfoTime()}
    set {_time = newValue}
  }
  /// Returns true if `time` has been explicitly set.
  var hasTime: Bool {return self._time != nil}
  /// Clears the value of `time`. Subsequent reads from it will return its default value.
  mutating func clearTime() {self._time = nil}

  var date: InfoStr {
    get {return _date ?? InfoStr()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {self._date = nil}

  var week: InfoStr {
    get {return _week ?? InfoStr()}
    set {_week = newValue}
  }
  /// Returns true if `week` has been explicitly set.
  var hasWeek: Bool {return self._week != nil}
  /// Clears the value of `week`. Subsequent reads from it will return its default value.
  mutating func clearWeek() {self._week = nil}

  var timeFormat: InfoStr {
    get {return _timeFormat ?? InfoStr()}
    set {_timeFormat = newValue}
  }
  /// Returns true if `timeFormat` has been explicitly set.
  var hasTimeFormat: Bool {return self._timeFormat != nil}
  /// Clears the value of `timeFormat`. Subsequent reads from it will return its default value.
  mutating func clearTimeFormat() {self._timeFormat = nil}

  var states: [State] = []

  var elements: [Element] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _bg: InfoIcon? = nil
  fileprivate var _time: InfoTime? = nil
  fileprivate var _date: InfoStr? = nil
  fileprivate var _week: InfoStr? = nil
  fileprivate var _timeFormat: InfoStr? = nil
}

struct CustomDialNotification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: UInt32 {
    get {return _storage._hash ?? 0}
    set {_uniqueStorage()._hash = newValue}
  }
  /// Returns true if `hash` has been explicitly set.
  var hasHash: Bool {return _storage._hash != nil}
  /// Clears the value of `hash`. Subsequent reads from it will return its default value.
  mutating func clearHash() {_uniqueStorage()._hash = nil}

  var dial: DialIndex {
    get {return _storage._dial ?? .dialIndex1}
    set {_uniqueStorage()._dial = newValue}
  }
  /// Returns true if `dial` has been explicitly set.
  var hasDial: Bool {return _storage._dial != nil}
  /// Clears the value of `dial`. Subsequent reads from it will return its default value.
  mutating func clearDial() {_uniqueStorage()._dial = nil}

  var conf: CustomDialConf {
    get {return _storage._conf ?? CustomDialConf()}
    set {_uniqueStorage()._conf = newValue}
  }
  /// Returns true if `conf` has been explicitly set.
  var hasConf: Bool {return _storage._conf != nil}
  /// Clears the value of `conf`. Subsequent reads from it will return its default value.
  mutating func clearConf() {_uniqueStorage()._conf = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct CustomDialRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var req: UInt32 {
    get {return _req ?? 0}
    set {_req = newValue}
  }
  /// Returns true if `req` has been explicitly set.
  var hasReq: Bool {return self._req != nil}
  /// Clears the value of `req`. Subsequent reads from it will return its default value.
  mutating func clearReq() {self._req = nil}

  var opt: Operation {
    get {return _opt ?? .read}
    set {_opt = newValue}
  }
  /// Returns true if `opt` has been explicitly set.
  var hasOpt: Bool {return self._opt != nil}
  /// Clears the value of `opt`. Subsequent reads from it will return its default value.
  mutating func clearOpt() {self._opt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _req: UInt32? = nil
  fileprivate var _opt: Operation? = nil
}

struct CustomDialSubscriber {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: CustomDialSubscriber.OneOf_Data? = nil

  var notify: CustomDialNotification {
    get {
      if case .notify(let v)? = data {return v}
      return CustomDialNotification()
    }
    set {data = .notify(newValue)}
  }

  var request: CustomDialRequest {
    get {
      if case .request(let v)? = data {return v}
      return CustomDialRequest()
    }
    set {data = .request(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Data: Equatable {
    case notify(CustomDialNotification)
    case request(CustomDialRequest)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .notify: return {
        guard case .notify(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .request: return {
        guard case .request(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      }
    }

  #if !swift(>=4.1)
    static func ==(lhs: CustomDialSubscriber.OneOf_Data, rhs: CustomDialSubscriber.OneOf_Data) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.notify, .notify): return {
        guard case .notify(let l) = lhs, case .notify(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.request, .request): return {
        guard case .request(let l) = lhs, case .request(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct CustomDialConfim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var group: [CustomDialIndexGroup] = []

  var ret: Bool {
    get {return _ret ?? false}
    set {_ret = newValue}
  }
  /// Returns true if `ret` has been explicitly set.
  var hasRet: Bool {return self._ret != nil}
  /// Clears the value of `ret`. Subsequent reads from it will return its default value.
  mutating func clearRet() {self._ret = nil}

  var opt: Operation {
    get {return _opt ?? .read}
    set {_opt = newValue}
  }
  /// Returns true if `opt` has been explicitly set.
  var hasOpt: Bool {return self._opt != nil}
  /// Clears the value of `opt`. Subsequent reads from it will return its default value.
  mutating func clearOpt() {self._opt = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ret: Bool? = nil
  fileprivate var _opt: Operation? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension DialIndex: @unchecked Sendable {}
extension Operation: @unchecked Sendable {}
extension ElementType: @unchecked Sendable {}
extension TimeRealStyle: @unchecked Sendable {}
extension StateType: @unchecked Sendable {}
extension InfoIcon: @unchecked Sendable {}
extension InfoStr: @unchecked Sendable {}
extension InfoProgressBarCircle: @unchecked Sendable {}
extension InfoProgressBarRec: @unchecked Sendable {}
extension InfoProgressBar: @unchecked Sendable {}
extension InfoProgressBar.OneOf_Data: @unchecked Sendable {}
extension InfoTimeReal: @unchecked Sendable {}
extension InfoTimeDeg: @unchecked Sendable {}
extension InfoTime: @unchecked Sendable {}
extension InfoTime.OneOf_Data: @unchecked Sendable {}
extension Element: @unchecked Sendable {}
extension State: @unchecked Sendable {}
extension CustomDialIndexGroup: @unchecked Sendable {}
extension CustomDialConf: @unchecked Sendable {}
extension CustomDialNotification: @unchecked Sendable {}
extension CustomDialRequest: @unchecked Sendable {}
extension CustomDialSubscriber: @unchecked Sendable {}
extension CustomDialSubscriber.OneOf_Data: @unchecked Sendable {}
extension CustomDialConfim: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension DialIndex: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "DIAL_INDEX1"),
    2: .same(proto: "DIAL_INDEX2"),
  ]
}

extension Operation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "READ"),
    2: .same(proto: "CLEAR"),
    3: .same(proto: "WRITE"),
  ]
}

extension ElementType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ELEMENT_BAT"),
    2: .same(proto: "ELEMENT_CALORIE"),
    3: .same(proto: "ELEMENT_STEP"),
    4: .same(proto: "ELEMENT_DISTANCE"),
    5: .same(proto: "ELEMENT_STAND"),
    6: .same(proto: "ELEMENT_HR"),
    7: .same(proto: "ELEMENT_SPO2"),
  ]
}

extension TimeRealStyle: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "TIMEREAL_STYLE1"),
    1: .same(proto: "TIMEREAL_STYLE2"),
    2: .same(proto: "TIMEREAL_STYLE3"),
    3: .same(proto: "TIMEREAL_STYLE4"),
  ]
}

extension StateType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "STATE_BLE"),
    1: .same(proto: "STATE_MSG"),
    2: .same(proto: "STATE_MISSCALL"),
    3: .same(proto: "STATE_NODISTURB"),
    4: .same(proto: "STATE_AF"),
  ]
}

extension InfoIcon: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "InfoIcon"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .standard(proto: "icon_info"),
  ]

  public var isInitialized: Bool {
    if self._position == nil {return false}
    if self._iconInfo == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._position) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._iconInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._position {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._iconInfo {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: InfoIcon, rhs: InfoIcon) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs._iconInfo != rhs._iconInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InfoStr: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "InfoStr"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .standard(proto: "align_color"),
  ]

  public var isInitialized: Bool {
    if self._position == nil {return false}
    if self._alignColor == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._position) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._alignColor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._position {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._alignColor {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: InfoStr, rhs: InfoStr) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs._alignColor != rhs._alignColor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InfoProgressBarCircle: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "InfoProgressBarCircle"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .same(proto: "radius"),
    3: .same(proto: "color"),
    4: .standard(proto: "bg_color"),
    5: .standard(proto: "pen_size"),
  ]

  public var isInitialized: Bool {
    if self._position == nil {return false}
    if self._radius == nil {return false}
    if self._color == nil {return false}
    if self._bgColor == nil {return false}
    if self._penSize == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._position) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._radius) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._color) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._bgColor) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self._penSize) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._position {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._radius {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._color {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._bgColor {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._penSize {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: InfoProgressBarCircle, rhs: InfoProgressBarCircle) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs._radius != rhs._radius {return false}
    if lhs._color != rhs._color {return false}
    if lhs._bgColor != rhs._bgColor {return false}
    if lhs._penSize != rhs._penSize {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InfoProgressBarRec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "InfoProgressBarRec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "position"),
    2: .same(proto: "len"),
    3: .same(proto: "color"),
    4: .standard(proto: "bg_color"),
    5: .same(proto: "size"),
  ]

  public var isInitialized: Bool {
    if self._position == nil {return false}
    if self._len == nil {return false}
    if self._color == nil {return false}
    if self._bgColor == nil {return false}
    if self._size == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._position) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._len) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._color) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._bgColor) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self._size) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._position {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._len {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._color {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._bgColor {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._size {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: InfoProgressBarRec, rhs: InfoProgressBarRec) -> Bool {
    if lhs._position != rhs._position {return false}
    if lhs._len != rhs._len {return false}
    if lhs._color != rhs._color {return false}
    if lhs._bgColor != rhs._bgColor {return false}
    if lhs._size != rhs._size {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InfoProgressBar: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "InfoProgressBar"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "bar_circle"),
    2: .standard(proto: "bar_rec"),
  ]

  public var isInitialized: Bool {
    if let v = self.data, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: InfoProgressBarCircle?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .barCircle(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .barCircle(v)
        }
      }()
      case 2: try {
        var v: InfoProgressBarRec?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .barRec(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .barRec(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.data {
    case .barCircle?: try {
      guard case .barCircle(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .barRec?: try {
      guard case .barRec(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: InfoProgressBar, rhs: InfoProgressBar) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InfoTimeReal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "InfoTimeReal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "style"),
    2: .same(proto: "color"),
    3: .standard(proto: "hour_color"),
    4: .standard(proto: "min_color"),
    5: .standard(proto: "sec_color"),
  ]

  public var isInitialized: Bool {
    if self._style == nil {return false}
    if self._color == nil {return false}
    if self._hourColor == nil {return false}
    if self._minColor == nil {return false}
    if self._secColor == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._style) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._color) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._hourColor) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._minColor) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self._secColor) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._style {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._color {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._hourColor {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._minColor {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._secColor {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: InfoTimeReal, rhs: InfoTimeReal) -> Bool {
    if lhs._style != rhs._style {return false}
    if lhs._color != rhs._color {return false}
    if lhs._hourColor != rhs._hourColor {return false}
    if lhs._minColor != rhs._minColor {return false}
    if lhs._secColor != rhs._secColor {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InfoTimeDeg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "InfoTimeDeg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "hour_icon"),
    2: .standard(proto: "separator_icon"),
    3: .standard(proto: "min_icon"),
  ]

  public var isInitialized: Bool {
    if self._hourIcon == nil {return false}
    if self._minIcon == nil {return false}
    if let v = self._hourIcon, !v.isInitialized {return false}
    if let v = self._separatorIcon, !v.isInitialized {return false}
    if let v = self._minIcon, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._hourIcon) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._separatorIcon) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._minIcon) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hourIcon {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._separatorIcon {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._minIcon {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: InfoTimeDeg, rhs: InfoTimeDeg) -> Bool {
    if lhs._hourIcon != rhs._hourIcon {return false}
    if lhs._separatorIcon != rhs._separatorIcon {return false}
    if lhs._minIcon != rhs._minIcon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension InfoTime: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "InfoTime"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "time_real"),
    2: .standard(proto: "time_deg"),
  ]

  public var isInitialized: Bool {
    if let v = self.data, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: InfoTimeReal?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .timeReal(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .timeReal(v)
        }
      }()
      case 2: try {
        var v: InfoTimeDeg?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .timeDeg(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .timeDeg(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.data {
    case .timeReal?: try {
      guard case .timeReal(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .timeDeg?: try {
      guard case .timeDeg(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: InfoTime, rhs: InfoTime) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Element: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Element"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "icon"),
    3: .same(proto: "bar"),
    4: .same(proto: "str"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if let v = self._icon, !v.isInitialized {return false}
    if let v = self._bar, !v.isInitialized {return false}
    if let v = self._str, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._icon) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._bar) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._str) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._icon {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._bar {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._str {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Element, rhs: Element) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._icon != rhs._icon {return false}
    if lhs._bar != rhs._bar {return false}
    if lhs._str != rhs._str {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension State: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "State"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "icon"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if self._icon == nil {return false}
    if let v = self._icon, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._icon) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._icon {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: State, rhs: State) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._icon != rhs._icon {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CustomDialIndexGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CustomDialIndexGroup"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "dial"),
  ]

  public var isInitialized: Bool {
    if self._hash == nil {return false}
    if self._dial == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._hash) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._dial) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._hash {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._dial {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CustomDialIndexGroup, rhs: CustomDialIndexGroup) -> Bool {
    if lhs._hash != rhs._hash {return false}
    if lhs._dial != rhs._dial {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CustomDialConf: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CustomDialConf"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "bg"),
    2: .same(proto: "time"),
    3: .same(proto: "date"),
    4: .same(proto: "week"),
    5: .standard(proto: "time_format"),
    6: .same(proto: "states"),
    7: .same(proto: "elements"),
  ]

  public var isInitialized: Bool {
    if self._bg == nil {return false}
    if self._time == nil {return false}
    if let v = self._bg, !v.isInitialized {return false}
    if let v = self._time, !v.isInitialized {return false}
    if let v = self._date, !v.isInitialized {return false}
    if let v = self._week, !v.isInitialized {return false}
    if let v = self._timeFormat, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.states) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.elements) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._bg) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._time) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._date) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._week) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._timeFormat) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.states) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.elements) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._bg {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._time {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._date {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._week {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._timeFormat {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.states.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.states, fieldNumber: 6)
    }
    if !self.elements.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.elements, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CustomDialConf, rhs: CustomDialConf) -> Bool {
    if lhs._bg != rhs._bg {return false}
    if lhs._time != rhs._time {return false}
    if lhs._date != rhs._date {return false}
    if lhs._week != rhs._week {return false}
    if lhs._timeFormat != rhs._timeFormat {return false}
    if lhs.states != rhs.states {return false}
    if lhs.elements != rhs.elements {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CustomDialNotification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CustomDialNotification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "dial"),
    3: .same(proto: "conf"),
  ]

  fileprivate class _StorageClass {
    var _hash: UInt32? = nil
    var _dial: DialIndex? = nil
    var _conf: CustomDialConf? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _hash = source._hash
      _dial = source._dial
      _conf = source._conf
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._hash == nil {return false}
      if _storage._dial == nil {return false}
      if _storage._conf == nil {return false}
      if let v = _storage._conf, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularFixed32Field(value: &_storage._hash) }()
        case 2: try { try decoder.decodeSingularEnumField(value: &_storage._dial) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._conf) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._hash {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._dial {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._conf {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CustomDialNotification, rhs: CustomDialNotification) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._hash != rhs_storage._hash {return false}
        if _storage._dial != rhs_storage._dial {return false}
        if _storage._conf != rhs_storage._conf {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CustomDialRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CustomDialRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "req"),
    2: .same(proto: "opt"),
  ]

  public var isInitialized: Bool {
    if self._req == nil {return false}
    if self._opt == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._req) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._opt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._req {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._opt {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CustomDialRequest, rhs: CustomDialRequest) -> Bool {
    if lhs._req != rhs._req {return false}
    if lhs._opt != rhs._opt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CustomDialSubscriber: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CustomDialSubscriber"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "notify"),
    2: .same(proto: "request"),
  ]

  public var isInitialized: Bool {
    if let v = self.data, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: CustomDialNotification?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .notify(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .notify(v)
        }
      }()
      case 2: try {
        var v: CustomDialRequest?
        var hadOneofValue = false
        if let current = self.data {
          hadOneofValue = true
          if case .request(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.data = .request(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.data {
    case .notify?: try {
      guard case .notify(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .request?: try {
      guard case .request(let v)? = self.data else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CustomDialSubscriber, rhs: CustomDialSubscriber) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CustomDialConfim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CustomDialConfim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "group"),
    2: .same(proto: "ret"),
    3: .same(proto: "opt"),
  ]

  public var isInitialized: Bool {
    if self._ret == nil {return false}
    if self._opt == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.group) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.group) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._ret) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._opt) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.group.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.group, fieldNumber: 1)
    }
    try { if let v = self._ret {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._opt {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CustomDialConfim, rhs: CustomDialConfim) -> Bool {
    if lhs.group != rhs.group {return false}
    if lhs._ret != rhs._ret {return false}
    if lhs._opt != rhs._opt {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
