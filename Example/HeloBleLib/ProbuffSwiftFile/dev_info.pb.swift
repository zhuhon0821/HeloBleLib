// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: dev_info.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum DevInfoFota: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case non // = 0
  case cc2540 // = 1
  case nrf51 // = 2
  case da1468X // = 3
  case mt2523 // = 4
  case nrf52Ble // = 5
  case gh551XBle // = 6

  init() {
    self = .non
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .non
    case 1: self = .cc2540
    case 2: self = .nrf51
    case 3: self = .da1468X
    case 4: self = .mt2523
    case 5: self = .nrf52Ble
    case 6: self = .gh551XBle
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .non: return 0
    case .cc2540: return 1
    case .nrf51: return 2
    case .da1468X: return 3
    case .mt2523: return 4
    case .nrf52Ble: return 5
    case .gh551XBle: return 6
    }
  }

}

#if swift(>=4.2)

extension DevInfoFota: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

enum DevInfoOperation: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case read // = 0
  case write // = 1

  init() {
    self = .read
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .read
    case 1: self = .write
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .read: return 0
    case .write: return 1
    }
  }

}

#if swift(>=4.2)

extension DevInfoOperation: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct DevInfoManu {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var date: String {
    get {return _date ?? String()}
    set {_date = newValue}
  }
  /// Returns true if `date` has been explicitly set.
  var hasDate: Bool {return self._date != nil}
  /// Clears the value of `date`. Subsequent reads from it will return its default value.
  mutating func clearDate() {self._date = nil}

  var factory: String {
    get {return _factory ?? String()}
    set {_factory = newValue}
  }
  /// Returns true if `factory` has been explicitly set.
  var hasFactory: Bool {return self._factory != nil}
  /// Clears the value of `factory`. Subsequent reads from it will return its default value.
  mutating func clearFactory() {self._factory = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _date: String? = nil
  fileprivate var _factory: String? = nil
}

struct DeviceInfoResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var model: String {
    get {return _model ?? String()}
    set {_model = newValue}
  }
  /// Returns true if `model` has been explicitly set.
  var hasModel: Bool {return self._model != nil}
  /// Clears the value of `model`. Subsequent reads from it will return its default value.
  mutating func clearModel() {self._model = nil}

  var version: String {
    get {return _version ?? String()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  mutating func clearVersion() {self._version = nil}

  var mac: Data {
    get {return _mac ?? Data()}
    set {_mac = newValue}
  }
  /// Returns true if `mac` has been explicitly set.
  var hasMac: Bool {return self._mac != nil}
  /// Clears the value of `mac`. Subsequent reads from it will return its default value.
  mutating func clearMac() {self._mac = nil}

  var fota: DevInfoFota {
    get {return _fota ?? .non}
    set {_fota = newValue}
  }
  /// Returns true if `fota` has been explicitly set.
  var hasFota: Bool {return self._fota != nil}
  /// Clears the value of `fota`. Subsequent reads from it will return its default value.
  mutating func clearFota() {self._fota = nil}

  var manu: DevInfoManu {
    get {return _manu ?? DevInfoManu()}
    set {_manu = newValue}
  }
  /// Returns true if `manu` has been explicitly set.
  var hasManu: Bool {return self._manu != nil}
  /// Clears the value of `manu`. Subsequent reads from it will return its default value.
  mutating func clearManu() {self._manu = nil}

  var userData: Data {
    get {return _userData ?? Data()}
    set {_userData = newValue}
  }
  /// Returns true if `userData` has been explicitly set.
  var hasUserData: Bool {return self._userData != nil}
  /// Clears the value of `userData`. Subsequent reads from it will return its default value.
  mutating func clearUserData() {self._userData = nil}

  var pbVersion: String {
    get {return _pbVersion ?? String()}
    set {_pbVersion = newValue}
  }
  /// Returns true if `pbVersion` has been explicitly set.
  var hasPbVersion: Bool {return self._pbVersion != nil}
  /// Clears the value of `pbVersion`. Subsequent reads from it will return its default value.
  mutating func clearPbVersion() {self._pbVersion = nil}

  var ctpCs: UInt32 {
    get {return _ctpCs ?? 0}
    set {_ctpCs = newValue}
  }
  /// Returns true if `ctpCs` has been explicitly set.
  var hasCtpCs: Bool {return self._ctpCs != nil}
  /// Clears the value of `ctpCs`. Subsequent reads from it will return its default value.
  mutating func clearCtpCs() {self._ctpCs = nil}

  var programAddr: UInt32 {
    get {return _programAddr ?? 0}
    set {_programAddr = newValue}
  }
  /// Returns true if `programAddr` has been explicitly set.
  var hasProgramAddr: Bool {return self._programAddr != nil}
  /// Clears the value of `programAddr`. Subsequent reads from it will return its default value.
  mutating func clearProgramAddr() {self._programAddr = nil}

  var resourceAddr: UInt32 {
    get {return _resourceAddr ?? 0}
    set {_resourceAddr = newValue}
  }
  /// Returns true if `resourceAddr` has been explicitly set.
  var hasResourceAddr: Bool {return self._resourceAddr != nil}
  /// Clears the value of `resourceAddr`. Subsequent reads from it will return its default value.
  mutating func clearResourceAddr() {self._resourceAddr = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _model: String? = nil
  fileprivate var _version: String? = nil
  fileprivate var _mac: Data? = nil
  fileprivate var _fota: DevInfoFota? = nil
  fileprivate var _manu: DevInfoManu? = nil
  fileprivate var _userData: Data? = nil
  fileprivate var _pbVersion: String? = nil
  fileprivate var _ctpCs: UInt32? = nil
  fileprivate var _programAddr: UInt32? = nil
  fileprivate var _resourceAddr: UInt32? = nil
}

struct DeviceInfoCommand {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var userData: Data {
    get {return _userData ?? Data()}
    set {_userData = newValue}
  }
  /// Returns true if `userData` has been explicitly set.
  var hasUserData: Bool {return self._userData != nil}
  /// Clears the value of `userData`. Subsequent reads from it will return its default value.
  mutating func clearUserData() {self._userData = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _userData: Data? = nil
}

struct DeviceInfoRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var reserved: UInt32 {
    get {return _reserved ?? 0}
    set {_reserved = newValue}
  }
  /// Returns true if `reserved` has been explicitly set.
  var hasReserved: Bool {return self._reserved != nil}
  /// Clears the value of `reserved`. Subsequent reads from it will return its default value.
  mutating func clearReserved() {self._reserved = nil}

  var operation: DevInfoOperation {
    get {return _operation ?? .read}
    set {_operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  var hasOperation: Bool {return self._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  mutating func clearOperation() {self._operation = nil}

  var devinfo: DeviceInfoCommand {
    get {return _devinfo ?? DeviceInfoCommand()}
    set {_devinfo = newValue}
  }
  /// Returns true if `devinfo` has been explicitly set.
  var hasDevinfo: Bool {return self._devinfo != nil}
  /// Clears the value of `devinfo`. Subsequent reads from it will return its default value.
  mutating func clearDevinfo() {self._devinfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _reserved: UInt32? = nil
  fileprivate var _operation: DevInfoOperation? = nil
  fileprivate var _devinfo: DeviceInfoCommand? = nil
}

#if swift(>=5.5) && canImport(_Concurrency)
extension DevInfoFota: @unchecked Sendable {}
extension DevInfoOperation: @unchecked Sendable {}
extension DevInfoManu: @unchecked Sendable {}
extension DeviceInfoResponse: @unchecked Sendable {}
extension DeviceInfoCommand: @unchecked Sendable {}
extension DeviceInfoRequest: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension DevInfoFota: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NON"),
    1: .same(proto: "CC2540"),
    2: .same(proto: "NRF51"),
    3: .same(proto: "DA1468X"),
    4: .same(proto: "MT2523"),
    5: .same(proto: "NRF52_BLE"),
    6: .same(proto: "GH551X_BLE"),
  ]
}

extension DevInfoOperation: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "Read"),
    1: .same(proto: "Write"),
  ]
}

extension DevInfoManu: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DevInfoManu"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "date"),
    2: .same(proto: "factory"),
  ]

  public var isInitialized: Bool {
    if self._date == nil {return false}
    if self._factory == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._date) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._factory) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._date {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._factory {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DevInfoManu, rhs: DevInfoManu) -> Bool {
    if lhs._date != rhs._date {return false}
    if lhs._factory != rhs._factory {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceInfoResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceInfoResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "model"),
    2: .same(proto: "version"),
    3: .same(proto: "mac"),
    4: .same(proto: "fota"),
    5: .same(proto: "manu"),
    6: .standard(proto: "user_data"),
    7: .standard(proto: "pb_version"),
    8: .standard(proto: "ctp_cs"),
    9: .standard(proto: "program_addr"),
    10: .standard(proto: "resource_addr"),
  ]

  public var isInitialized: Bool {
    if let v = self._manu, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._model) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._version) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self._mac) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self._fota) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._manu) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self._userData) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._pbVersion) }()
      case 8: try { try decoder.decodeSingularFixed32Field(value: &self._ctpCs) }()
      case 9: try { try decoder.decodeSingularFixed32Field(value: &self._programAddr) }()
      case 10: try { try decoder.decodeSingularFixed32Field(value: &self._resourceAddr) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._model {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._version {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._mac {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._fota {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._manu {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._userData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._pbVersion {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._ctpCs {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._programAddr {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._resourceAddr {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 10)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceInfoResponse, rhs: DeviceInfoResponse) -> Bool {
    if lhs._model != rhs._model {return false}
    if lhs._version != rhs._version {return false}
    if lhs._mac != rhs._mac {return false}
    if lhs._fota != rhs._fota {return false}
    if lhs._manu != rhs._manu {return false}
    if lhs._userData != rhs._userData {return false}
    if lhs._pbVersion != rhs._pbVersion {return false}
    if lhs._ctpCs != rhs._ctpCs {return false}
    if lhs._programAddr != rhs._programAddr {return false}
    if lhs._resourceAddr != rhs._resourceAddr {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceInfoCommand: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceInfoCommand"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "user_data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self._userData) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._userData {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceInfoCommand, rhs: DeviceInfoCommand) -> Bool {
    if lhs._userData != rhs._userData {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DeviceInfoRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceInfoRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "reserved"),
    2: .same(proto: "operation"),
    3: .same(proto: "devinfo"),
  ]

  public var isInitialized: Bool {
    if self._operation == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._reserved) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._operation) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._devinfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._reserved {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._operation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._devinfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceInfoRequest, rhs: DeviceInfoRequest) -> Bool {
    if lhs._reserved != rhs._reserved {return false}
    if lhs._operation != rhs._operation {return false}
    if lhs._devinfo != rhs._devinfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
