// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: files_update.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum FUType: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case gps // = 0
  case font // = 1
  case mgaonline // = 2
  case customdial // = 3
  case firmware // = 4
  case bp // = 5
  case ctp // = 6

  init() {
    self = .gps
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .gps
    case 1: self = .font
    case 2: self = .mgaonline
    case 3: self = .customdial
    case 4: self = .firmware
    case 5: self = .bp
    case 6: self = .ctp
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .gps: return 0
    case .font: return 1
    case .mgaonline: return 2
    case .customdial: return 3
    case .firmware: return 4
    case .bp: return 5
    case .ctp: return 6
    }
  }

}

#if swift(>=4.2)

extension FUType: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct FUInitResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fd: FUType {
    get {return _fd ?? .gps}
    set {_fd = newValue}
  }
  /// Returns true if `fd` has been explicitly set.
  var hasFd: Bool {return self._fd != nil}
  /// Clears the value of `fd`. Subsequent reads from it will return its default value.
  mutating func clearFd() {self._fd = nil}

  var status: FUInitResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case errorParams // = 1
    case errorInner // = 2

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .errorParams
      case 2: self = .errorInner
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .errorParams: return 1
      case .errorInner: return 2
      }
    }

  }

  init() {}

  fileprivate var _fd: FUType? = nil
  fileprivate var _status: FUInitResponse.Status? = nil
}

#if swift(>=4.2)

extension FUInitResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct FUDataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fd: FUType {
    get {return _fd ?? .gps}
    set {_fd = newValue}
  }
  /// Returns true if `fd` has been explicitly set.
  var hasFd: Bool {return self._fd != nil}
  /// Clears the value of `fd`. Subsequent reads from it will return its default value.
  mutating func clearFd() {self._fd = nil}

  var status: FUDataResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var fileOffset: UInt32 {
    get {return _fileOffset ?? 0}
    set {_fileOffset = newValue}
  }
  /// Returns true if `fileOffset` has been explicitly set.
  var hasFileOffset: Bool {return self._fileOffset != nil}
  /// Clears the value of `fileOffset`. Subsequent reads from it will return its default value.
  mutating func clearFileOffset() {self._fileOffset = nil}

  var crc32AtOffset: UInt32 {
    get {return _crc32AtOffset ?? 0}
    set {_crc32AtOffset = newValue}
  }
  /// Returns true if `crc32AtOffset` has been explicitly set.
  var hasCrc32AtOffset: Bool {return self._crc32AtOffset != nil}
  /// Clears the value of `crc32AtOffset`. Subsequent reads from it will return its default value.
  mutating func clearCrc32AtOffset() {self._crc32AtOffset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case errorParams // = 1
    case errorOffsetMismatch // = 2
    case errorCrc32Mismatch // = 3
    case errorInner // = 4

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .errorParams
      case 2: self = .errorOffsetMismatch
      case 3: self = .errorCrc32Mismatch
      case 4: self = .errorInner
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .errorParams: return 1
      case .errorOffsetMismatch: return 2
      case .errorCrc32Mismatch: return 3
      case .errorInner: return 4
      }
    }

  }

  init() {}

  fileprivate var _fd: FUType? = nil
  fileprivate var _status: FUDataResponse.Status? = nil
  fileprivate var _fileOffset: UInt32? = nil
  fileprivate var _crc32AtOffset: UInt32? = nil
}

#if swift(>=4.2)

extension FUDataResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct FUFileInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fd: FUType {
    get {return _fd ?? .gps}
    set {_fd = newValue}
  }
  /// Returns true if `fd` has been explicitly set.
  var hasFd: Bool {return self._fd != nil}
  /// Clears the value of `fd`. Subsequent reads from it will return its default value.
  mutating func clearFd() {self._fd = nil}

  var fileName: String {
    get {return _fileName ?? String()}
    set {_fileName = newValue}
  }
  /// Returns true if `fileName` has been explicitly set.
  var hasFileName: Bool {return self._fileName != nil}
  /// Clears the value of `fileName`. Subsequent reads from it will return its default value.
  mutating func clearFileName() {self._fileName = nil}

  var fileSize: UInt32 {
    get {return _fileSize ?? 0}
    set {_fileSize = newValue}
  }
  /// Returns true if `fileSize` has been explicitly set.
  var hasFileSize: Bool {return self._fileSize != nil}
  /// Clears the value of `fileSize`. Subsequent reads from it will return its default value.
  mutating func clearFileSize() {self._fileSize = nil}

  var fileCrc32: UInt32 {
    get {return _fileCrc32 ?? 0}
    set {_fileCrc32 = newValue}
  }
  /// Returns true if `fileCrc32` has been explicitly set.
  var hasFileCrc32: Bool {return self._fileCrc32 != nil}
  /// Clears the value of `fileCrc32`. Subsequent reads from it will return its default value.
  mutating func clearFileCrc32() {self._fileCrc32 = nil}

  var fileOffset: UInt32 {
    get {return _fileOffset ?? 0}
    set {_fileOffset = newValue}
  }
  /// Returns true if `fileOffset` has been explicitly set.
  var hasFileOffset: Bool {return self._fileOffset != nil}
  /// Clears the value of `fileOffset`. Subsequent reads from it will return its default value.
  mutating func clearFileOffset() {self._fileOffset = nil}

  var crc32AtOffset: UInt32 {
    get {return _crc32AtOffset ?? 0}
    set {_crc32AtOffset = newValue}
  }
  /// Returns true if `crc32AtOffset` has been explicitly set.
  var hasCrc32AtOffset: Bool {return self._crc32AtOffset != nil}
  /// Clears the value of `crc32AtOffset`. Subsequent reads from it will return its default value.
  mutating func clearCrc32AtOffset() {self._crc32AtOffset = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fd: FUType? = nil
  fileprivate var _fileName: String? = nil
  fileprivate var _fileSize: UInt32? = nil
  fileprivate var _fileCrc32: UInt32? = nil
  fileprivate var _fileOffset: UInt32? = nil
  fileprivate var _crc32AtOffset: UInt32? = nil
}

struct FUFileDesc {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var maxSize: UInt32 {
    get {return _maxSize ?? 0}
    set {_maxSize = newValue}
  }
  /// Returns true if `maxSize` has been explicitly set.
  var hasMaxSize: Bool {return self._maxSize != nil}
  /// Clears the value of `maxSize`. Subsequent reads from it will return its default value.
  mutating func clearMaxSize() {self._maxSize = nil}

  var valid: Bool {
    get {return _valid ?? false}
    set {_valid = newValue}
  }
  /// Returns true if `valid` has been explicitly set.
  var hasValid: Bool {return self._valid != nil}
  /// Clears the value of `valid`. Subsequent reads from it will return its default value.
  mutating func clearValid() {self._valid = nil}

  var info: FUFileInfo {
    get {return _info ?? FUFileInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _maxSize: UInt32? = nil
  fileprivate var _valid: Bool? = nil
  fileprivate var _info: FUFileInfo? = nil
}

struct FUExitResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fd: FUType {
    get {return _fd ?? .gps}
    set {_fd = newValue}
  }
  /// Returns true if `fd` has been explicitly set.
  var hasFd: Bool {return self._fd != nil}
  /// Clears the value of `fd`. Subsequent reads from it will return its default value.
  mutating func clearFd() {self._fd = nil}

  var status: FUExitResponse.Status {
    get {return _status ?? .ok}
    set {_status = newValue}
  }
  /// Returns true if `status` has been explicitly set.
  var hasStatus: Bool {return self._status != nil}
  /// Clears the value of `status`. Subsequent reads from it will return its default value.
  mutating func clearStatus() {self._status = nil}

  var desc: FUFileDesc {
    get {return _desc ?? FUFileDesc()}
    set {_desc = newValue}
  }
  /// Returns true if `desc` has been explicitly set.
  var hasDesc: Bool {return self._desc != nil}
  /// Clears the value of `desc`. Subsequent reads from it will return its default value.
  mutating func clearDesc() {self._desc = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum Status: SwiftProtobuf.Enum {
    typealias RawValue = Int
    case ok // = 0
    case errorParams // = 1
    case errorCrcMismatch // = 2
    case errorSizeMismatch // = 3
    case errorInner // = 4

    init() {
      self = .ok
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .ok
      case 1: self = .errorParams
      case 2: self = .errorCrcMismatch
      case 3: self = .errorSizeMismatch
      case 4: self = .errorInner
      default: return nil
      }
    }

    var rawValue: Int {
      switch self {
      case .ok: return 0
      case .errorParams: return 1
      case .errorCrcMismatch: return 2
      case .errorSizeMismatch: return 3
      case .errorInner: return 4
      }
    }

  }

  init() {}

  fileprivate var _fd: FUType? = nil
  fileprivate var _status: FUExitResponse.Status? = nil
  fileprivate var _desc: FUFileDesc? = nil
}

#if swift(>=4.2)

extension FUExitResponse.Status: CaseIterable {
  // Support synthesized by the compiler.
}

#endif  // swift(>=4.2)

struct FUDescResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var mtu: UInt32 {
    get {return _storage._mtu ?? 0}
    set {_uniqueStorage()._mtu = newValue}
  }
  /// Returns true if `mtu` has been explicitly set.
  var hasMtu: Bool {return _storage._mtu != nil}
  /// Clears the value of `mtu`. Subsequent reads from it will return its default value.
  mutating func clearMtu() {_uniqueStorage()._mtu = nil}

  var gps: FUFileDesc {
    get {return _storage._gps ?? FUFileDesc()}
    set {_uniqueStorage()._gps = newValue}
  }
  /// Returns true if `gps` has been explicitly set.
  var hasGps: Bool {return _storage._gps != nil}
  /// Clears the value of `gps`. Subsequent reads from it will return its default value.
  mutating func clearGps() {_uniqueStorage()._gps = nil}

  var font: FUFileDesc {
    get {return _storage._font ?? FUFileDesc()}
    set {_uniqueStorage()._font = newValue}
  }
  /// Returns true if `font` has been explicitly set.
  var hasFont: Bool {return _storage._font != nil}
  /// Clears the value of `font`. Subsequent reads from it will return its default value.
  mutating func clearFont() {_uniqueStorage()._font = nil}

  var mgaonline: FUFileDesc {
    get {return _storage._mgaonline ?? FUFileDesc()}
    set {_uniqueStorage()._mgaonline = newValue}
  }
  /// Returns true if `mgaonline` has been explicitly set.
  var hasMgaonline: Bool {return _storage._mgaonline != nil}
  /// Clears the value of `mgaonline`. Subsequent reads from it will return its default value.
  mutating func clearMgaonline() {_uniqueStorage()._mgaonline = nil}

  var customdial: FUFileDesc {
    get {return _storage._customdial ?? FUFileDesc()}
    set {_uniqueStorage()._customdial = newValue}
  }
  /// Returns true if `customdial` has been explicitly set.
  var hasCustomdial: Bool {return _storage._customdial != nil}
  /// Clears the value of `customdial`. Subsequent reads from it will return its default value.
  mutating func clearCustomdial() {_uniqueStorage()._customdial = nil}

  var firmware: FUFileDesc {
    get {return _storage._firmware ?? FUFileDesc()}
    set {_uniqueStorage()._firmware = newValue}
  }
  /// Returns true if `firmware` has been explicitly set.
  var hasFirmware: Bool {return _storage._firmware != nil}
  /// Clears the value of `firmware`. Subsequent reads from it will return its default value.
  mutating func clearFirmware() {_uniqueStorage()._firmware = nil}

  var bp: FUFileDesc {
    get {return _storage._bp ?? FUFileDesc()}
    set {_uniqueStorage()._bp = newValue}
  }
  /// Returns true if `bp` has been explicitly set.
  var hasBp: Bool {return _storage._bp != nil}
  /// Clears the value of `bp`. Subsequent reads from it will return its default value.
  mutating func clearBp() {_uniqueStorage()._bp = nil}

  var ctp: FUFileDesc {
    get {return _storage._ctp ?? FUFileDesc()}
    set {_uniqueStorage()._ctp = newValue}
  }
  /// Returns true if `ctp` has been explicitly set.
  var hasCtp: Bool {return _storage._ctp != nil}
  /// Clears the value of `ctp`. Subsequent reads from it will return its default value.
  mutating func clearCtp() {_uniqueStorage()._ctp = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct FilesUpdateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var params: FilesUpdateResponse.OneOf_Params? = nil

  var init_p: FUInitResponse {
    get {
      if case .init_p(let v)? = params {return v}
      return FUInitResponse()
    }
    set {params = .init_p(newValue)}
  }

  var data: FUDataResponse {
    get {
      if case .data(let v)? = params {return v}
      return FUDataResponse()
    }
    set {params = .data(newValue)}
  }

  var exit: FUExitResponse {
    get {
      if case .exit(let v)? = params {return v}
      return FUExitResponse()
    }
    set {params = .exit(newValue)}
  }

  var desc: FUDescResponse {
    get {
      if case .desc(let v)? = params {return v}
      return FUDescResponse()
    }
    set {params = .desc(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Params: Equatable {
    case init_p(FUInitResponse)
    case data(FUDataResponse)
    case exit(FUExitResponse)
    case desc(FUDescResponse)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .init_p: return {
        guard case .init_p(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .data: return {
        guard case .data(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .exit: return {
        guard case .exit(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .desc: return {
        guard case .desc(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      }
    }

  #if !swift(>=4.1)
    static func ==(lhs: FilesUpdateResponse.OneOf_Params, rhs: FilesUpdateResponse.OneOf_Params) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.init_p, .init_p): return {
        guard case .init_p(let l) = lhs, case .init_p(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.exit, .exit): return {
        guard case .exit(let l) = lhs, case .exit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.desc, .desc): return {
        guard case .desc(let l) = lhs, case .desc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct FUInitRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var initInfo: FUFileInfo {
    get {return _initInfo ?? FUFileInfo()}
    set {_initInfo = newValue}
  }
  /// Returns true if `initInfo` has been explicitly set.
  var hasInitInfo: Bool {return self._initInfo != nil}
  /// Clears the value of `initInfo`. Subsequent reads from it will return its default value.
  mutating func clearInitInfo() {self._initInfo = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _initInfo: FUFileInfo? = nil
}

struct FUDataRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fd: FUType {
    get {return _fd ?? .gps}
    set {_fd = newValue}
  }
  /// Returns true if `fd` has been explicitly set.
  var hasFd: Bool {return self._fd != nil}
  /// Clears the value of `fd`. Subsequent reads from it will return its default value.
  mutating func clearFd() {self._fd = nil}

  var fileOffset: UInt32 {
    get {return _fileOffset ?? 0}
    set {_fileOffset = newValue}
  }
  /// Returns true if `fileOffset` has been explicitly set.
  var hasFileOffset: Bool {return self._fileOffset != nil}
  /// Clears the value of `fileOffset`. Subsequent reads from it will return its default value.
  mutating func clearFileOffset() {self._fileOffset = nil}

  var crc32AtOffset: UInt32 {
    get {return _crc32AtOffset ?? 0}
    set {_crc32AtOffset = newValue}
  }
  /// Returns true if `crc32AtOffset` has been explicitly set.
  var hasCrc32AtOffset: Bool {return self._crc32AtOffset != nil}
  /// Clears the value of `crc32AtOffset`. Subsequent reads from it will return its default value.
  mutating func clearCrc32AtOffset() {self._crc32AtOffset = nil}

  var buf: Data {
    get {return _buf ?? Data()}
    set {_buf = newValue}
  }
  /// Returns true if `buf` has been explicitly set.
  var hasBuf: Bool {return self._buf != nil}
  /// Clears the value of `buf`. Subsequent reads from it will return its default value.
  mutating func clearBuf() {self._buf = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fd: FUType? = nil
  fileprivate var _fileOffset: UInt32? = nil
  fileprivate var _crc32AtOffset: UInt32? = nil
  fileprivate var _buf: Data? = nil
}

struct FUExitRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fd: FUType {
    get {return _fd ?? .gps}
    set {_fd = newValue}
  }
  /// Returns true if `fd` has been explicitly set.
  var hasFd: Bool {return self._fd != nil}
  /// Clears the value of `fd`. Subsequent reads from it will return its default value.
  mutating func clearFd() {self._fd = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _fd: FUType? = nil
}

struct FilesUpdateRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var params: FilesUpdateRequest.OneOf_Params? = nil

  var init_p: FUInitRequest {
    get {
      if case .init_p(let v)? = params {return v}
      return FUInitRequest()
    }
    set {params = .init_p(newValue)}
  }

  var data: FUDataRequest {
    get {
      if case .data(let v)? = params {return v}
      return FUDataRequest()
    }
    set {params = .data(newValue)}
  }

  var exit: FUExitRequest {
    get {
      if case .exit(let v)? = params {return v}
      return FUExitRequest()
    }
    set {params = .exit(newValue)}
  }

  var desc: Bool {
    get {
      if case .desc(let v)? = params {return v}
      return false
    }
    set {params = .desc(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Params: Equatable {
    case init_p(FUInitRequest)
    case data(FUDataRequest)
    case exit(FUExitRequest)
    case desc(Bool)

    fileprivate var isInitialized: Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch self {
      case .init_p: return {
        guard case .init_p(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .data: return {
        guard case .data(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      case .exit: return {
        guard case .exit(let v) = self else { preconditionFailure() }
        return v.isInitialized
      }()
      default: return true
      }
    }

  #if !swift(>=4.1)
    static func ==(lhs: FilesUpdateRequest.OneOf_Params, rhs: FilesUpdateRequest.OneOf_Params) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.init_p, .init_p): return {
        guard case .init_p(let l) = lhs, case .init_p(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.data, .data): return {
        guard case .data(let l) = lhs, case .data(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.exit, .exit): return {
        guard case .exit(let l) = lhs, case .exit(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.desc, .desc): return {
        guard case .desc(let l) = lhs, case .desc(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension FUType: @unchecked Sendable {}
extension FUInitResponse: @unchecked Sendable {}
extension FUInitResponse.Status: @unchecked Sendable {}
extension FUDataResponse: @unchecked Sendable {}
extension FUDataResponse.Status: @unchecked Sendable {}
extension FUFileInfo: @unchecked Sendable {}
extension FUFileDesc: @unchecked Sendable {}
extension FUExitResponse: @unchecked Sendable {}
extension FUExitResponse.Status: @unchecked Sendable {}
extension FUDescResponse: @unchecked Sendable {}
extension FilesUpdateResponse: @unchecked Sendable {}
extension FilesUpdateResponse.OneOf_Params: @unchecked Sendable {}
extension FUInitRequest: @unchecked Sendable {}
extension FUDataRequest: @unchecked Sendable {}
extension FUExitRequest: @unchecked Sendable {}
extension FilesUpdateRequest: @unchecked Sendable {}
extension FilesUpdateRequest.OneOf_Params: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension FUType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "GPS"),
    1: .same(proto: "FONT"),
    2: .same(proto: "MGAONLINE"),
    3: .same(proto: "CUSTOMDIAL"),
    4: .same(proto: "FIRMWARE"),
    5: .same(proto: "BP"),
    6: .same(proto: "CTP"),
  ]
}

extension FUInitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FUInitResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fd"),
    2: .same(proto: "status"),
  ]

  public var isInitialized: Bool {
    if self._fd == nil {return false}
    if self._status == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._fd) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fd {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FUInitResponse, rhs: FUInitResponse) -> Bool {
    if lhs._fd != rhs._fd {return false}
    if lhs._status != rhs._status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FUInitResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "ERROR_PARAMS"),
    2: .same(proto: "ERROR_INNER"),
  ]
}

extension FUDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FUDataResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fd"),
    2: .same(proto: "status"),
    3: .standard(proto: "file_offset"),
    4: .standard(proto: "crc32_at_offset"),
  ]

  public var isInitialized: Bool {
    if self._fd == nil {return false}
    if self._status == nil {return false}
    if self._fileOffset == nil {return false}
    if self._crc32AtOffset == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._fd) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._fileOffset) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._crc32AtOffset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fd {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._fileOffset {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._crc32AtOffset {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FUDataResponse, rhs: FUDataResponse) -> Bool {
    if lhs._fd != rhs._fd {return false}
    if lhs._status != rhs._status {return false}
    if lhs._fileOffset != rhs._fileOffset {return false}
    if lhs._crc32AtOffset != rhs._crc32AtOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FUDataResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "ERROR_PARAMS"),
    2: .same(proto: "ERROR_OFFSET_MISMATCH"),
    3: .same(proto: "ERROR_CRC32_MISMATCH"),
    4: .same(proto: "ERROR_INNER"),
  ]
}

extension FUFileInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FUFileInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fd"),
    2: .standard(proto: "file_name"),
    3: .standard(proto: "file_size"),
    4: .standard(proto: "file_crc32"),
    5: .standard(proto: "file_offset"),
    6: .standard(proto: "crc32_at_offset"),
  ]

  public var isInitialized: Bool {
    if self._fd == nil {return false}
    if self._fileName == nil {return false}
    if self._fileSize == nil {return false}
    if self._fileCrc32 == nil {return false}
    if self._fileOffset == nil {return false}
    if self._crc32AtOffset == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._fd) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._fileName) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._fileSize) }()
      case 4: try { try decoder.decodeSingularFixed32Field(value: &self._fileCrc32) }()
      case 5: try { try decoder.decodeSingularFixed32Field(value: &self._fileOffset) }()
      case 6: try { try decoder.decodeSingularFixed32Field(value: &self._crc32AtOffset) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fd {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fileName {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._fileSize {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._fileCrc32 {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._fileOffset {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._crc32AtOffset {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FUFileInfo, rhs: FUFileInfo) -> Bool {
    if lhs._fd != rhs._fd {return false}
    if lhs._fileName != rhs._fileName {return false}
    if lhs._fileSize != rhs._fileSize {return false}
    if lhs._fileCrc32 != rhs._fileCrc32 {return false}
    if lhs._fileOffset != rhs._fileOffset {return false}
    if lhs._crc32AtOffset != rhs._crc32AtOffset {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FUFileDesc: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FUFileDesc"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_size"),
    2: .same(proto: "valid"),
    3: .same(proto: "info"),
  ]

  public var isInitialized: Bool {
    if self._maxSize == nil {return false}
    if self._valid == nil {return false}
    if self._info == nil {return false}
    if let v = self._info, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed32Field(value: &self._maxSize) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._valid) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._maxSize {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._valid {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FUFileDesc, rhs: FUFileDesc) -> Bool {
    if lhs._maxSize != rhs._maxSize {return false}
    if lhs._valid != rhs._valid {return false}
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FUExitResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FUExitResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fd"),
    2: .same(proto: "status"),
    3: .same(proto: "desc"),
  ]

  public var isInitialized: Bool {
    if self._fd == nil {return false}
    if self._status == nil {return false}
    if self._desc == nil {return false}
    if let v = self._desc, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._fd) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._status) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._desc) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fd {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._status {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._desc {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FUExitResponse, rhs: FUExitResponse) -> Bool {
    if lhs._fd != rhs._fd {return false}
    if lhs._status != rhs._status {return false}
    if lhs._desc != rhs._desc {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FUExitResponse.Status: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OK"),
    1: .same(proto: "ERROR_PARAMS"),
    2: .same(proto: "ERROR_CRC_MISMATCH"),
    3: .same(proto: "ERROR_SIZE_MISMATCH"),
    4: .same(proto: "ERROR_INNER"),
  ]
}

extension FUDescResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FUDescResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "mtu"),
    2: .same(proto: "gps"),
    3: .same(proto: "font"),
    4: .same(proto: "mgaonline"),
    5: .same(proto: "customdial"),
    6: .same(proto: "firmware"),
    7: .same(proto: "bp"),
    8: .same(proto: "ctp"),
  ]

  fileprivate class _StorageClass {
    var _mtu: UInt32? = nil
    var _gps: FUFileDesc? = nil
    var _font: FUFileDesc? = nil
    var _mgaonline: FUFileDesc? = nil
    var _customdial: FUFileDesc? = nil
    var _firmware: FUFileDesc? = nil
    var _bp: FUFileDesc? = nil
    var _ctp: FUFileDesc? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _mtu = source._mtu
      _gps = source._gps
      _font = source._font
      _mgaonline = source._mgaonline
      _customdial = source._customdial
      _firmware = source._firmware
      _bp = source._bp
      _ctp = source._ctp
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._mtu == nil {return false}
      if let v = _storage._gps, !v.isInitialized {return false}
      if let v = _storage._font, !v.isInitialized {return false}
      if let v = _storage._mgaonline, !v.isInitialized {return false}
      if let v = _storage._customdial, !v.isInitialized {return false}
      if let v = _storage._firmware, !v.isInitialized {return false}
      if let v = _storage._bp, !v.isInitialized {return false}
      if let v = _storage._ctp, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularFixed32Field(value: &_storage._mtu) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._gps) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._font) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._mgaonline) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._customdial) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._firmware) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._bp) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._ctp) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._mtu {
        try visitor.visitSingularFixed32Field(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._gps {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._font {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._mgaonline {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._customdial {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._firmware {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._bp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._ctp {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FUDescResponse, rhs: FUDescResponse) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._mtu != rhs_storage._mtu {return false}
        if _storage._gps != rhs_storage._gps {return false}
        if _storage._font != rhs_storage._font {return false}
        if _storage._mgaonline != rhs_storage._mgaonline {return false}
        if _storage._customdial != rhs_storage._customdial {return false}
        if _storage._firmware != rhs_storage._firmware {return false}
        if _storage._bp != rhs_storage._bp {return false}
        if _storage._ctp != rhs_storage._ctp {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilesUpdateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FilesUpdateResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "init"),
    2: .same(proto: "data"),
    3: .same(proto: "exit"),
    4: .same(proto: "desc"),
  ]

  public var isInitialized: Bool {
    if let v = self.params, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: FUInitResponse?
        var hadOneofValue = false
        if let current = self.params {
          hadOneofValue = true
          if case .init_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.params = .init_p(v)
        }
      }()
      case 2: try {
        var v: FUDataResponse?
        var hadOneofValue = false
        if let current = self.params {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.params = .data(v)
        }
      }()
      case 3: try {
        var v: FUExitResponse?
        var hadOneofValue = false
        if let current = self.params {
          hadOneofValue = true
          if case .exit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.params = .exit(v)
        }
      }()
      case 4: try {
        var v: FUDescResponse?
        var hadOneofValue = false
        if let current = self.params {
          hadOneofValue = true
          if case .desc(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.params = .desc(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.params {
    case .init_p?: try {
      guard case .init_p(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .data?: try {
      guard case .data(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .exit?: try {
      guard case .exit(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .desc?: try {
      guard case .desc(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FilesUpdateResponse, rhs: FilesUpdateResponse) -> Bool {
    if lhs.params != rhs.params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FUInitRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FUInitRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "init_info"),
  ]

  public var isInitialized: Bool {
    if self._initInfo == nil {return false}
    if let v = self._initInfo, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._initInfo) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._initInfo {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FUInitRequest, rhs: FUInitRequest) -> Bool {
    if lhs._initInfo != rhs._initInfo {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FUDataRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FUDataRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fd"),
    2: .standard(proto: "file_offset"),
    3: .standard(proto: "crc32_at_offset"),
    4: .same(proto: "buf"),
  ]

  public var isInitialized: Bool {
    if self._fd == nil {return false}
    if self._fileOffset == nil {return false}
    if self._crc32AtOffset == nil {return false}
    if self._buf == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._fd) }()
      case 2: try { try decoder.decodeSingularFixed32Field(value: &self._fileOffset) }()
      case 3: try { try decoder.decodeSingularFixed32Field(value: &self._crc32AtOffset) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self._buf) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fd {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._fileOffset {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._crc32AtOffset {
      try visitor.visitSingularFixed32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._buf {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FUDataRequest, rhs: FUDataRequest) -> Bool {
    if lhs._fd != rhs._fd {return false}
    if lhs._fileOffset != rhs._fileOffset {return false}
    if lhs._crc32AtOffset != rhs._crc32AtOffset {return false}
    if lhs._buf != rhs._buf {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FUExitRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FUExitRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fd"),
  ]

  public var isInitialized: Bool {
    if self._fd == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._fd) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._fd {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FUExitRequest, rhs: FUExitRequest) -> Bool {
    if lhs._fd != rhs._fd {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilesUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "FilesUpdateRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "init"),
    2: .same(proto: "data"),
    3: .same(proto: "exit"),
    4: .same(proto: "desc"),
  ]

  public var isInitialized: Bool {
    if let v = self.params, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: FUInitRequest?
        var hadOneofValue = false
        if let current = self.params {
          hadOneofValue = true
          if case .init_p(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.params = .init_p(v)
        }
      }()
      case 2: try {
        var v: FUDataRequest?
        var hadOneofValue = false
        if let current = self.params {
          hadOneofValue = true
          if case .data(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.params = .data(v)
        }
      }()
      case 3: try {
        var v: FUExitRequest?
        var hadOneofValue = false
        if let current = self.params {
          hadOneofValue = true
          if case .exit(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.params = .exit(v)
        }
      }()
      case 4: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.params != nil {try decoder.handleConflictingOneOf()}
          self.params = .desc(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.params {
    case .init_p?: try {
      guard case .init_p(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .data?: try {
      guard case .data(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .exit?: try {
      guard case .exit(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .desc?: try {
      guard case .desc(let v)? = self.params else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: FilesUpdateRequest, rhs: FilesUpdateRequest) -> Bool {
    if lhs.params != rhs.params {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
